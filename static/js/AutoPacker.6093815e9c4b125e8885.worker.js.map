{"version":3,"sources":["../webpack/bootstrap","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../../src/rectanglePacker.ts","../../src/Rect.ts","../../src/GuillotineBinPack.ts","workers/AutoPacker.worker.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_arrayLikeToArray","arr","len","length","arr2","Array","_toConsumableArray","isArray","iter","iterator","from","minLen","toString","slice","constructor","test","TypeError","TheState","FreeRectChoiceHeuristic","GuillotineSplitHeuristic","this","binWidth","binHeight","freeRectangles","push","rects","j","height","score","packing","list","sizes","widthList","map","item","width","heightList","minWidth","Math","min","apply","minHeight","maxWidth","reduce","a","b","maxHeight","maxMin","max","state","placed","packer","GuillotineBinPack","ceil","InsertSizes","usedRectangles","floor","ctx","self","addEventListener","msg","data","postMessage"],"mappings":"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","file":"static/js/AutoPacker.6093815e9c4b125e8885.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayWithoutHoles from \"@babel/runtime/helpers/esm/arrayWithoutHoles\";\nimport iterableToArray from \"@babel/runtime/helpers/esm/iterableToArray\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableSpread from \"@babel/runtime/helpers/esm/nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","var SUCCESS = 1;\nvar FAIL = 0;\n/**\n * 放置状态枚举\n */\nvar TheState;\n(function (TheState) {\n    TheState[TheState[\"DO_PLACING\"] = 0] = \"DO_PLACING\";\n    TheState[TheState[\"DEC_WIDTH\"] = 1] = \"DEC_WIDTH\";\n    TheState[TheState[\"INC_HEIGHT\"] = 2] = \"INC_HEIGHT\";\n    TheState[TheState[\"STOP\"] = 3] = \"STOP\";\n})(TheState || (TheState = {}));\nfunction sortForAreaOrHeight(ar, br) {\n    var a = ar.width * ar.height;\n    var b = br.width * br.height;\n    if (a < b) {\n        return 1;\n    }\n    else if (a > b) {\n        return -1;\n    }\n    else if (ar.height > br.height) {\n        return -1;\n    }\n    else if (ar.height < br.height) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\n/**\n * 创建 Placing\n * @param enclosingWidth 区域宽\n * @param enclosingHeight 区域高\n */\nfunction allocPlacing(enclosingWidth, enclosingHeight) {\n    var cell = {\n        height: enclosingHeight,\n        occupied: 0,\n        nextCell: null,\n    };\n    var cols = {\n        width: enclosingWidth,\n        nextCol: null,\n        cell: cell,\n    };\n    var placing = {\n        enclosingWidth: enclosingWidth,\n        enclosingHeight: enclosingHeight,\n        cols: cols,\n    };\n    return placing;\n}\n/**\n * 释放 Placing 对象\n * @param placing 即将释放的 Placing\n */\nfunction freePlacing(placing) {\n    if (placing === null) {\n        return;\n    }\n    // 循环释放列和单元格\n    var col = placing.cols;\n    while (col !== null) {\n        // 释放列中所有单元格\n        var cell = col.cell;\n        while (cell !== null) {\n            var tempR = cell;\n            cell = cell.nextCell;\n            tempR.nextCell = null;\n        }\n        // 保存下一个列，释放当前列\n        var tempC = col;\n        col = col.nextCol;\n        tempC.nextCol = null;\n        tempC.cell = null;\n    }\n    placing.cols = null;\n    return;\n}\n/**\n * 尝试调整列高度\n * @param col 列\n * @param height 高度\n * @param cellR 区域\n */\nfunction tryFitHeightInCol(col, height, cellR) {\n    /**\n     * 循环列中的单元格\n     * 查找高度大于 height 的连续未被占用的单元格序列。\n     * 结果存储在 cellR 中\n     */\n    if (col == null) {\n        console.error(\"Error. col pointer was null.\\n\");\n        return FAIL;\n    }\n    else if (height <= 0) {\n        console.error(\"Error. height must be positive.\\n\");\n        return FAIL;\n    }\n    var sumHeight = 0;\n    cellR.startIndex = 0;\n    // 循环列中的单元格\n    for (var cell = col.cell, i = 0; cell != null; cell = cell.nextCell, i++) {\n        /**\n         * 如果单元格被占用, 重置高度总和并且更新 startIndex\n         * 否则, 检查高度是否可满足\n         */\n        if (cell.occupied) {\n            sumHeight = 0;\n            cellR.startIndex = i + 1;\n        }\n        else {\n            if (sumHeight + cell.height > height) {\n                cellR.endIndex = i;\n                cellR.overshoot = height - sumHeight;\n                return SUCCESS;\n            }\n            else if (sumHeight + cell.height === height) {\n                // 无需拆分\n                cellR.endIndex = i;\n                cellR.overshoot = 0;\n                return SUCCESS;\n            }\n            sumHeight += cell.height;\n        }\n    }\n    // 如果循环到达这里，说明矩形不适合此列\n    return FAIL;\n}\n/**\n * 查找符合偏移的单元格\n * @param base 基础单元格\n * @param offset 偏移量\n */\nfunction stepOffset(base, offset) {\n    if (base == null) {\n        console.error(\"Error. Basepointer was null.\\n\");\n        return null;\n    }\n    var cell = base;\n    for (var i = 0; i < offset; i++) {\n        cell = cell.nextCell;\n        if (cell == null) {\n            console.error(\"Error. Offset to large.\\n\");\n            return null;\n        }\n    }\n    return cell;\n}\n/**\n * 查找可容纳矩形的区域\n * @param placing 区域\n * @param rectangle 矩形\n * @param reg 位置\n */\nfunction findRegion(placing, rectangle, reg) {\n    // 遍历所有列\n    for (var col = placing.cols, i = 0; col != null; col = col.nextCol, i++) {\n        var colR = {\n            startIndex: 0,\n            endIndex: 0,\n            overshoot: 0,\n        };\n        var cellR = {\n            startIndex: 0,\n            endIndex: 0,\n            overshoot: 0,\n        };\n        var sumWidth = 0;\n        var temp = void 0;\n        // 检查此列是否适合矩形的高度\n        if (!tryFitHeightInCol(col, rectangle.height, cellR)) {\n            // 不合适\n            continue;\n        }\n        // 循环输入列，并检查i的单元格在整个矩形宽度上是否为空\n        colR.startIndex = i;\n        colR.endIndex = i;\n        for (temp = col; temp != null; temp = temp.nextCol) {\n            var cell = stepOffset(temp.cell, cellR.startIndex);\n            if (cell === null || cell === void 0 ? void 0 : cell.occupied) {\n                // 不合适，无法放置\n                break;\n            }\n            else {\n                if (sumWidth + temp.width > rectangle.width) {\n                    // 需要拆分单元格\n                    colR.overshoot = rectangle.width - sumWidth;\n                    reg.colR = colR;\n                    reg.cellR = cellR;\n                    return SUCCESS;\n                }\n                else if (sumWidth + temp.width === rectangle.width) {\n                    // 不需要拆分单元格\n                    colR.overshoot = 0;\n                    reg.colR = colR;\n                    reg.cellR = cellR;\n                    return SUCCESS;\n                }\n                sumWidth += temp.width;\n                colR.endIndex++;\n            }\n        }\n    }\n    return FAIL;\n}\nfunction split(placing, reg) {\n    var colSplitMe = null;\n    // 水平拆分单元格\n    for (var col = placing.cols, i = 0; col != null; col = col.nextCol, i++) {\n        // 仅 overshoot > 0 时才拆分列\n        if (reg.cellR.overshoot > 0) {\n            var cell = stepOffset(col.cell, reg.cellR.endIndex);\n            if (cell == null)\n                continue;\n            var newCell = {\n                // 设置新的单元格\n                height: cell.height - reg.cellR.overshoot,\n                occupied: cell.occupied,\n                nextCell: cell.nextCell,\n            };\n            // 更新旧的单元格\n            cell.height = reg.cellR.overshoot;\n            cell.nextCell = newCell;\n        }\n        // 保存要拆分的列\n        if (i === reg.colR.endIndex) {\n            colSplitMe = col;\n        }\n    }\n    // 仅 overshoot > 0 时才拆分列\n    if (reg.colR.overshoot > 0) {\n        // 纵向拆分列\n        if (colSplitMe == null) {\n            console.log(\"Error. Failed to find column to split.\\n\");\n            return FAIL;\n        }\n        var newCol = {\n            width: colSplitMe.width - reg.colR.overshoot,\n            nextCol: null,\n            cell: {\n                height: 0,\n                occupied: 0,\n                nextCell: null,\n            },\n        };\n        // 设置一个新列\n        var tail = newCol.cell;\n        for (var cell = colSplitMe.cell; cell != null; cell = cell.nextCell) {\n            tail.height = cell.height;\n            tail.occupied = cell.occupied;\n            if (cell.nextCell == null) {\n                tail.nextCell = null;\n                break;\n            }\n            tail.nextCell = {\n                height: 0,\n                occupied: 0,\n                nextCell: null,\n            };\n            tail = tail.nextCell;\n        }\n        newCol.nextCol = colSplitMe.nextCol;\n        // 更新旧的列\n        colSplitMe.width = reg.colR.overshoot;\n        colSplitMe.nextCol = newCol;\n    }\n    return SUCCESS;\n}\n/**\n * 更新单元格，使其放置在正确的位置\n * @param placing 放置区域\n * @param rectangle 矩形\n * @param reg Region\n */\nfunction update(placing, rectangle, reg) {\n    if (!rectangle.__id || rectangle.__id === 0) {\n        console.error(\"Error. Rectangle can't have id = \" + rectangle.__id + \".\\n\");\n        return FAIL;\n    }\n    var x = 0;\n    var y = 0;\n    var done = 0;\n    // 遍历每一列\n    for (var col = placing.cols, i = 0; col != null; col = col.nextCol, i++) {\n        if (i > reg.colR.endIndex) {\n            break;\n        }\n        if (i >= reg.colR.startIndex) {\n            // 遍历单元格\n            for (var cell = col.cell, k = 0; cell != null; cell = cell.nextCell, k++) {\n                if (k > reg.cellR.endIndex) {\n                    break;\n                }\n                if (k >= reg.cellR.startIndex) {\n                    cell.occupied = rectangle.__id;\n                    if (!done) {\n                        rectangle.x = x;\n                        rectangle.y = y;\n                        done = 1;\n                    }\n                }\n                y += cell.height;\n            }\n        }\n        x += col.width;\n    }\n    return SUCCESS;\n}\nfunction addRec(p, r) {\n    var reg = {\n        colR: {\n            startIndex: 0,\n            endIndex: 0,\n            overshoot: 0,\n        },\n        cellR: {\n            startIndex: 0,\n            endIndex: 0,\n            overshoot: 0,\n        },\n    };\n    if (findRegion(p, r, reg) === FAIL) {\n        return FAIL;\n    }\n    if (split(p, reg) === FAIL) {\n        console.error(\"Error in splitting.\\n\");\n        return FAIL;\n    }\n    if (update(p, r, reg) === FAIL) {\n        console.error(\"Error in updating.\\n\");\n        return FAIL;\n    }\n    return SUCCESS;\n}\n/**\n * 尝试执行内容排列\n * @param list 矩形列表\n * @param enclosingWidth 容器宽度\n * @param enclosingHeight 容器高度\n */\nfunction doPlacing(list, enclosingWidth, enclosingHeight) {\n    var p = allocPlacing(enclosingWidth, enclosingHeight);\n    var len = list.length;\n    for (var i = 0; i < len; i++) {\n        if (!addRec(p, list[i])) {\n            freePlacing(p);\n            p = null;\n            return FAIL;\n        }\n    }\n    freePlacing(p);\n    p = null;\n    return SUCCESS;\n}\n/**\n * 计算所有矩形的宽高和\n * @param list 矩形列表\n */\nfunction sumWH(list) {\n    var len = list.length;\n    var width = 0;\n    var height = 0;\n    for (var i = 0; i < len; i++) {\n        width += list[i].width;\n        height += list[i].height;\n    }\n    return {\n        width: width,\n        height: height,\n    };\n}\n/**\n * 查找所有矩形中，宽度最大值与高度最大值\n * @param list 矩形列表\n */\nfunction maxWH(list) {\n    var len = list.length;\n    var width = 0;\n    var height = 0;\n    for (var i = 0; i < len; i++) {\n        if (list[i].width >= width) {\n            width = list[i].width;\n        }\n        if (list[i].height >= height) {\n            height = list[i].height;\n        }\n    }\n    return {\n        width: width,\n        height: height,\n    };\n}\n/**\n * 计算所有矩形总面积\n * @param list 矩形列表\n */\nfunction totalArea(list) {\n    var len = list.length;\n    var area = 0;\n    for (var i = 0; i < len; i++) {\n        area += list[i].height * list[i].width;\n    }\n    return area;\n}\n/**\n * 计算容器需要的最大宽度\n * @param list 矩形列表\n */\nfunction placingWidth(list) {\n    var len = list.length;\n    var width = 0;\n    for (var i = 0; i < len; i++) {\n        if (list[i].x === -1) {\n            console.error(\"Error. Can't compute placing_width if not all rectangles have been placed.\\n\");\n            return -1;\n        }\n        if (list[i].width + list[i].x >= width) {\n            width = list[i].width + list[i].x;\n        }\n    }\n    return width;\n}\n/**\n * 放置最小区域算法\n * @param list 矩形列表\n * @param en 初始区域\n */\nfunction areapackAlgorithm(list, en) {\n    var _a = maxWH(list), maxWidth = _a.width, maxHeight = _a.height;\n    var sumWidth = sumWH(list).width;\n    var minWidth = -1;\n    var minHeight = -1;\n    var area = -1;\n    var status;\n    var state;\n    var totArea = totalArea(list);\n    /* 初始化高度为最大高度 */\n    en.height = maxHeight;\n    en.width = sumWidth;\n    area = en.height * en.width;\n    state = TheState.DO_PLACING;\n    /* 从封闭区域(w=sum, h=max)开始查找\n     * do placing\n     * - 如果成功，保存区域\n     * - 如果失败，尝试新的封闭区域\n     *\n     * 减小宽度，否则增加高度直到成功\n     *\n     * 如果 en width=max: 停止\n     *\n     * */\n    var loop = 1;\n    while (loop) {\n        switch (state) {\n            case TheState.DO_PLACING:\n                /**\n                 * 尝试将矩形放置在封闭矩形中。\n                 * 如果成功，保存该区域，然后尝试减小包装宽度。\n                 * 如果失败，增加高度并重试。\n                 */\n                status = doPlacing(list, en.width, en.height);\n                if (status === 1) {\n                    en.width = placingWidth(list);\n                    area = en.height * en.width;\n                    minWidth = en.width;\n                    minHeight = en.height;\n                    state = TheState.DEC_WIDTH;\n                }\n                else {\n                    state = TheState.INC_HEIGHT;\n                }\n                break;\n            case TheState.DEC_WIDTH:\n                /**\n                 * 减小包装宽度，然后尝试再次放置。\n                 * 如果新宽度小于矩形的最大宽度，则停止算法并提出最佳解决方案\n                 */\n                en.width--;\n                if (en.width < maxWidth) {\n                    state = TheState.STOP;\n                }\n                else {\n                    state = TheState.DO_PLACING;\n                }\n                break;\n            case TheState.INC_HEIGHT:\n                /**\n                 * 增加封闭高度，然后尝试再次放置。\n                 * 但是，如果新的高度使封闭区域小于所有矩形的总面积，则增加封闭高度并重新开始。\n                 * 如果封闭区域比目前最好的封闭区域大，则减小封闭宽度并重新开始。\n                 */\n                en.height++;\n                if (en.height * en.width < totArea) {\n                    state = TheState.INC_HEIGHT;\n                }\n                else if (en.height * en.width >= area) {\n                    state = TheState.DEC_WIDTH;\n                }\n                else {\n                    state = TheState.DO_PLACING;\n                }\n                break;\n            case TheState.STOP:\n                // 计算结束\n                loop = 0;\n                break;\n        }\n    }\n    if (minWidth === -1 || minHeight === -1) {\n        return FAIL;\n    }\n    // 以最佳的宽度和高度进行最后放置\n    status = doPlacing(list, minWidth, minHeight);\n    return SUCCESS;\n}\n/**\n * 打包给到的所有矩形\n * @param rectangleSizes 带有宽高的矩形列表\n */\nexport function rectanglePacker(rectangleSizes) {\n    if (!Array.isArray(rectangleSizes) || rectangleSizes.length === 0)\n        return [];\n    var enclosing = { width: 0, height: 0 };\n    var rectList = rectangleSizes.map(function (_a, i) {\n        var width = _a.width, height = _a.height;\n        if (!width || !height)\n            throw new Error(\"Rectangle width and height must be an integer\");\n        return {\n            width: width,\n            height: height,\n            x: -1,\n            y: -1,\n            __id: i + 1,\n        };\n    });\n    var result = areapackAlgorithm(rectList, enclosing);\n    if (result === FAIL) {\n        console.error(\"Unexpected error in algorithm implementation\");\n        return [];\n    }\n    rectList.forEach(function (rectangle) { return delete rectangle.__id; });\n    return rectList;\n}\nexport function rectanglePackerMutation(rectangleSizes) {\n    var list = rectanglePacker(rectangleSizes);\n    rectangleSizes.forEach(function (rs, i) {\n        rs.x = list[i].x;\n        rs.y = list[i].y;\n    });\n    return rectangleSizes;\n}\n//# sourceMappingURL=rectanglePacker.js.map","var Rect = /** @class */ (function () {\n    function Rect(x, y, width, height) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        if (width === void 0) { width = 0; }\n        if (height === void 0) { height = 0; }\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    Rect.IsContainedIn = function (a, b) {\n        return (a.x >= b.x &&\n            a.y >= b.y &&\n            a.x + a.width <= b.x + b.width &&\n            a.y + a.height <= b.y + b.height);\n    };\n    return Rect;\n}());\nexport default Rect;\n//# sourceMappingURL=Rect.js.map","import Rect from \"./Rect\";\n/// Specifies the different choice heuristics that can be used when deciding which of the free subrectangles\n/// to place the to-be-packed rectangle into.\nvar FreeRectChoiceHeuristic;\n(function (FreeRectChoiceHeuristic) {\n    FreeRectChoiceHeuristic[FreeRectChoiceHeuristic[\"RectBestAreaFit\"] = 0] = \"RectBestAreaFit\";\n    FreeRectChoiceHeuristic[FreeRectChoiceHeuristic[\"RectBestShortSideFit\"] = 1] = \"RectBestShortSideFit\";\n    FreeRectChoiceHeuristic[FreeRectChoiceHeuristic[\"RectBestLongSideFit\"] = 2] = \"RectBestLongSideFit\";\n    FreeRectChoiceHeuristic[FreeRectChoiceHeuristic[\"RectWorstAreaFit\"] = 3] = \"RectWorstAreaFit\";\n    FreeRectChoiceHeuristic[FreeRectChoiceHeuristic[\"RectWorstShortSideFit\"] = 4] = \"RectWorstShortSideFit\";\n    FreeRectChoiceHeuristic[FreeRectChoiceHeuristic[\"RectWorstLongSideFit\"] = 5] = \"RectWorstLongSideFit\";\n})(FreeRectChoiceHeuristic || (FreeRectChoiceHeuristic = {}));\n/// Specifies the different choice heuristics that can be used when the packer needs to decide whether to\n/// subdivide the remaining free space in horizontal or vertical direction.\nvar GuillotineSplitHeuristic;\n(function (GuillotineSplitHeuristic) {\n    GuillotineSplitHeuristic[GuillotineSplitHeuristic[\"SplitShorterLeftoverAxis\"] = 0] = \"SplitShorterLeftoverAxis\";\n    GuillotineSplitHeuristic[GuillotineSplitHeuristic[\"SplitLongerLeftoverAxis\"] = 1] = \"SplitLongerLeftoverAxis\";\n    GuillotineSplitHeuristic[GuillotineSplitHeuristic[\"SplitMinimizeArea\"] = 2] = \"SplitMinimizeArea\";\n    GuillotineSplitHeuristic[GuillotineSplitHeuristic[\"SplitMaximizeArea\"] = 3] = \"SplitMaximizeArea\";\n    GuillotineSplitHeuristic[GuillotineSplitHeuristic[\"SplitShorterAxis\"] = 4] = \"SplitShorterAxis\";\n    GuillotineSplitHeuristic[GuillotineSplitHeuristic[\"SplitLongerAxis\"] = 5] = \"SplitLongerAxis\";\n})(GuillotineSplitHeuristic || (GuillotineSplitHeuristic = {}));\nvar GuillotineBinPack = /** @class */ (function () {\n    function GuillotineBinPack(binWidth, binHeight, allowFlip) {\n        if (binWidth === void 0) { binWidth = 0; }\n        if (binHeight === void 0) { binHeight = 0; }\n        if (allowFlip === void 0) { allowFlip = false; }\n        this.binWidth = binWidth;\n        this.binHeight = binHeight;\n        this.allowFlip = allowFlip;\n        this.usedRectangles = [];\n        this.freeRectangles = [];\n        if (this.binWidth && this.binHeight) {\n            this.freeRectangles.push(new Rect(0, 0, this.binWidth, this.binHeight));\n        }\n    }\n    GuillotineBinPack.prototype.InsertSizes = function (rects, merge, rectChoice, splitMethod) {\n        var _a;\n        // Remember variables about the best packing choice we have made so far during the iteration process.\n        var bestFreeRect = 0;\n        var bestRect = 0;\n        var bestFlipped = false;\n        // Pack rectangles one at a time until we have cleared the rects array of all rectangles.\n        // rects will get destroyed in the process.\n        while (rects.length > 0) {\n            // Stores the penalty score of the best rectangle placement - bigger=worse, smaller=better.\n            var bestScore = Number.MAX_VALUE;\n            for (var i = 0; i < this.freeRectangles.length; ++i) {\n                for (var j = 0; j < rects.length; ++j) {\n                    // If this rectangle is a perfect match, we pick it instantly.\n                    if (rects[j].width === this.freeRectangles[i].width &&\n                        rects[j].height === this.freeRectangles[i].height) {\n                        bestFreeRect = i;\n                        bestRect = j;\n                        bestFlipped = false;\n                        bestScore = Number.MIN_VALUE;\n                        i = this.freeRectangles.length; // Force a jump out of the outer loop as well - we got an instant fit.\n                        break;\n                    }\n                    // If flipping this rectangle is a perfect match, pick that then.\n                    else if (this.allowFlip &&\n                        rects[j].height === this.freeRectangles[i].width &&\n                        rects[j].width === this.freeRectangles[i].height) {\n                        bestFreeRect = i;\n                        bestRect = j;\n                        bestFlipped = true;\n                        bestScore = Number.MIN_VALUE;\n                        i = this.freeRectangles.length; // Force a jump out of the outer loop as well - we got an instant fit.\n                        break;\n                    }\n                    // Try if we can fit the rectangle upright.\n                    else if (rects[j].width <= this.freeRectangles[i].width &&\n                        rects[j].height <= this.freeRectangles[i].height) {\n                        var score = this.ScoreByHeuristic(rects[j].width, rects[j].height, this.freeRectangles[i], rectChoice);\n                        if (score < bestScore) {\n                            bestFreeRect = i;\n                            bestRect = j;\n                            bestFlipped = false;\n                            bestScore = score;\n                        }\n                    }\n                    // If not, then perhaps flipping sideways will make it fit?\n                    else if (this.allowFlip &&\n                        rects[j].height <= this.freeRectangles[i].width &&\n                        rects[j].width <= this.freeRectangles[i].height) {\n                        var score = this.ScoreByHeuristic(rects[j].height, rects[j].width, this.freeRectangles[i], rectChoice);\n                        if (score < bestScore) {\n                            bestFreeRect = i;\n                            bestRect = j;\n                            bestFlipped = true;\n                            bestScore = score;\n                        }\n                    }\n                }\n            }\n            // If we didn't manage to find any rectangle to pack, abort.\n            if (bestScore === Number.MAX_VALUE)\n                return;\n            // Remove the rectangle we just packed from the input list.\n            var node = rects.splice(bestRect, 1)[0];\n            node.x = this.freeRectangles[bestFreeRect].x;\n            node.y = this.freeRectangles[bestFreeRect].y;\n            // Otherwise, we're good to go and do the actual packing.\n            var newNode = new Rect(this.freeRectangles[bestFreeRect].x, this.freeRectangles[bestFreeRect].y, node.width, node.height);\n            if (bestFlipped)\n                _a = [newNode.height, newNode.width], newNode.width = _a[0], newNode.height = _a[1];\n            // Remove the free space we lost in the bin.\n            this.SplitFreeRectByHeuristic(this.freeRectangles[bestFreeRect], newNode, splitMethod);\n            this.freeRectangles.splice(bestFreeRect, 1);\n            // Perform a Rectangle Merge step if desired.\n            if (merge)\n                this.MergeFreeList();\n            // Remember the new used rectangle.\n            this.usedRectangles.push(node);\n            // Check that we're really producing correct packings here.\n            // debug_assert(disjointRects.Add(newNode) === true);\n        }\n    };\n    /// @return True if r fits inside freeRect (possibly rotated).\n    GuillotineBinPack.prototype.Fits = function (r, freeRect) {\n        return ((r.width <= freeRect.width && r.height <= freeRect.height) ||\n            (r.height <= freeRect.width && r.width <= freeRect.height));\n    };\n    /// @return True if r fits perfectly inside freeRect, i.e. the leftover area is 0.\n    GuillotineBinPack.prototype.FitsPerfectly = function (r, freeRect) {\n        return ((r.width === freeRect.width && r.height === freeRect.height) ||\n            (r.height === freeRect.width && r.width === freeRect.height));\n    };\n    //   Insert(\n    //     width: number,\n    //     height: number,\n    //     merge: boolean,\n    //     rectChoice: FreeRectChoiceHeuristic,\n    //     splitMethod: GuillotineSplitHeuristic,\n    //   ): Rect {\n    //     // Find where to put the new rectangle.\n    //     let freeNodeIndex: RefNumber = { value: 0 }\n    //     const newRect: Rect = this.FindPositionForNewNode(\n    //       width,\n    //       height,\n    //       rectChoice,\n    //       freeNodeIndex,\n    //     )\n    //     // Abort if we didn't have enough space in the bin.\n    //     if (newRect.height === 0) return newRect\n    //     // Remove the space that was just consumed by the new rectangle.\n    //     this.SplitFreeRectByHeuristic(\n    //       this.freeRectangles[freeNodeIndex.value],\n    //       newRect,\n    //       splitMethod,\n    //     )\n    //     this.freeRectangles.splice(freeNodeIndex.value, 1)\n    //     // Perform a Rectangle Merge step if desired.\n    //     if (merge) this.MergeFreeList()\n    //     // Remember the new used rectangle.\n    //     this.usedRectangles.push(newRect)\n    //     // Check that we're really producing correct packings here.\n    //     // debug_assert(disjointRects.Add(newRect) === true);\n    //     return newRect\n    //   }\n    /// Computes the ratio of used surface area to the total bin area.\n    GuillotineBinPack.prototype.Occupancy = function () {\n        ///\\todo The occupancy rate could be cached/tracked incrementally instead\n        ///      of looping through the list of packed rectangles here.\n        var usedSurfaceArea = 0;\n        for (var i = 0; i < this.usedRectangles.length; ++i)\n            usedSurfaceArea += this.usedRectangles[i].width * this.usedRectangles[i].height;\n        return usedSurfaceArea / (this.binWidth * this.binHeight);\n    };\n    /// Returns the heuristic score value for placing a rectangle of size width*height into freeRect. Does not try to rotate.\n    GuillotineBinPack.prototype.ScoreByHeuristic = function (width, height, freeRect, rectChoice) {\n        switch (rectChoice) {\n            case FreeRectChoiceHeuristic.RectBestAreaFit:\n                return this.ScoreBestAreaFit(width, height, freeRect);\n            case FreeRectChoiceHeuristic.RectBestShortSideFit:\n                return this.ScoreBestShortSideFit(width, height, freeRect);\n            case FreeRectChoiceHeuristic.RectBestLongSideFit:\n                return this.ScoreBestLongSideFit(width, height, freeRect);\n            case FreeRectChoiceHeuristic.RectWorstAreaFit:\n                return this.ScoreWorstAreaFit(width, height, freeRect);\n            case FreeRectChoiceHeuristic.RectWorstShortSideFit:\n                return this.ScoreWorstShortSideFit(width, height, freeRect);\n            case FreeRectChoiceHeuristic.RectWorstLongSideFit:\n                return this.ScoreWorstLongSideFit(width, height, freeRect);\n            default:\n                return Number.MAX_VALUE;\n        }\n    };\n    GuillotineBinPack.prototype.ScoreBestAreaFit = function (width, height, freeRect) {\n        return freeRect.width * freeRect.height - width * height;\n    };\n    GuillotineBinPack.prototype.ScoreBestShortSideFit = function (width, height, freeRect) {\n        var leftoverHoriz = Math.abs(freeRect.width - width);\n        var leftoverVert = Math.abs(freeRect.height - height);\n        var leftover = Math.min(leftoverHoriz, leftoverVert);\n        return leftover;\n    };\n    GuillotineBinPack.prototype.ScoreBestLongSideFit = function (width, height, freeRect) {\n        var leftoverHoriz = Math.abs(freeRect.width - width);\n        var leftoverVert = Math.abs(freeRect.height - height);\n        var leftover = Math.max(leftoverHoriz, leftoverVert);\n        return leftover;\n    };\n    GuillotineBinPack.prototype.ScoreWorstAreaFit = function (width, height, freeRect) {\n        return -this.ScoreBestAreaFit(width, height, freeRect);\n    };\n    GuillotineBinPack.prototype.ScoreWorstShortSideFit = function (width, height, freeRect) {\n        return -this.ScoreBestShortSideFit(width, height, freeRect);\n    };\n    GuillotineBinPack.prototype.ScoreWorstLongSideFit = function (width, height, freeRect) {\n        return -this.ScoreBestLongSideFit(width, height, freeRect);\n    };\n    GuillotineBinPack.prototype.FindPositionForNewNode = function (width, height, rectChoice, nodeIndex) {\n        var bestNode = new Rect();\n        var bestScore = Number.MAX_VALUE;\n        /// Try each free rectangle to find the best one for placement.\n        for (var i = 0; i < this.freeRectangles.length; ++i) {\n            // If this is a perfect fit upright, choose it immediately.\n            if (width === this.freeRectangles[i].width && height === this.freeRectangles[i].height) {\n                bestNode.x = this.freeRectangles[i].x;\n                bestNode.y = this.freeRectangles[i].y;\n                bestNode.width = width;\n                bestNode.height = height;\n                bestScore = Number.MIN_VALUE;\n                nodeIndex.value = i;\n                // debug_assert(disjointRects.Disjoint(bestNode));\n                break;\n            }\n            // If this is a perfect fit sideways, choose it.\n            else if (height === this.freeRectangles[i].width && width === this.freeRectangles[i].height) {\n                bestNode.x = this.freeRectangles[i].x;\n                bestNode.y = this.freeRectangles[i].y;\n                bestNode.width = height;\n                bestNode.height = width;\n                bestScore = Number.MIN_VALUE;\n                nodeIndex.value = i;\n                // debug_assert(disjointRects.Disjoint(bestNode));\n                break;\n            }\n            // Does the rectangle fit upright?\n            else if (width <= this.freeRectangles[i].width && height <= this.freeRectangles[i].height) {\n                var score = this.ScoreByHeuristic(width, height, this.freeRectangles[i], rectChoice);\n                if (score < bestScore) {\n                    bestNode.x = this.freeRectangles[i].x;\n                    bestNode.y = this.freeRectangles[i].y;\n                    bestNode.width = width;\n                    bestNode.height = height;\n                    bestScore = score;\n                    nodeIndex.value = i;\n                    // debug_assert(disjointRects.Disjoint(bestNode));\n                }\n            }\n            // Does the rectangle fit sideways?\n            else if (height <= this.freeRectangles[i].width && width <= this.freeRectangles[i].height) {\n                var score = this.ScoreByHeuristic(height, width, this.freeRectangles[i], rectChoice);\n                if (score < bestScore) {\n                    bestNode.x = this.freeRectangles[i].x;\n                    bestNode.y = this.freeRectangles[i].y;\n                    bestNode.width = height;\n                    bestNode.height = width;\n                    bestScore = score;\n                    nodeIndex.value = i;\n                    // debug_assert(disjointRects.Disjoint(bestNode));\n                }\n            }\n        }\n        return bestNode;\n    };\n    GuillotineBinPack.prototype.SplitFreeRectByHeuristic = function (freeRect, placedRect, method) {\n        // Compute the lengths of the leftover area.\n        var w = freeRect.width - placedRect.width;\n        var h = freeRect.height - placedRect.height;\n        // Placing placedRect into freeRect results in an L-shaped free area, which must be split into\n        // two disjoint rectangles. This can be achieved with by splitting the L-shape using a single line.\n        // We have two choices: horizontal or vertical.\n        // Use the given heuristic to decide which choice to make.\n        var splitHorizontal;\n        switch (method) {\n            case GuillotineSplitHeuristic.SplitShorterLeftoverAxis:\n                // Split along the shorter leftover axis.\n                splitHorizontal = w <= h;\n                break;\n            case GuillotineSplitHeuristic.SplitLongerLeftoverAxis:\n                // Split along the longer leftover axis.\n                splitHorizontal = w > h;\n                break;\n            case GuillotineSplitHeuristic.SplitMinimizeArea:\n                // Maximize the larger area === minimize the smaller area.\n                // Tries to make the single bigger rectangle.\n                splitHorizontal = placedRect.width * h > w * placedRect.height;\n                break;\n            case GuillotineSplitHeuristic.SplitMaximizeArea:\n                // Maximize the smaller area === minimize the larger area.\n                // Tries to make the rectangles more even-sized.\n                splitHorizontal = placedRect.width * h <= w * placedRect.height;\n                break;\n            case GuillotineSplitHeuristic.SplitShorterAxis:\n                // Split along the shorter total axis.\n                splitHorizontal = freeRect.width <= freeRect.height;\n                break;\n            case GuillotineSplitHeuristic.SplitLongerAxis:\n                // Split along the longer total axis.\n                splitHorizontal = freeRect.width > freeRect.height;\n                break;\n            default:\n                splitHorizontal = true;\n            // assert(false);\n        }\n        // Perform the actual split.\n        this.SplitFreeRectAlongAxis(freeRect, placedRect, splitHorizontal);\n    };\n    /// This function will add the two generated rectangles into the this.freeRectangles array. The caller is expected to\n    /// remove the original rectangle from the this.freeRectangles array after that.\n    GuillotineBinPack.prototype.SplitFreeRectAlongAxis = function (freeRect, placedRect, splitHorizontal) {\n        // Form the two new rectangles.\n        var bottom = new Rect(freeRect.x, freeRect.y + placedRect.height, 0, freeRect.height - placedRect.height);\n        var right = new Rect(freeRect.x + placedRect.width, freeRect.y, freeRect.width - placedRect.width, 0);\n        if (splitHorizontal) {\n            bottom.width = freeRect.width;\n            right.height = placedRect.height;\n        } // Split vertically\n        else {\n            bottom.width = placedRect.width;\n            right.height = freeRect.height;\n        }\n        // Add the new rectangles into the free rectangle pool if they weren't degenerate.\n        if (bottom.width > 0 && bottom.height > 0)\n            this.freeRectangles.push(bottom);\n        if (right.width > 0 && right.height > 0)\n            this.freeRectangles.push(right);\n        // debug_assert(disjointRects.Disjoint(bottom));\n        // debug_assert(disjointRects.Disjoint(right));\n    };\n    GuillotineBinPack.prototype.MergeFreeList = function () {\n        // Do a Theta(n^2) loop to see if any pair of free rectangles could me merged into one.\n        // Note that we miss any opportunities to merge three rectangles into one. (should call this function again to detect that)\n        for (var i = 0; i < this.freeRectangles.length; ++i)\n            for (var j = i + 1; j < this.freeRectangles.length; ++j) {\n                if (this.freeRectangles[i].width === this.freeRectangles[j].width &&\n                    this.freeRectangles[i].x === this.freeRectangles[j].x) {\n                    if (this.freeRectangles[i].y === this.freeRectangles[j].y + this.freeRectangles[j].height) {\n                        this.freeRectangles[i].y -= this.freeRectangles[j].height;\n                        this.freeRectangles[i].height += this.freeRectangles[j].height;\n                        this.freeRectangles.splice(j, 1);\n                        --j;\n                    }\n                    else if (this.freeRectangles[i].y + this.freeRectangles[i].height === this.freeRectangles[j].y) {\n                        this.freeRectangles[i].height += this.freeRectangles[j].height;\n                        this.freeRectangles.splice(j, 1);\n                        --j;\n                    }\n                }\n                else if (this.freeRectangles[i].height === this.freeRectangles[j].height &&\n                    this.freeRectangles[i].y === this.freeRectangles[j].y) {\n                    if (this.freeRectangles[i].x === this.freeRectangles[j].x + this.freeRectangles[j].width) {\n                        this.freeRectangles[i].x -= this.freeRectangles[j].width;\n                        this.freeRectangles[i].width += this.freeRectangles[j].width;\n                        this.freeRectangles.splice(j, 1);\n                        --j;\n                    }\n                    else if (this.freeRectangles[i].x + this.freeRectangles[i].width === this.freeRectangles[j].x) {\n                        this.freeRectangles[i].width += this.freeRectangles[j].width;\n                        this.freeRectangles.splice(j, 1);\n                        --j;\n                    }\n                }\n            }\n    };\n    GuillotineBinPack.FreeRectChoiceHeuristic = FreeRectChoiceHeuristic;\n    GuillotineBinPack.GuillotineSplitHeuristic = GuillotineSplitHeuristic;\n    return GuillotineBinPack;\n}());\nexport default GuillotineBinPack;\n//# sourceMappingURL=GuillotineBinPack.js.map","import { GuillotineBinPack } from 'rectangle-packer'\n\ninterface Rectangle {\n  width: number\n  height: number\n  x: number\n  y: number\n  letter: string\n}\n\nconst STOP = 0\nconst DO_PLACING = 1\nconst INCREASE = 2\nconst REDUCE = 3\n\nfunction maxMin(list: Rectangle[]) {\n  const widthList = list.map((item) => item.width)\n  const heightList = list.map((item) => item.height)\n  return {\n    minWidth: Math.min.apply(null, widthList),\n    minHeight: Math.min.apply(null, heightList),\n    maxWidth: widthList.reduce((a, b) => a + b, 0),\n    maxHeight: heightList.reduce((a, b) => a + b, 0),\n  }\n}\n\nfunction packing(list: Rectangle[]) {\n  const sizes = maxMin(list)\n  let min = Math.max(sizes.minWidth, sizes.minHeight)\n  let max = Math.max(sizes.maxWidth, sizes.maxHeight)\n  let state = DO_PLACING\n  let placed: Rectangle[] = []\n  while (state) {\n    switch (state) {\n      case DO_PLACING:\n        const packer = new GuillotineBinPack<Rectangle>(\n          min + Math.ceil((max - min) / 2),\n          min + Math.ceil((max - min) / 2),\n        )\n        packer.InsertSizes([...list], true, 1, 1)\n        if (max - min < 2) {\n          state = STOP\n        } else if (list.length > packer.usedRectangles.length) {\n          state = INCREASE\n        } else {\n          placed = packer.usedRectangles\n          state = REDUCE\n        }\n        break\n      case INCREASE:\n        min += Math.ceil((max - min) / 2)\n        state = DO_PLACING\n        break\n      case REDUCE:\n        max -= Math.floor((max - min) / 2)\n        state = DO_PLACING\n        break\n    }\n  }\n  return placed\n}\n\n// eslint-disable-next-line no-restricted-globals\nconst ctx: Worker = (self as unknown) as Worker\nctx.addEventListener(\n  'message',\n  function converter(msg) {\n    const { data } = msg\n    const list = packing(data as Rectangle[])\n    ctx.postMessage(list)\n  },\n  false,\n)\n"],"sourceRoot":""}