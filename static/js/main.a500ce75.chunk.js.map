{"version":3,"sources":["store/ui.ts","workers/AutoPacker.worker.ts","utils/is.ts","utils/getTextBaselines.ts","utils/use.ts","store/base/ui.ts","utils/fontStyleStringify.ts","utils/updateFontFace.ts","store/base/font.ts","store/base/gradient.ts","utils/getFontBaselines.ts","utils/base64ToArrayBuffer.ts","store/base/patternTexture.ts","store/base/fill.ts","store/base/stroke.ts","store/base/shadow.ts","store/base/style.ts","store/base/layout.ts","store/base/metric.ts","utils/trimImageData.ts","utils/getPointOnCircle.ts","utils/getCanvasStyle.ts","utils/getTextSize.ts","utils/pathDoSharp.ts","utils/ctxDoPath.ts","utils/getFontGlyphInfo.ts","utils/getGlyphInfo.ts","store/base/glyphBase.ts","store/base/glyphFont.ts","store/index.ts","store/base/glyphImage.ts","utils/getTrimImageInfo.ts","store/project.ts","store/workspace.ts","app/theme/props.ts","app/theme/overrides.ts","app/theme/index.ts","store/hooks.ts","utils/readFile.ts","app/layout/LeftBar/modules/Font/FontFamily.tsx","app/components/GridInput/GridInput.tsx","app/layout/LeftBar/modules/Font/FontSize.tsx","app/layout/LeftBar/modules/Font/Sharp.tsx","app/layout/LeftBar/modules/Font/Font.tsx","app/layout/LeftBar/modules/Glyphs/Glyphs.tsx","app/layout/LeftBar/modules/PackConfig/Padding.tsx","app/layout/LeftBar/modules/PackConfig/Spacing.tsx","app/layout/LeftBar/modules/PackConfig/AutoPack.tsx","app/layout/LeftBar/modules/PackConfig/FixedSize.tsx","app/layout/LeftBar/modules/PackConfig/PackWidth.tsx","app/layout/LeftBar/modules/PackConfig/PackHeight.tsx","app/layout/LeftBar/modules/PackConfig/PackConfig.tsx","app/layout/common/FormAdjustMetric/FormAdjustMetric.tsx","app/layout/LeftBar/modules/GlobalMetric/GlobalMetric.tsx","app/layout/LeftBar/LeftBar.tsx","app/layout/TitleBar/ButtonNew.tsx","utils/getVersionNumber.ts","file/conversion/types/sbf/prefix.ts","file/conversion/types/sbf/getVersion.ts","file/conversion/types/sbf/check.ts","file/conversion/types/sbf/proto/1.0.0/project.js","file/conversion/types/sbf/proto/1.0.0/updateToNext.ts","file/conversion/types/sbf/proto/1.0.1/project.js","file/conversion/types/sbf/proto/1.0.1/updateToNext.ts","file/conversion/types/sbf/proto/1.0.2/project.js","file/conversion/types/sbf/proto/1.0.2/updateToNext.ts","file/conversion/types/sbf/proto/1.0.3/project.js","file/conversion/types/sbf/proto/1.0.3/updateToNext.ts","file/conversion/types/sbf/proto/project.js","file/conversion/types/sbf/proto/index.ts","file/conversion/types/sbf/updateOldProject.ts","file/conversion/types/sbf/encode.ts","file/conversion/types/sbf/proto/encodeProject.ts","file/conversion/types/sbf/index.ts","file/conversion/types/sbf/decode.ts","file/conversion/types/sbf/proto/toOriginBuffer.ts","file/conversion/types/littera/schema/index.ts","file/conversion/types/littera/schema/glow.ts","file/conversion/types/littera/schema/fill.ts","file/conversion/types/littera/schema/settings.ts","file/conversion/types/littera/schema/shadow.ts","file/conversion/types/littera/schema/stroke.ts","file/conversion/types/littera/schema/background.ts","file/conversion/types/littera/schema/bevel.ts","file/conversion/types/littera/schema/glyphs.ts","file/conversion/types/littera/schema/font.ts","file/conversion/types/littera/check.ts","file/conversion/types/littera/decode.ts","file/conversion/types/index.ts","file/conversion/types/littera/index.ts","file/conversion/index.ts","app/layout/TitleBar/ButtonOpen.tsx","app/layout/TitleBar/ButtonSave.tsx","utils/formatStr.ts","file/export/types/text.ts","file/export/types/xml.ts","file/export/toBmfInfo.ts","file/export/index.ts","app/layout/TitleBar/ButtonExport.tsx","file/export/exportFile.ts","app/layout/TitleBar/TitleBar.tsx","app/components/WrappedSketchPicker/WrappedSketchPicker.tsx","app/components/ColorInput/ColorInput.tsx","app/layout/common/FormColor/FormColor.tsx","app/components/GradientPicker/ColorStop.tsx","app/components/GradientPicker/ColorStopsHolder.tsx","app/components/Palette/Palette.tsx","app/components/GradientPicker/GradientBuilder.tsx","app/components/AnglePicker/AnglePicker.tsx","app/layout/common/FormAngle/FormAngle.tsx","app/layout/common/FormGradient/FormGradient.tsx","app/layout/common/FormImage/FileSelector.tsx","app/layout/common/FormImage/FormImage.tsx","app/layout/common/FormFill/FormFill.tsx","app/layout/RightBar/modules/Fill/Fill.tsx","app/layout/RightBar/modules/Stroke/Stroke.tsx","app/layout/RightBar/modules/Shadow/Shadow.tsx","app/layout/RightBar/modules/BackgroundColor/BackgroundColor.tsx","app/layout/RightBar/RightBar.tsx","app/hooks/useWheel.ts","app/hooks/useSpaceDrag.ts","app/layout/WorkSpace/modules/PackView/PackCanvas.tsx","app/layout/WorkSpace/modules/PackView/PackSizeBar.tsx","app/layout/WorkSpace/modules/PackView/PackView.tsx","app/layout/WorkSpace/modules/Preview/LetterList.tsx","app/layout/WorkSpace/modules/Preview/PreviewCanvas.tsx","app/layout/WorkSpace/modules/Preview/getPreviewCanvas.ts","app/layout/WorkSpace/modules/Preview/PreviewText.tsx","app/layout/WorkSpace/modules/Preview/PreviewMertic.tsx","app/layout/WorkSpace/modules/Preview/PreviewKerning.tsx","app/layout/WorkSpace/modules/Preview/Preview.tsx","app/layout/WorkSpace/modules/MainView/MainView.tsx","app/layout/WorkSpace/modules/ProjectTabs/ProjectTab.tsx","app/layout/WorkSpace/modules/ProjectTabs/ProjectTabs.tsx","app/layout/WorkSpace/modules/ControlerBar/ControlerBar.tsx","app/layout/WorkSpace/modules/ImageGlyphList/ImageGlyph.tsx","app/layout/WorkSpace/modules/ImageGlyphList/ImageGlyphList.tsx","app/layout/WorkSpace/modules/ImageGlyphList/LayerBox.tsx","app/layout/WorkSpace/WorkSpace.tsx","app/layout/Wrap/UpdateToast.tsx","app/layout/Wrap/Wrap.tsx","app/App.tsx","serviceWorkerRegistration.ts","index.tsx"],"names":["Ui","action","bound","num","this","globalLoader","observable","Worker_fn","Worker","canvas","is","n","Number","isNaN","use","a","b","ui","previewText","offsetX","Math","min","max","width","offsetY","height","scale","trans","reOffset","text","showPreview","previewScale","previewOffsetX","previewOffsetY","letter","next","selectLetter","selectNextLetter","packFailed","defaultConfig","fontSize","fontFamily","fontStyleStringify","fontStyleConfig","config","arr","fontStyle","push","fontVariant","fontWeight","lineHeight","join","fontTargeCache","loadDiv","GradientType","DEFAULT_FAMILY","Font","font","size","sharp","fonts","length","forEach","fontResource","addFont","updateBaseines","mainFont","family","opentype","map","middle","hanging","top","alphabetic","ideographic","bottom","bls","unitsPerEm","ascender","descender","fontHeight","getFontBaselines","styleConig","document","createElement","ctx","getContext","Error","textBaseline","measureText","baselines","actualBoundingBoxAscent","actualBoundingBoxDescent","getTextBaselines","parse","lowMemory","e","Promise","reject","names","postScriptName","Object","keys","find","url","URL","createObjectURL","Blob","name","cssNode","createTextNode","appendChild","textNode","head","style","position","left","opacity","pointerEvents","body","resolve","setTimeout","updateFontFace","then","runInAction","idx","indexOf","splice","computed","Gradient","shallow","gradient","type","angle","palette","item","id","nextId","addColor","color","ids","offset","base64ToArrayBuffer","base64","binaryString","atob","len","bytes","Uint8Array","i","charCodeAt","buffer","FillType","PatternTexture","ref","pt","repetition","setImage","src","img","Image","onload","image","Fill","fill","patternTexture","Stroke","stroke","lineCap","lineJoin","strokeType","Shadow","shadow","blur","Style","useShadow","useStroke","bgColor","Layout","layout","padding","spacing","auto","fixedSize","Metric","metric","xAdvance","xOffset","yOffset","trimImageData","imageData","threshold","data","topTrim","bottomTrim","leftTrim","rightTrim","topStatus","bottomStatus","leftStatus","rightStatus","h","ceil","w","j","trimOffsetLeft","trimOffsetTop","getPointOnCircle","x","y","r","cos","PI","sin","matrix","createElementNS","createSVGMatrix","getCanvasStyle","cx","cy","startPoint","endPoint","createLinearGradient","createRadialGradient","addColorStop","pattern","createPattern","setTransform","translate","v","distance","strength","round","ctxDoPath","commands","beginPath","cmd","moveTo","lineTo","bezierCurveTo","x1","y1","x2","y2","quadraticCurveTo","closePath","getFontGlyphInfo","charToGlyph","unicode","glyph","baseline","path","getPath","snapDistance","snapX","snapY","pathDoSharp","boundingBox","getBoundingBox","fontWidth","getAdvanceWidth","trimInfo","floor","trimOffsetRight","trimOffsetBottom","lineWidth","addX","addY","abs","fillStyle","strokCanvas","strokCtx","strokeStyle","strokeWidth","globalCompositeOperation","drawImage","cvs","newCtx","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","imgData","getImageData","styleTrimInfo","putImageData","getGlyphInfo","textAlign","testA","actualBoundingBoxLeft","parseInt","testB","actualBoundingBoxRight","getTextSize","styleX","styleY","fillText","strokeText","GlyphBase","adjustMetric","kerning","set","Map","GlyphFont","galyphFont","textStyle","setGlyphInfo","glyphInfo","source","store","GlyphImage","glyphImage","fileName","fileType","initImage","naturalWidth","naturalHeight","getTrimImageInfo","isSelect","selected","Project","project","worker","packStart","packTimer","idleId","Date","now","globalAdjustMetric","glyphs","value","key","glyphImages","has","addGlyphs","addAutoRun","pack","obj","split","get","glyphList","isUnEmpty","terminate","isPacking","packList","rectangleList","sort","packer","GuillotineBinPack","list","filter","InsertSizes","setPack","usedRectangles","AutoPacker","addEventListener","messageEvent","postMessage","failedList","imgList","maxWidth","maxHeight","rectangle","gi","setPackFailed","setSize","cancel","tasks","runTasks","request","deadline","tr","timeRemaining","start","shift","window","clearTimeout","isName","deepObserve","throttlePack","change","packStyle","str","oldText","replace","currentList","Array","from","Set","oldList","diffList","concat","t","includes","delete","all","packCanvas","Workspace","activeId","projectList","namedList","p","named","match","setName","configure","enforceActions","computedRequiresReaction","props","MuiButton","MuiButtonBase","disableRipple","MuiFilledInput","margin","MuiFormControl","MuiFormHelperText","MuiIconButton","MuiInputBase","MuiInputLabel","MuiListItem","dense","MuiOutlinedInput","MuiFab","MuiTable","MuiTextField","MuiToolbar","variant","overrides","MuiCssBaseline","html","WebkitFontSmoothing","MozOsxFontSmoothing","userSelect","minWidth","marginLeft","background","input","MuiSlider","root","verticalAlign","theme","createTheme","primary","main","secondary","paper","default","activityBar","titleBar","sidebar","common","black","white","hover","bgPixel","backgroundColor","backgroundImage","backgroundSize","backgroundPosition","backgroundRepeat","typography","transitions","create","shape","borderRadius","responsiveFontSizes","useStores","useContext","MobXProviderContext","useWorkspace","workspace","useLayout","currentProject","useProject","useStyle","useFont","useProjectUi","readFile","file","isText","arrayBuffer","reader","FileReader","readAsText","readAsArrayBuffer","target","result","observer","useState","loading","setLoading","removeFont","enqueueSnackbar","useSnackbar","List","disablePadding","ListItem","disableGutters","divider","ListItemText","ListItemSecondaryAction","IconButton","edge","onClick","Button","component","fullWidth","startIcon","CircularProgress","disabled","hidden","onChange","event","files","arrBuf","ArrayBuffer","catch","message","Sentry","accept","GridInput","before","children","after","childrenWidth","other","Grid","container","wrap","justifyContent","alignItems","xs","Typography","noWrap","align","Input","inputProps","setSharp","undefined","Slider","Box","paddingX","marginY","setText","isIME","setIsIME","inputText","setInputText","handleCompositionStart","useCallback","useEffect","TextField","multiline","rows","spellCheck","onCompositionStart","onCompositionEnd","setPadding","setSpacing","setAuto","Checkbox","checked","setFixedSize","setWidth","setHeight","PackConfig","FormAdjustMetric","setXAdvance","setXOffset","setYOffset","getHandle","handleSet","useStyles","makeStyles","createStyles","overflow","LeftBar","classes","bgcolor","display","flexDirection","className","boxShadow","flex","Divider","addProject","handleNewProject","preventDefault","hotkeys","unbind","title","getVersionNumber","version","isArray","reverse","reduce","previousValue","currentValue","currentIndex","pow","prefix","s","decode","byteLength","perfixBuffer","perfixName","slice","filePrefix","versionBuffer","isSbf","check","getVersion","$Reader","$protobuf","$Writer","$util","$root","properties","prototype","encode","writer","hasOwnProperty","call","uint32","sint32","encodeDelimited","ldelim","end","pos","tag","skipType","decodeDelimited","verify","isInteger","fromObject","object","toObject","options","defaults","toJSON","constructor","toJSONOptions","GradientColor","int32","string","isString","String","emptyArray","float","fork","error","TypeError","arrays","json","isFinite","newBuffer","double","emptyObject","end2","tag2","isObject","keys2","objects","bool","Boolean","power","Long","fromBits","int64","low","high","fromValue","unsigned","LongBits","toNumber","long","longs","toString","updateToNext","fixOffset","FontResource","oldProto","proto1000000","proto1000001","proto1000002","proto1000003","verions","verion","updateOldProject","projectBuffer","ProjectProto","finish","encodeProject","sbfFile","ext","u8","protoProject","imgKerning","k","gl","glyphKerning","toOriginBuffer","schema","glow","quality","colors","elements","glowEnabled","alphas","ratios","blurX","blurY","gradientAlphas","gradientType","enum","gradientRotation","fillType","textureScale","distanceFieldEnabled","distanceFieldColor","gradientColors","distanceFieldDownscale","distanceFieldSpread","distanceFieldType","gradientRatios","optionalProperties","texture","settings","postfixes","filename","scalings","shadowEnabled","alpha","pixelHinting","strokeEnabled","miterLimit","jointStyle","bevel","bevelEnabled","highlightColor","highlightAlpha","shadowAlpha","powerOfTwo","canvasHeight","packMethod","canvasWidth","roundValues","descriptionFormat","fallbackfont","validate","Ajv","compile","litteraStr","litteraData","JSON","isLittera","errors","category","level","Info","transformFill","litteraFill","SOLID","Color","hex","GRADIENT","RADIAL","LINEAR","assign","conversionList","sbf","conversion","inputFile","worckSpace","labelRef","useRef","test","console","log","handleSaveProject","toJS","saveAs","formatStr","matchs","returns","outputConfig","exts","getString","bmfont","info","pages","chars","kernings","charset","char","count","parser","DOMParser","xmlDOM","implementation","createDocument","infoDoc","parseFromString","documentElement","childNodes","commonDoc","pagesDoc","charsDoc","charDoc","kerningsDoc","kerningDoc","XMLSerializer","serializeToString","toBmfInfo","fontScale","face","mainFamily","bold","italic","stretchH","smooth","aa","base","scaleW","scaleH","packed","xoffset","yoffset","xadvance","page","chnl","amount","getKerningValue","charToGlyphIndex","first","second","configList","xml","setShowPreview","open","setOpen","val","setVal","fontName","setFontName","setFileName","handleOpen","handleClose","handleSave","zip","JSZip","saveFileName","toBlob","blob","generateAsync","content","exportFile","Dialog","onClose","DialogTitle","DialogContent","dividers","placeholder","Select","displayEmpty","MenuItem","toUpperCase","DialogActions","autoFocus","zIndex","appBar","appName","marginRight","appNameSup","btn","textTransform","TitleBar","href","picker","borderColor","border","WrappedSketchPicker","anchorEl","placement","pickerStyle","useTheme","shadows","usePickerStyle","Popper","styles","rgb","g","swatch","cursor","ColorInput","ClickAwayListener","mouseEvent","onClickAway","current","FormColor","borderWidth","isActive","borderStyle","dark","activeColor","grey","ColorStop","divProps","clsx","ColorStopsHolder","onAdd","onUpdate","onSelect","setStartPoint","isDragging","setIsDragging","rootRef","clientWidth","handleMouseMove","buttons","findIndex","paletteItem","newPalette","clientY","clientX","handleMouseUp","stopPropagation","removeEventListener","onMouseDown","getBoundingClientRect","handleMouseDown","svg","Palette","random","substr","sortedPalette","stopColor","GradientBuilder","rootEl","oldPalette","setOldPalette","setActiveId","setActiveColor","isAdd","setIsAdd","newIds","oldIds","diff","handleUpdate","isDelete","updateItem","right","offsetSpace","leftColor","rightColor","red","green","blue","React","cloneElement","point","marginTop","transformOrigin","transform","AnglePicker","bounds","radians","atan2","FormAngle","updatePalette","setAngle","setType","RadioGroup","row","flexWrap","FormControlLabel","control","Radio","label","FileSelector","multiple","alt","FormImage","setRepetition","setScale","step","setColor","IMAGE","setUseStroke","setLineJoin","setLineCap","setStrokeType","Switch","ButtonGroup","setUseShadow","setOffsetX","setOffsetY","setBlur","setBgColor","RightBar","useWheel","onWheel","deps","callback","handleWheel","ctrlKey","altKey","deltaX","deltaY","d","deltaScale","dom","passive","useSpaceDrag","onMove","ks","ms","moveState","setMoveState","dragStatus","useMemo","moveCallback","handleKeyEvent","state","keyCode","handleMove","handleEnd","dragState","imageRendering","packWidth","packHeight","setCanvas","canvasRef","domRef","offsetInfo","ix","iy","os","ox","oy","fillRect","animationDuration","LinearProgress","PackView","outline","select","setSelectLetter","handleSelect","setData","minBaseLine","maxBaseLine","setPreviewTransform","lh","index","baseLine","basey","setLineDash","lines","autorun","kerningMap","charMap","minX","minY","maxX","maxY","lk","kering","getPreviewCanvas","setPreviewText","setOffset","setGlyph","setKerning","disposer","steKerning","Preview","PreviewText","PreviewMertic","PreviewKerning","to","toast","animationName","icon","minHeight","borderRight","whiteSpace","editor","appearance","ProjectTab","useRemove","onRemove","onRename","setEditor","sname","setSName","editorRef","handleRemove","focus","onDoubleClick","onKeyDown","onBlur","workSpace","selectProject","removeProject","setProjectName","Tabs","indicatorColor","textColor","scrollButtons","selectionFollowsFocus","TabIndicatorProps","slider","anchorRef","handleChange","prevOpen","Paper","contains","MenuList","actions","inputLabel","removeImage","inputValue","setInputValue","changeSelect","direction","InputBase","onFocus","onInput","iv","fixed","panel","continer","overflowY","listWrap","addImages","isFullscreen","setFullscreen","handleLoadFile","matched","fileList","f","handleKeyDown","tagName","onDragEnter","onDragOver","onDrop","dataTransfer","Accordion","expanded","o","TransitionProps","AccordionSummary","expandIcon","AccordionDetails","tabsRoot","tabRoot","tabSelected","tabWrapper","WorkSpace","close","ConsecutiveSnackbars","reason","updateVersion","detail","Snackbar","anchorOrigin","vertical","horizontal","Fragment","location","reload","loadingBackdrop","drawer","Backdrop","App","ThemeProvider","CssBaseline","isLocalhost","hostname","registerValidSW","swUrl","navigator","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","controller","onSuccess","dsn","process","release","integrations","Integrations","BrowserTracing","tracesSampleRate","environment","ReactDOM","render","getElementById","origin","fetch","headers","response","contentType","status","ready","unregister","checkValidServiceWorker","serviceWorkerRegistration","waiting","channel","MessageChannel","port1","onmessage","dispatchEvent","CustomEvent","port2"],"mappings":"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","file":"static/js/main.a500ce75.chunk.js","sourcesContent":["import { action, observable } from 'mobx'\n\nclass Ui {\n  @observable globalLoader = 0\n\n  @action.bound showGlobalLoader(num = 1): void {\n    this.globalLoader += num\n  }\n\n  @action.bound hideGlobalLoader(num = -1): void {\n    this.globalLoader += num\n  }\n}\n\nexport default Ui\n","export default function Worker_fn() {\n  return new Worker(__webpack_public_path__ + \"static/js/AutoPacker.ea1294b4f722df64607a.worker.js\");\n}\n","const num = (n: unknown): n is number => {\n  return typeof n === 'number' && !Number.isNaN(n)\n}\n\nconst is = {\n  num,\n}\n\nexport default is\n","import fontStyleStringify from './fontStyleStringify'\n\ninterface StyleConig {\n  fontFamily: string\n  fontSize: number\n}\ninterface Baselines {\n  middle: number\n  hanging: number\n  top: number\n  alphabetic: number\n  ideographic: number\n  bottom: number\n  lineHeight: number\n}\n\nlet canvas: HTMLCanvasElement\n\nexport default function getTextBaselines(\n  text: string,\n  styleConig: StyleConig,\n): Baselines {\n  if (!canvas) canvas = document.createElement('canvas')\n  const ctx = canvas.getContext('2d')\n  if (!ctx) throw new Error('Get context 2d failed.')\n  const font = fontStyleStringify(styleConig)\n\n  // clear before settings\n  canvas.width = 1\n  canvas.height = 1\n\n  ctx.font = font\n\n  ctx.textBaseline = 'middle'\n  const middle = ctx.measureText(text)\n  ctx.textBaseline = 'hanging'\n  const hanging = ctx.measureText(text)\n  ctx.textBaseline = 'top'\n  const top = ctx.measureText(text)\n  ctx.textBaseline = 'alphabetic'\n  const alphabetic = ctx.measureText(text)\n  ctx.textBaseline = 'ideographic'\n  const ideographic = ctx.measureText(text)\n  ctx.textBaseline = 'bottom'\n  const bottom = ctx.measureText(text)\n\n  const baselines = {\n    middle: 0,\n    hanging: hanging.actualBoundingBoxAscent - middle.actualBoundingBoxAscent,\n    top: top.actualBoundingBoxAscent - middle.actualBoundingBoxAscent,\n    alphabetic:\n      middle.actualBoundingBoxDescent - alphabetic.actualBoundingBoxDescent,\n    ideographic:\n      middle.actualBoundingBoxDescent - ideographic.actualBoundingBoxDescent,\n    bottom: middle.actualBoundingBoxDescent - bottom.actualBoundingBoxDescent,\n    lineHeight: 1,\n  }\n\n  baselines.lineHeight =\n    (Math.max(baselines.ideographic, baselines.bottom) -\n      Math.min(baselines.hanging, baselines.top)) /\n    styleConig.fontSize\n\n  return baselines\n}\n","import is from './is'\n\nconst num = (a: unknown, b: number): number => {\n  if (is.num(a)) return a\n  return b\n}\n\nconst use = {\n  num,\n}\n\nexport default use\n","import { action, observable } from 'mobx'\nimport use from 'src/utils/use'\n\nclass Ui {\n  @observable scale = 1\n\n  @observable offsetX = 0\n\n  @observable offsetY = 0\n\n  @observable width = 0\n\n  @observable height = 0\n\n  @observable previewText = 'Hello World!\\nHello Snow Bamboo!' // /\\r\\n|\\r|\\n/\n\n  @observable selectLetter = ''\n\n  @observable selectNextLetter = ''\n\n  @observable showPreview = false\n\n  @observable previewScale = 1\n\n  @observable previewOffsetX = 0\n\n  @observable previewOffsetY = 0\n\n  @observable packFailed = false\n\n  constructor(ui: Partial<Ui> = {}) {\n    if (ui.previewText) {\n      this.previewText = ui.previewText\n    }\n  }\n\n  reOffset() {\n    this.offsetX = Math.min(\n      Math.max(this.width / -2, this.offsetX),\n      this.width / 2,\n    )\n    this.offsetY = Math.min(\n      Math.max(this.height / -2, this.offsetY),\n      this.height / 2,\n    )\n    this.scale = Math.max(this.scale, 0.01)\n  }\n\n  @action.bound setTransform(trans: Partial<Ui>): void {\n    this.scale = use.num(trans.scale, this.scale)\n    this.offsetX = use.num(trans.offsetX, this.offsetX)\n    this.offsetY = use.num(trans.offsetY, this.offsetY)\n    this.reOffset()\n  }\n\n  @action.bound setSize(width: number, height: number): void {\n    this.width = width\n    this.height = height\n    this.reOffset()\n  }\n\n  @action.bound setPreviewText(text: string): void {\n    this.previewText = text\n  }\n\n  @action.bound setShowPreview(showPreview: boolean): void {\n    this.showPreview = showPreview\n  }\n\n  @action.bound setPreviewTransform(trans: Partial<Ui>): void {\n    this.previewScale = Math.max(\n      use.num(trans.previewScale, this.previewScale),\n      0.01,\n    )\n    this.previewOffsetX = use.num(trans.previewOffsetX, this.previewOffsetX)\n    this.previewOffsetY = use.num(trans.previewOffsetY, this.previewOffsetY)\n  }\n\n  @action.bound setSelectLetter(letter: string = '', next: string = ''): void {\n    this.selectLetter = letter\n    this.selectNextLetter = next\n  }\n\n  @action.bound setPackFailed(packFailed: boolean): void {\n    this.packFailed = packFailed\n  }\n}\n\nexport default Ui\n","import is from './is'\n\nexport interface FontStyleConfig {\n  fontStyle?: 'normal' | 'italic' | 'oblique' | string\n  fontVariant?: 'normal' | 'none' | 'small-caps' | string\n  fontWeight?:\n    | 'normal'\n    | 'bold'\n    | 'lighter'\n    | 'bolder'\n    | '100'\n    | '200'\n    | '300'\n    | '400'\n    | '500'\n    | '600'\n    | '700'\n    | '800'\n    | '900'\n    | 100\n    | 200\n    | 300\n    | 400\n    | 500\n    | 600\n    | 700\n    | 800\n    | 900\n    | 'inherit'\n    | 'initial'\n    | 'unset'\n  fontSize?: string | number\n  lineHeight?: string | number\n  fontFamily?: string\n}\n\nconst defaultConfig: FontStyleConfig = {\n  fontSize: '14px',\n  fontFamily: 'sans-serif',\n}\n\n// https://developer.mozilla.org/zh-CN/docs/Web/CSS/font\nexport default function fontStyleStringify(\n  fontStyleConfig: FontStyleConfig,\n): string {\n  const config = { ...defaultConfig, ...fontStyleConfig }\n  const arr = []\n\n  if (config.fontStyle) arr.push(config.fontStyle)\n\n  if (config.fontVariant) arr.push(config.fontVariant)\n\n  if (config.fontWeight) arr.push(config.fontWeight)\n\n  if (is.num(config.fontSize)) {\n    config.fontSize = `${config.fontSize}px`\n  } else {\n    config.fontSize = defaultConfig.fontSize\n  }\n\n  if (config.lineHeight) {\n    arr.push(`${config.fontSize}/${config.lineHeight}`)\n  } else {\n    arr.push(config.fontSize)\n  }\n\n  arr.push(config.fontFamily)\n\n  return arr.join(' ')\n}\n","let fontTargeCache: HTMLStyleElement\nlet loadDiv: HTMLDivElement\n\nexport default function updateFontFace(\n  name: string,\n  url: string,\n): Promise<void> {\n  const cssNode = document.createTextNode(`\n    @font-face {\n        font-family: \"${name}\";\n        src: url(\"${url}\") format('truetype');\n    }`)\n\n  if (!fontTargeCache) {\n    const textNode = document.createTextNode(`A`)\n    fontTargeCache = document.createElement('style')\n    loadDiv = document.createElement('div')\n    document.head.appendChild(fontTargeCache)\n    fontTargeCache.appendChild(cssNode)\n    loadDiv.appendChild(textNode)\n    loadDiv.style.position = 'absolute'\n    loadDiv.style.left = '-1000px'\n    loadDiv.style.top = '-1000px'\n    loadDiv.style.opacity = '0'\n    loadDiv.style.fontSize = '12px'\n    loadDiv.style.pointerEvents = 'none'\n    document.body.appendChild(loadDiv)\n  } else {\n    fontTargeCache.appendChild(cssNode)\n  }\n  loadDiv.style.fontFamily = name\n  return new Promise((resolve) => setTimeout(resolve, 200))\n}\n","import { action, observable, computed, runInAction } from 'mobx'\nimport getTextBaselines from 'src/utils/getTextBaselines'\nimport { parse, Font as OpenType } from 'opentype.js'\nimport updateFontFace from 'src/utils/updateFontFace'\nimport getFontBaselines from 'src/utils/getFontBaselines'\nimport is from 'src/utils/is'\n\nexport interface FontResource {\n  font: ArrayBuffer\n  family: string\n  opentype: OpenType\n}\n\nconst DEFAULT_FAMILY = 'sans-serif'\n\nclass Font {\n  @observable fonts: FontResource[] = []\n\n  @observable size: number\n\n  @observable lineHeight = 1\n\n  @observable middle = 0\n\n  @observable hanging = 0\n\n  @observable top = 0\n\n  @observable alphabetic = 0\n\n  @observable ideographic = 0\n\n  @observable bottom = 0\n\n  @observable sharp = 80\n\n  @computed get mainFont() {\n    if (this.fonts.length > 0) return this.fonts[0]\n    return null\n  }\n\n  @computed get mainFamily() {\n    if (this.mainFont) return this.mainFont.family\n    return DEFAULT_FAMILY\n  }\n\n  @computed get opentype() {\n    if (this.mainFont) return this.mainFont.opentype\n    return null\n  }\n\n  @computed get family(): string {\n    return (\n      this.fonts.map((fontResource) => `\"${fontResource.family}\"`).join(',') ||\n      DEFAULT_FAMILY\n    )\n  }\n\n  @computed get minBaseLine() {\n    const min = Math.min(\n      this.middle,\n      this.hanging,\n      this.top,\n      this.alphabetic,\n      this.ideographic,\n      this.bottom,\n    )\n    if (Number.isNaN(Number(min))) return 0\n    return min\n  }\n\n  @computed get maxBaseLine() {\n    const max = Math.max(\n      this.middle,\n      this.hanging,\n      this.top,\n      this.alphabetic,\n      this.ideographic,\n      this.bottom,\n    )\n    if (Number.isNaN(Number(max))) return this.size\n    return max\n  }\n\n  constructor(font: Partial<Font> = {}) {\n    this.size = font.size || 72\n    // this.lineHeight = font.lineHeight || 1.25\n    this.sharp = is.num(font.sharp) ? font.sharp : 80\n    if (font.fonts && font.fonts.length) {\n      font.fonts.forEach((fontResource) => this.addFont(fontResource.font))\n    } else {\n      this.updateBaseines()\n    }\n  }\n\n  updateBaseines(): void {\n    let bls\n    if (this.mainFont?.opentype) {\n      bls = getFontBaselines(this.mainFont.opentype, this.size)\n    } else {\n      bls = getTextBaselines('x', {\n        fontFamily: this.family,\n        fontSize: this.size,\n      })\n    }\n    this.lineHeight = bls.lineHeight\n    this.middle = bls.middle\n    this.hanging = bls.hanging\n    this.top = bls.top\n    this.alphabetic = bls.alphabetic\n    this.ideographic = bls.ideographic\n    this.bottom = bls.bottom\n  }\n\n  @action.bound addFont(font: ArrayBuffer): Promise<void> {\n    let opentype: OpenType\n    try {\n      opentype = parse(font, { lowMemory: true })\n    } catch (e) {\n      return Promise.reject(e)\n    }\n    const { names } = opentype\n    const family = names.postScriptName[Object.keys(names.postScriptName)[0]]\n    const hasFont = this.fonts.find(\n      (fontResource) => fontResource.family === family,\n    )\n    if (hasFont) {\n      return Promise.reject(new Error('Font already exists.'))\n    }\n    const url = URL.createObjectURL(new Blob([font]))\n    return updateFontFace(family, url).then(() => {\n      runInAction(() => {\n        this.fonts.push({\n          font,\n          family,\n          opentype,\n        })\n        this.updateBaseines()\n      })\n    })\n  }\n\n  @action.bound removeFont(fontResource: FontResource) {\n    const idx = this.fonts.indexOf(fontResource)\n    if (idx === -1) return\n    this.fonts.splice(idx, 1)\n    if (idx === 0) {\n      this.updateBaseines()\n    }\n  }\n\n  @action.bound setSize(size: number): void {\n    this.size = size\n    this.updateBaseines()\n  }\n\n  @action.bound setLineHeight(lineHeight: number): void {\n    this.lineHeight = lineHeight\n  }\n\n  @action.bound setSharp(sharp: number): void {\n    this.sharp = sharp\n  }\n}\n\nexport default Font\n","import { action, computed, observable } from 'mobx'\n\n// import GradientPaletteItem from './gradientPaletteItem'\n\nexport enum GradientType {\n  LINEAR,\n  RADIAL,\n}\n\nexport interface GradientColor {\n  offset: number\n  color: string\n}\n\nexport interface GradientPaletteItem extends GradientColor {\n  id: number\n}\n\nexport interface GradientColorOption extends GradientColor {\n  id?: number\n}\n\nclass Gradient {\n  @observable type: GradientType = 0\n\n  @observable angle: number\n\n  @observable.shallow palette: GradientPaletteItem[] = []\n\n  constructor(gradient: Partial<Gradient> = {}) {\n    this.type = gradient.type && GradientType[gradient.type] ? gradient.type : 0\n    this.angle = gradient.angle || 0\n    if (gradient.palette) {\n      gradient.palette.forEach((item) => {\n        this.palette.push({\n          ...item,\n          id: item.id || this.nextId,\n        })\n      })\n    } else {\n      this.addColor(0, 'rgba(255,255,255,1)')\n      this.addColor(1)\n    }\n  }\n\n  @computed get ids(): number[] {\n    return this.palette.map((color) => color.id)\n  }\n\n  @computed get nextId(): number {\n    if (this.ids.length === 0) return 1\n    return Math.max(...this.ids) + 1\n  }\n\n  @action.bound setType(type: GradientType): void {\n    this.type = type\n  }\n\n  @action.bound setAngle(angle: number): void {\n    this.angle = angle\n  }\n\n  @action.bound addColor(offset = 0, color = 'rgba(0,0,0,1)'): void {\n    this.palette.push({ offset, color, id: this.nextId })\n  }\n\n  @action.bound updatePalette(palette: GradientPaletteItem[]): void {\n    this.palette = palette\n  }\n}\n\nexport default Gradient\n","import { Font } from 'opentype.js'\n\ninterface Baselines {\n  middle: number\n  hanging: number\n  top: number\n  alphabetic: number\n  ideographic: number\n  bottom: number\n  lineHeight: number\n}\n\nexport default function getFontBaselines(\n  font: Font,\n  fontSize: number,\n): Baselines {\n  const scale = fontSize / font.unitsPerEm\n  const height = font.ascender - font.descender\n  const fontHeight = height * scale\n  const alphabetic = font.ascender * scale\n\n  return {\n    middle: 0,\n    hanging: 0,\n    top: fontHeight / -2,\n    alphabetic: alphabetic - fontHeight / 2,\n    ideographic: 0,\n    bottom: fontHeight / 2,\n    lineHeight: height / font.unitsPerEm,\n  }\n}\n","export default function base64ToArrayBuffer(base64: string): ArrayBuffer {\n  const binaryString = atob(base64)\n  const len = binaryString.length\n  const bytes = new Uint8Array(len)\n  for (let i = 0; i < len; i += 1) {\n    bytes[i] = binaryString.charCodeAt(i)\n  }\n  return bytes.buffer\n}\n","import { action, observable, runInAction } from 'mobx'\nimport use from 'src/utils/use'\nimport base64ToArrayBuffer from 'src/utils/base64ToArrayBuffer'\n\nexport type Repetition = 'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat'\n\nconst DEFAULT_IMAGE =\n  'iVBORw0KGgoAAAANSUhEUgAAAAgAAAAIAQMAAAD+wSzIAAAABlBMVEX////MzMw46qqDAAAADklEQVQI12Pgh8IPEAgAEeAD/Xk4HBcAAAAASUVORK5CYII='\n\nclass PatternTexture {\n  @observable.ref buffer: ArrayBuffer = base64ToArrayBuffer(DEFAULT_IMAGE)\n\n  @observable.ref image: HTMLImageElement | null = null\n\n  @observable src = ''\n\n  @observable repetition: Repetition = 'repeat'\n\n  @observable scale: number\n\n  constructor(pt: Partial<PatternTexture> = {}) {\n    this.scale = use.num(pt.scale, 1)\n    this.repetition = pt.repetition || 'repeat'\n    this.setImage(pt.buffer || this.buffer)\n  }\n\n  @action.bound setImage(buffer: ArrayBuffer): void {\n    const src = URL.createObjectURL(new Blob([buffer]))\n    const img = new Image()\n    img.onload = () => {\n      runInAction('setPatternTextureImage', () => {\n        this.buffer = buffer\n        this.image = img\n        this.src = src\n        img.onload = null\n      })\n    }\n    img.src = src\n  }\n\n  @action.bound setRepetition(repetition: Repetition): void {\n    this.repetition = repetition\n  }\n\n  @action.bound setScale(scale: number): void {\n    this.scale = scale\n  }\n}\n\nexport default PatternTexture\n","import { action, observable } from 'mobx'\n\nimport Gradient from './gradient'\nimport PatternTexture from './patternTexture'\n\nexport enum FillType {\n  SOLID,\n  GRADIENT,\n  IMAGE,\n}\n\nclass Fill {\n  @observable type: FillType\n\n  @observable color: string\n\n  @observable.shallow gradient: Gradient\n\n  @observable.shallow patternTexture: PatternTexture\n\n  constructor(fill: Partial<Fill> = {}) {\n    this.color = fill.color || '#000000'\n    this.type = fill.type && FillType[fill.type] ? fill.type : 0\n    this.gradient = new Gradient(fill.gradient)\n    this.patternTexture = new PatternTexture(fill.patternTexture)\n  }\n\n  @action.bound setType(type: FillType = 0): void {\n    this.type = type\n  }\n\n  @action.bound setColor(color = '#000000'): void {\n    this.color = color\n  }\n}\n\nexport default Fill\n","import { action, observable } from 'mobx'\nimport use from 'src/utils/use'\n\nimport Fill from './fill'\n\nclass Stroke extends Fill {\n  @observable width = 1\n\n  /**\n   * butt   默认。向线条的每个末端添加平直的边缘。\n   * round  向线条的每个末端添加圆形线帽。\n   * square 向线条的每个末端添加正方形线帽。\n   */\n  @observable lineCap: CanvasLineCap\n\n  /**\n   * bevel 创建斜角。\n   * round 创建圆角。\n   * miter 默认。创建尖角。\n   */\n  @observable lineJoin: CanvasLineJoin\n\n  /**\n   * Stroke Type\n   *\n   * 0 outer stroke\n   * 1 middle stroke\n   * 2 inner stroke\n   */\n  @observable strokeType: 0 | 1 | 2\n\n  constructor(stroke: Partial<Stroke> = {}) {\n    super(stroke)\n    this.width = use.num(stroke.width, 1)\n    this.lineCap = stroke.lineCap || 'round'\n    this.lineJoin = stroke.lineJoin || 'round'\n    this.strokeType = stroke.strokeType || 0\n  }\n\n  @action.bound setWidth(width: number): void {\n    this.width = width\n  }\n\n  @action.bound setLineCap(lineCap: CanvasLineCap): void {\n    this.lineCap = lineCap\n  }\n\n  @action.bound setLineJoin(lineJoin: CanvasLineJoin): void {\n    this.lineJoin = lineJoin\n  }\n\n  @action.bound setStrokeType(strokeType: 0 | 1 | 2): void {\n    this.strokeType = strokeType\n  }\n}\n\nexport default Stroke\n","import { action, observable } from 'mobx'\nimport use from 'src/utils/use'\n\nclass Shadow {\n  @observable color: string\n\n  @observable blur = 1\n\n  @observable offsetX = 1\n\n  @observable offsetY = 1\n\n  constructor(shadow: Partial<Shadow> = {}) {\n    this.color = shadow.color || '#000000'\n    this.blur = use.num(shadow.blur, 1)\n    this.offsetX = use.num(shadow.offsetX, 1)\n    this.offsetY = use.num(shadow.offsetY, 1)\n  }\n\n  @action.bound setColor(color: string): void {\n    this.color = color\n  }\n\n  @action.bound setBlur(blur: number): void {\n    this.blur = blur\n  }\n\n  @action.bound setOffsetX(offsetX: number): void {\n    this.offsetX = offsetX\n  }\n\n  @action.bound setOffsetY(offsetY: number): void {\n    this.offsetY = offsetY\n  }\n\n  @action.bound setOffset(offsetX: number, offsetY: number): void {\n    this.offsetX = offsetX\n    this.offsetY = offsetY\n  }\n}\n\nexport default Shadow\n","import { action, observable } from 'mobx'\n\nimport Font from './font'\nimport Fill from './fill'\nimport Stroke from './stroke'\nimport Shadow from './shadow'\n\nclass Style {\n  @observable readonly font: Font\n\n  @observable readonly fill: Fill\n\n  @observable useStroke: boolean\n\n  @observable readonly stroke: Stroke\n\n  @observable useShadow: boolean\n\n  @observable readonly shadow: Shadow\n\n  @observable bgColor = 'rgba(0,0,0,0)'\n\n  constructor(style: Partial<Style> = {}) {\n    this.font = new Font(style.font)\n    this.fill = new Fill(style.fill)\n    this.stroke = new Stroke(style.stroke)\n    this.shadow = new Shadow(style.shadow)\n    this.useShadow = !!style.useShadow\n    this.useStroke = !!style.useStroke\n  }\n\n  @action.bound setUseStroke(useStroke: boolean): void {\n    this.useStroke = useStroke\n  }\n\n  @action.bound setUseShadow(useShadow: boolean): void {\n    this.useShadow = useShadow\n  }\n\n  @action.bound setBgColor(bgColor: string): void {\n    this.bgColor = bgColor\n  }\n}\n\nexport default Style\n","import { action, observable } from 'mobx'\nimport use from 'src/utils/use'\n\nclass Layout {\n  @observable padding = 1\n\n  @observable spacing = 1\n\n  @observable width = 1024\n\n  @observable height = 1024\n\n  @observable auto = true\n\n  @observable fixedSize = false\n\n  constructor(layout: Partial<Layout> = {}) {\n    this.padding = use.num(layout.padding, 1)\n\n    this.spacing = use.num(layout.spacing, 1)\n\n    this.width = use.num(layout.width, 1024)\n\n    this.height = use.num(layout.height, 1024)\n\n    // Compatible with old files, default true.\n    this.auto = layout.auto === false ? false : true\n\n    this.fixedSize = !!layout.fixedSize\n  }\n\n  @action.bound setPadding(padding: number): void {\n    this.padding = padding\n  }\n\n  @action.bound setSpacing(spacing: number): void {\n    this.spacing = spacing\n  }\n\n  @action.bound setWidth(width: number): void {\n    this.width = width\n  }\n\n  @action.bound setHeight(height: number): void {\n    this.height = height\n  }\n\n  @action.bound setAuto(auto: boolean): void {\n    this.auto = auto\n  }\n\n  @action.bound setFixedSize(fixedSize: boolean): void {\n    this.fixedSize = fixedSize\n  }\n}\n\nexport default Layout\n","import { action, observable } from 'mobx'\n\nclass Metric {\n  @observable xAdvance = 0\n\n  @observable xOffset = 0\n\n  @observable yOffset = 0\n\n  constructor(metric: Partial<Metric> = {}) {\n    this.xAdvance = metric.xAdvance || 0\n    this.xOffset = metric.xOffset || 0\n    this.yOffset = metric.yOffset || 0\n  }\n\n  @action.bound setXAdvance(xAdvance: number): void {\n    this.xAdvance = xAdvance\n  }\n\n  @action.bound setXOffset(xOffset: number): void {\n    this.xOffset = xOffset\n  }\n\n  @action.bound setYOffset(yOffset: number): void {\n    this.yOffset = yOffset\n  }\n}\n\nexport default Metric\n","export interface TrimImageInfo {\n  width: number\n  height: number\n  trimOffsetTop: number\n  trimOffsetLeft: number\n}\n\nexport default function trimImageData(\n  imageData: ImageData,\n  threshold = 0,\n): TrimImageInfo {\n  const { data, width, height } = imageData\n  let topTrim = 0\n  let bottomTrim = 0\n  let leftTrim = 0\n  let rightTrim = 0\n  let topStatus = true\n  let bottomStatus = true\n  let leftStatus = true\n  let rightStatus = true\n\n  let h: number = Math.ceil(height / 2)\n  const w: number = Math.ceil(width / 2)\n\n  for (let i = 0; i < h; i += 1) {\n    for (let j = 0; j < width; j += 1) {\n      if (topStatus && data[(i * width + j) * 4 + 3] > threshold) {\n        topStatus = false\n      }\n      if (\n        bottomStatus &&\n        data[((height - i - 1) * width + j) * 4 + 3] > threshold\n      ) {\n        bottomStatus = false\n      }\n      if (!topStatus && !bottomStatus) {\n        break\n      }\n    }\n    if (!topStatus && !bottomStatus) {\n      break\n    }\n    if (topStatus) topTrim += 1\n    if (bottomStatus) bottomTrim += 1\n  }\n\n  if (topTrim + bottomTrim >= height) {\n    // Is empty image.\n    return {\n      trimOffsetLeft: width * -1,\n      trimOffsetTop: height * -1,\n      width: 0,\n      height: 0,\n    }\n  }\n\n  h = height - bottomTrim\n\n  for (let i = 0; i < w; i += 1) {\n    for (let j = topTrim; j < h; j += 1) {\n      if (leftStatus && data[(width * j + i) * 4 + 3] > threshold) {\n        leftStatus = false\n      }\n      if (\n        rightStatus &&\n        data[(width * j + width - i - 1) * 4 + 3] > threshold\n      ) {\n        rightStatus = false\n      }\n      if (!leftStatus && !rightStatus) {\n        break\n      }\n    }\n    if (!leftStatus && !rightStatus) {\n      break\n    }\n    if (leftStatus) leftTrim += 1\n    if (rightStatus) rightTrim += 1\n  }\n\n  return {\n    trimOffsetLeft: leftTrim * -1,\n    trimOffsetTop: topTrim * -1,\n    width: width - leftTrim - rightTrim,\n    height: height - topTrim - bottomTrim,\n  }\n}\n","export interface Point {\n  x: number\n  y: number\n}\n\nexport default function getPointOnCircle(\n  x: number,\n  y: number,\n  r: number,\n  angle: number,\n): Point {\n  return {\n    x: x + r * Math.cos((Math.PI / 180) * angle),\n    y: y + r * Math.sin((Math.PI / 180) * angle),\n  }\n}\n","import getPointOnCircle from './getPointOnCircle'\n\ninterface GarentColor {\n  offset: number\n  color: string\n}\n\ninterface Pradient {\n  type: 0 | 1\n  palette: GarentColor[]\n  angle: number\n}\n\ninterface PatternTexture {\n  image: HTMLImageElement | null\n  repetition: string\n  scale: number\n}\n\ninterface Config {\n  type: number\n  color: string\n  gradient: Pradient\n  patternTexture: PatternTexture\n}\n\nconst svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')\nconst matrix = svg.createSVGMatrix()\n\nexport default function getCanvasStyle(\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  config: Config,\n): string | CanvasGradient | CanvasPattern {\n  // 纯色\n  if (config.type === 0) {\n    return config.color\n  }\n\n  // 渐变\n  if (config.type === 1) {\n    const { type, palette, angle } = config.gradient\n    let gradient: CanvasGradient\n    const cx = x + width / 2\n    const cy = y + height / 2\n    const r = Math.max(width, height) / 2\n    if (type === 0) {\n      const startPoint = getPointOnCircle(cx, cy, r, angle + 180)\n      const endPoint = getPointOnCircle(cx, cy, r, angle)\n      gradient = ctx.createLinearGradient(\n        startPoint.x,\n        startPoint.y,\n        endPoint.x,\n        endPoint.y,\n      )\n    } else {\n      gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, r)\n    }\n\n    palette.forEach((color) => {\n      gradient.addColorStop(color.offset, color.color)\n    })\n\n    return gradient\n  }\n\n  const { image, repetition, scale } = config.patternTexture\n  if (!image) return 'rgba(0,0,0,0)'\n\n  const pattern = ctx.createPattern(image, repetition)\n  if (!pattern) return 'rgba(0,0,0,0)'\n  // TODO: Add trim translate and rotate.\n  pattern.setTransform(matrix.scale(scale).translate(x, y))\n  return pattern\n}\n","import fontStyleStringify, { FontStyleConfig } from './fontStyleStringify'\n\nexport interface TextSize {\n  text: string\n  font: string\n  width: number\n  height: number\n  fontWidth: number\n  fontHeight: number\n  trimOffsetTop: number\n  trimOffsetLeft: number\n  trimOffsetRight: number\n  trimOffsetBottom: number\n}\n\nlet canvas: HTMLCanvasElement\n\nexport default function getTextSize(\n  text: string,\n  config: FontStyleConfig,\n): TextSize {\n  if (!canvas) canvas = document.createElement('canvas')\n  const ctx = canvas.getContext('2d')\n  if (!ctx) throw new Error('Get context 2d failed.')\n\n  // clear before settings\n  canvas.width = 1\n  canvas.height = 1\n\n  const font = fontStyleStringify(config)\n\n  ctx.font = font\n\n  ctx.textAlign = 'left'\n  ctx.textBaseline = 'bottom'\n\n  const testA = ctx.measureText(text)\n\n  if (typeof testA.actualBoundingBoxLeft === 'undefined') {\n    return {\n      text,\n      font,\n      width: testA.width,\n      height: parseInt(`${config.fontSize ?? '14'}`, 10),\n      fontWidth: testA.width,\n      fontHeight: parseInt(`${config.fontSize ?? '14'}`, 10),\n      trimOffsetTop: 0,\n      trimOffsetLeft: 0,\n      trimOffsetRight: 0,\n      trimOffsetBottom: 0,\n    }\n  }\n\n  ctx.textAlign = 'right'\n  ctx.textBaseline = 'top'\n\n  const testB = ctx.measureText(text)\n\n  const trimOffsetLeft = Math.ceil(testA.actualBoundingBoxLeft)\n  const trimOffsetRight = Math.ceil(testB.actualBoundingBoxRight)\n  const trimOffsetTop = Math.ceil(testB.actualBoundingBoxAscent)\n  const trimOffsetBottom = Math.ceil(testA.actualBoundingBoxDescent)\n  const width = trimOffsetLeft + Math.ceil(testA.actualBoundingBoxRight)\n  const height = trimOffsetBottom + Math.ceil(testA.actualBoundingBoxAscent)\n  const fontWidth = Math.ceil(testA.width)\n  const fontHeight =\n    testA.actualBoundingBoxAscent - testB.actualBoundingBoxAscent\n\n  return {\n    text,\n    font,\n    width,\n    height,\n    fontWidth,\n    fontHeight,\n    trimOffsetTop,\n    trimOffsetLeft,\n    trimOffsetRight,\n    trimOffsetBottom,\n  }\n}\n","/**\n * Snap code from: https://opentype.js.org/\n */\n\nimport type { Path } from 'opentype.js'\n\nfunction sharp(v: number, distance: number = 1, strength: number = 80) {\n  return v * (1.0 - strength) + strength * Math.round(v / distance) * distance\n}\n\nexport default function pathDoSharp(\n  path: Path,\n  snapStrength = 80,\n  snapDistance = 1,\n  snapX = 0,\n  snapY = 0,\n) {\n  const strength = snapStrength / 100.0\n  for (let i = 0; i < path.commands.length; i++) {\n    const cmd = path.commands[i]\n    if (cmd.type !== 'Z') {\n      cmd.x = sharp(cmd.x + snapX, snapDistance, strength) - snapX\n      cmd.y = sharp(cmd.y + snapY, snapDistance, strength) - snapY\n    }\n    if (cmd.type === 'Q' || cmd.type === 'C') {\n      cmd.x1 = sharp(cmd.x1 + snapX, snapDistance, strength) - snapX\n      cmd.y1 = sharp(cmd.y1 + snapY, snapDistance, strength) - snapY\n    }\n    if (cmd.type === 'C') {\n      cmd.x2 = sharp(cmd.x2 + snapX, snapDistance, strength) - snapX\n      cmd.y2 = sharp(cmd.y2 + snapY, snapDistance, strength) - snapY\n    }\n  }\n}\n","import { PathCommand } from 'opentype.js'\n\nexport default function ctxDoPath(\n  ctx: CanvasRenderingContext2D,\n  commands: PathCommand[],\n) {\n  ctx.beginPath()\n  for (let i = 0; i < commands.length; i += 1) {\n    const cmd = commands[i]\n    if (cmd.type === 'M') {\n      ctx.moveTo(cmd.x, cmd.y)\n    } else if (cmd.type === 'L') {\n      ctx.lineTo(cmd.x, cmd.y)\n    } else if (cmd.type === 'C') {\n      ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y)\n    } else if (cmd.type === 'Q') {\n      ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y)\n    } else if (cmd.type === 'Z') {\n      ctx.closePath()\n    }\n  }\n}\n","import trimImageData from './trimImageData'\nimport { TextSize } from './getTextSize'\nimport getCanvasStyle from './getCanvasStyle'\nimport { Style } from 'src/store'\nimport pathDoSharp from './pathDoSharp'\nimport ctxDoPath from './ctxDoPath'\n\nexport interface GlyphInfo extends TextSize {\n  canvas: HTMLCanvasElement | null\n}\n\ninterface ParentColor {\n  offset: number\n  color: string\n}\n\ninterface Gradient {\n  type: 0 | 1\n  palette: ParentColor[]\n  angle: number\n}\n\ninterface PatternTexture {\n  image: HTMLImageElement | null\n  repetition: string\n  scale: number\n}\n\ninterface Fill {\n  type: number\n  color: string\n  gradient: Gradient\n  patternTexture: PatternTexture\n}\n\ninterface Stroke extends Fill {\n  width: number\n  lineJoin: CanvasLineJoin\n  lineCap: CanvasLineCap\n}\n\ninterface Font {\n  family: string\n  size: number\n}\n\ninterface Shadow {\n  color: string\n  blur: number\n  offsetX: number\n  offsetY: number\n}\n\nexport interface Config {\n  font: Font\n  fill: Fill\n  stroke?: Stroke\n  shadow?: Shadow\n}\n\nexport default function getFontGlyphInfo(\n  text: string,\n  config: Style,\n): GlyphInfo {\n  const { font, stroke, shadow, fill } = config\n\n  const fontResource = font.fonts.find(({ opentype }) => {\n    if (!opentype) return false\n\n    const glyph = opentype.charToGlyph(text)\n    if (glyph.unicode) {\n      return true\n    }\n    return false\n  })\n\n  if (!fontResource) {\n    throw new Error('Not Find Font.')\n  }\n\n  const opentype = fontResource.opentype\n\n  const glyph = opentype.charToGlyph(text)\n  const scale = font.size / opentype.unitsPerEm\n  const baseline = Math.ceil(opentype.ascender * scale)\n\n  let path = glyph.getPath(0, baseline, font.size)\n  pathDoSharp(path, font.sharp)\n  let boundingBox = path.getBoundingBox()\n\n  const fontWidth = opentype.getAdvanceWidth(text, font.size)\n  const fontHeight = (opentype.ascender - opentype.descender) * scale\n  const trimInfo = {\n    text,\n    font: font.family,\n    width: Math.ceil(boundingBox.x2) - Math.floor(boundingBox.x1),\n    height: Math.ceil(boundingBox.y2) - Math.floor(boundingBox.y1),\n    fontWidth,\n    fontHeight,\n    trimOffsetTop: Math.round(boundingBox.y1) * -1,\n    trimOffsetLeft: Math.round(boundingBox.x1) * -1,\n    trimOffsetRight: Math.round(fontWidth - boundingBox.x1) * -1,\n    trimOffsetBottom: Math.round(fontHeight - boundingBox.y2) * -1,\n  }\n\n  const { width, height, trimOffsetLeft, trimOffsetTop } = trimInfo\n  if (width === 0 || height === 0) return { canvas: null, ...trimInfo }\n\n  const lineWidth = stroke ? stroke.width * 2 : 0 // canvas is center stroke\n  let addX = lineWidth\n  let addY = lineWidth\n\n  if (shadow) {\n    const blur = Math.ceil(shadow.blur * 1.5)\n    addX += Math.abs(shadow.offsetX) + blur\n    addY += Math.abs(shadow.offsetY) + blur\n  }\n\n  let canvas = document.createElement('canvas')\n  let ctx = canvas.getContext('2d') as CanvasRenderingContext2D\n  canvas.width = width + addX * 2\n  canvas.height = height + addY * 2\n\n  ctx.translate(addX + trimOffsetLeft, addY + trimOffsetTop)\n  ctxDoPath(ctx, path.commands)\n  ctx.fillStyle = getCanvasStyle(ctx, 0, 0, fontWidth, fontHeight, fill)\n  ctx.fill()\n\n  if (stroke && lineWidth) {\n    const strokCanvas = document.createElement('canvas')\n    strokCanvas.width = canvas.width\n    strokCanvas.height = canvas.height\n    const strokCtx = strokCanvas.getContext('2d') as CanvasRenderingContext2D\n    strokCtx.translate(addX + trimOffsetLeft, addY + trimOffsetTop)\n    strokCtx.lineCap = stroke.lineCap\n    strokCtx.lineJoin = stroke.lineJoin\n    strokCtx.strokeStyle = path.stroke = getCanvasStyle(\n      strokCtx,\n      0,\n      0,\n      fontWidth,\n      fontHeight,\n      stroke,\n    ) as string\n    strokCtx.fillStyle = '#000000'\n\n    if (stroke.strokeType === 1) {\n      strokCtx.lineWidth = path.strokeWidth = stroke.width\n    } else {\n      strokCtx.lineWidth = path.strokeWidth = lineWidth\n    }\n\n    ctxDoPath(strokCtx, path.commands)\n\n    if (stroke.strokeType === 2) {\n      strokCtx.fill()\n      strokCtx.globalCompositeOperation = 'source-in'\n      strokCtx.stroke()\n    } else if (stroke.strokeType === 1) {\n      strokCtx.stroke()\n    } else {\n      strokCtx.stroke()\n      strokCtx.globalCompositeOperation = 'destination-out'\n      strokCtx.fill()\n    }\n    strokCtx.globalCompositeOperation = 'source-over'\n    ctx.setTransform(1, 0, 0, 1, 0, 0)\n    ctx.drawImage(strokCanvas, 0, 0)\n  }\n\n  if (shadow) {\n    const cvs = document.createElement('canvas')\n    cvs.width = width + addX * 2\n    cvs.height = height + addY * 2\n    const newCtx = cvs.getContext('2d') as CanvasRenderingContext2D\n\n    newCtx.shadowColor = shadow.color\n    newCtx.shadowBlur = shadow.blur\n    newCtx.shadowOffsetX = shadow.offsetX\n    newCtx.shadowOffsetY = shadow.offsetY\n    newCtx.drawImage(canvas, 0, 0)\n\n    canvas = cvs\n    ctx = newCtx\n  }\n\n  if (canvas.width === 0 || canvas.height === 0) {\n    return {\n      canvas,\n      ...trimInfo,\n    }\n  }\n\n  const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height)\n  const styleTrimInfo = trimImageData(imgData)\n  canvas.width = trimInfo.width = styleTrimInfo.width\n  canvas.height = trimInfo.height = styleTrimInfo.height\n\n  ctx.putImageData(\n    imgData,\n    styleTrimInfo.trimOffsetLeft,\n    styleTrimInfo.trimOffsetTop,\n  )\n\n  trimInfo.trimOffsetLeft += addX + styleTrimInfo.trimOffsetLeft\n  trimInfo.trimOffsetTop += addY + styleTrimInfo.trimOffsetTop\n  trimInfo.trimOffsetBottom +=\n    addY +\n    (height + addY * 2 + styleTrimInfo.trimOffsetTop - styleTrimInfo.height)\n\n  return {\n    canvas,\n    ...trimInfo,\n  }\n}\n","import trimImageData from './trimImageData'\nimport getTextSize, { TextSize } from './getTextSize'\nimport fontStyleStringify from './fontStyleStringify'\nimport getCanvasStyle from './getCanvasStyle'\n\nexport interface GlyphInfo extends TextSize {\n  canvas: HTMLCanvasElement | null\n}\n\ninterface ParentColor {\n  offset: number\n  color: string\n}\n\ninterface Gradient {\n  type: 0 | 1\n  palette: ParentColor[]\n  angle: number\n}\n\ninterface PatternTexture {\n  image: HTMLImageElement | null\n  repetition: string\n  scale: number\n}\n\ninterface Fill {\n  type: number\n  color: string\n  gradient: Gradient\n  patternTexture: PatternTexture\n}\n\ninterface Stroke extends Fill {\n  width: number\n  lineJoin: CanvasLineJoin\n  lineCap: CanvasLineCap\n  strokeType: 0 | 1 | 2\n}\n\ninterface Font {\n  family: string\n  size: number\n}\n\ninterface Shadow {\n  color: string\n  blur: number\n  offsetX: number\n  offsetY: number\n}\n\nexport interface Config {\n  font: Font\n  fill: Fill\n  stroke?: Stroke\n  shadow?: Shadow\n}\n\nexport default function getGlyphInfo(text: string, config: Config): GlyphInfo {\n  const { font, stroke, shadow, fill } = config\n\n  const styleConig = {\n    fontSize: font.size,\n    fontFamily: font.family,\n  }\n\n  const trimInfo = getTextSize(text, styleConig)\n  const { width, height, trimOffsetLeft, trimOffsetTop } = trimInfo\n  if (width === 0 || height === 0) return { canvas: null, ...trimInfo }\n\n  const lineWidth = stroke ? stroke.width * 2 : 0 // canvas is center stroke\n  let addX = lineWidth\n  let addY = lineWidth\n  let styleX = (width - font.size) / 2\n  let styleY = trimOffsetTop\n\n  if (shadow) {\n    const blur = Math.ceil(shadow.blur * 1.5)\n    addX += Math.abs(shadow.offsetX) + blur\n    addY += Math.abs(shadow.offsetY) + blur\n  }\n\n  styleX += addX\n  styleY += addY\n\n  let canvas = document.createElement('canvas')\n  let ctx = canvas.getContext('2d') as CanvasRenderingContext2D\n  canvas.width = width + addX * 2\n  canvas.height = height + addY * 2\n\n  ctx.textAlign = 'left'\n  ctx.textBaseline = 'top'\n\n  ctx.font = fontStyleStringify({\n    fontSize: font.size,\n    fontFamily: font.family,\n  })\n\n  ctx.fillStyle = getCanvasStyle(\n    ctx,\n    styleX,\n    styleY,\n    font.size,\n    font.size,\n    fill,\n  )\n  ctx.fillText(text, addX + trimOffsetLeft, addY + trimOffsetTop)\n\n  if (stroke && lineWidth) {\n    const strokCanvas = document.createElement('canvas')\n    strokCanvas.width = canvas.width\n    strokCanvas.height = canvas.height\n    const strokCtx = strokCanvas.getContext('2d') as CanvasRenderingContext2D\n\n    strokCtx.textAlign = 'left'\n    strokCtx.textBaseline = 'top'\n\n    strokCtx.font = fontStyleStringify({\n      fontSize: font.size,\n      fontFamily: font.family,\n    })\n\n    strokCtx.lineCap = stroke.lineCap\n    strokCtx.lineJoin = stroke.lineJoin\n    strokCtx.strokeStyle = getCanvasStyle(\n      strokCtx,\n      styleX,\n      styleY,\n      font.size,\n      font.size,\n      stroke,\n    )\n\n    strokCtx.fillStyle = '#000000'\n\n    if (stroke.strokeType === 1) {\n      strokCtx.lineWidth = stroke.width\n    } else {\n      strokCtx.lineWidth = lineWidth\n    }\n\n    if (stroke.strokeType === 2) {\n      strokCtx.fillText(text, addX + trimOffsetLeft, addY + trimOffsetTop)\n      strokCtx.globalCompositeOperation = 'source-in'\n      strokCtx.strokeText(text, addX + trimOffsetLeft, addY + trimOffsetTop)\n    } else if (stroke.strokeType === 1) {\n      strokCtx.strokeText(text, addX + trimOffsetLeft, addY + trimOffsetTop)\n    } else {\n      strokCtx.strokeText(text, addX + trimOffsetLeft, addY + trimOffsetTop)\n      strokCtx.globalCompositeOperation = 'destination-out'\n      strokCtx.fillText(text, addX + trimOffsetLeft, addY + trimOffsetTop)\n    }\n    strokCtx.globalCompositeOperation = 'source-over'\n    ctx.drawImage(strokCanvas, 0, 0)\n  }\n\n  if (shadow) {\n    const cvs = document.createElement('canvas')\n    cvs.width = width + addX * 2\n    cvs.height = height + addY * 2\n    const newCtx = cvs.getContext('2d') as CanvasRenderingContext2D\n\n    newCtx.shadowColor = shadow.color\n    newCtx.shadowBlur = shadow.blur\n    newCtx.shadowOffsetX = shadow.offsetX\n    newCtx.shadowOffsetY = shadow.offsetY\n\n    newCtx.drawImage(canvas, 0, 0)\n\n    canvas = cvs\n    ctx = newCtx\n  }\n\n  if (canvas.width === 0 || canvas.height === 0) {\n    return {\n      canvas,\n      ...trimInfo,\n    }\n  }\n\n  const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height)\n  const styleTrimInfo = trimImageData(imgData)\n  canvas.width = styleTrimInfo.width\n  canvas.height = styleTrimInfo.height\n  trimInfo.width = styleTrimInfo.width\n  trimInfo.height = styleTrimInfo.height\n  ctx.putImageData(\n    imgData,\n    styleTrimInfo.trimOffsetLeft,\n    styleTrimInfo.trimOffsetTop,\n  )\n  trimInfo.trimOffsetLeft += addX + styleTrimInfo.trimOffsetLeft\n  trimInfo.trimOffsetTop += addY + styleTrimInfo.trimOffsetTop\n  trimInfo.trimOffsetBottom +=\n    addY +\n    (height + addY * 2 + styleTrimInfo.trimOffsetTop - styleTrimInfo.height)\n\n  return {\n    canvas,\n    ...trimInfo,\n  }\n}\n","import { observable, action } from 'mobx'\n\nimport Metric from './metric'\n\nexport type GlyphType = 'text' | 'image'\n\nclass GlyphBase {\n  readonly type: GlyphType = 'text'\n\n  @observable letter = ''\n\n  @observable.ref source: HTMLImageElement | HTMLCanvasElement | null = null\n\n  @observable width = 0\n\n  @observable height = 0\n\n  @observable x = 0\n\n  @observable y = 0\n\n  @observable fontWidth = 0\n\n  @observable fontHeight = 0\n\n  @observable trimOffsetTop = 0\n\n  @observable trimOffsetLeft = 0\n\n  @observable trimOffsetRight = 0\n\n  @observable trimOffsetBottom = 0\n\n  @observable.ref adjustMetric: Metric\n\n  @observable kerning: Map<string, number> = new Map()\n\n  constructor(glyph: Partial<GlyphBase> = {}) {\n    this.letter = glyph.letter || ''\n    this.adjustMetric = new Metric(glyph.adjustMetric)\n\n    if (glyph.kerning) {\n      this.kerning = glyph.kerning\n    }\n  }\n\n  @action.bound steKerning(text: string, kerning: number) {\n    this.kerning.set(text, kerning)\n  }\n}\n\nexport default GlyphBase\n","import { action } from 'mobx'\nimport getFontGlyphInfo from 'src/utils/getFontGlyphInfo'\nimport getGlyphInfo, { Config } from 'src/utils/getGlyphInfo'\nimport GlyphBase from './glyphBase'\n\nimport Style from './style'\n\nclass GlyphFont extends GlyphBase {\n  constructor(galyphFont: Partial<GlyphFont> = {}, textStyle: Style) {\n    super(galyphFont)\n    this.setGlyphInfo(textStyle)\n  }\n\n  @action setGlyphInfo(textStyle: Style): void {\n    const { font, fill, useStroke, stroke, useShadow, shadow } = textStyle\n    const config: Config = { font, fill }\n    if (useStroke) config.stroke = stroke\n    if (useShadow) config.shadow = shadow\n\n    let glyphInfo\n    try {\n      glyphInfo = getFontGlyphInfo(this.letter, config as Style)\n    } catch (e) {\n      glyphInfo = getGlyphInfo(this.letter, config)\n    }\n    this.source = glyphInfo.canvas\n    this.width = glyphInfo.width\n    this.height = glyphInfo.height\n    this.fontWidth = glyphInfo.fontWidth\n    this.fontHeight = glyphInfo.fontHeight\n    this.trimOffsetTop = glyphInfo.trimOffsetTop\n    this.trimOffsetLeft = glyphInfo.trimOffsetLeft\n    this.trimOffsetRight = glyphInfo.trimOffsetRight\n    this.trimOffsetBottom = glyphInfo.trimOffsetBottom\n  }\n}\n\nexport default GlyphFont\n","import { configure } from 'mobx'\n\nimport Ui from './ui'\nimport Workspace from './workspace'\n\nconfigure({\n  enforceActions: 'always',\n  computedRequiresReaction: true,\n})\n\nexport interface Store {\n  ui: Ui\n  workspace: Workspace\n}\n\nlet store: Store\n\nexport default function createStore(): Store {\n  if (!store) store = { ui: new Ui(), workspace: new Workspace() }\n  return store\n}\n\nexport type TStore = ReturnType<typeof createStore>\n\nexport { default as Ui } from './ui'\nexport { default as Project } from './project'\nexport { default as Workspace } from './workspace'\n\nexport * from './base'\n","import { action, observable, runInAction } from 'mobx'\nimport getTrimImageInfo from 'src/utils/getTrimImageInfo'\n\nimport GlyphBase, { GlyphType } from './glyphBase'\n\nexport interface FileInfo {\n  letter?: string\n  fileName: string\n  fileType: string\n  buffer: ArrayBuffer\n}\n\nclass GlyphImage extends GlyphBase {\n  readonly type: GlyphType = 'image'\n\n  @observable src = '' // 仅显示列表中\n\n  @observable.ref buffer: ArrayBuffer | null = null\n\n  @observable fileName = ''\n\n  @observable fileType = ''\n\n  @observable selected = true\n\n  constructor(glyphImage: Partial<GlyphImage>) {\n    super(glyphImage)\n    this.letter = glyphImage.letter || ''\n    this.fileName = glyphImage.fileName || ''\n    this.fileType = glyphImage.fileType || ''\n    this.buffer = glyphImage.buffer || null\n    if (glyphImage.buffer) {\n      this.src = URL.createObjectURL(new Blob([glyphImage.buffer]))\n      this.initImage()\n    }\n  }\n\n  @action.bound initImage(): Promise<void> {\n    return new Promise((resolve) => {\n      const image = new Image()\n      image.onload = () => {\n        runInAction('trimImage', () => {\n          const { naturalWidth, naturalHeight } = image\n          this.fontWidth = naturalWidth\n          this.fontHeight = naturalHeight\n\n          const trimInfo = getTrimImageInfo(image)\n          this.width = trimInfo.width\n          this.height = trimInfo.height\n          this.trimOffsetLeft = trimInfo.trimOffsetLeft\n          this.trimOffsetTop = trimInfo.trimOffsetTop\n          this.trimOffsetRight =\n            trimInfo.width - trimInfo.trimOffsetLeft - naturalWidth\n          this.trimOffsetBottom =\n            trimInfo.height - trimInfo.trimOffsetTop - naturalHeight\n\n          this.source = trimInfo.canvas\n          resolve()\n        })\n      }\n      image.src = this.src\n    })\n  }\n\n  @action.bound setGlyph(text: string): void {\n    this.letter = text[0] || ''\n  }\n\n  @action.bound changeSelect(isSelect: boolean): void {\n    this.selected = isSelect\n  }\n}\n\nexport default GlyphImage\n","import trimImageData, { TrimImageInfo } from './trimImageData'\n\ninterface TrimInfo extends TrimImageInfo {\n  canvas: HTMLCanvasElement\n}\n\nexport default function getTrimImageInfo(\n  image: HTMLImageElement,\n  threshold = 0,\n): TrimInfo {\n  const width = image.naturalWidth\n  const height = image.naturalHeight\n\n  const canvas = document.createElement('canvas')\n  canvas.width = width\n  canvas.height = height\n  const ctx = canvas.getContext('2d') as CanvasRenderingContext2D\n  ctx.drawImage(image, 0, 0)\n  const imageData = ctx.getImageData(0, 0, width, height)\n  const trimInfo = trimImageData(imageData, threshold)\n  canvas.width = trimInfo.width\n  canvas.height = trimInfo.height\n  ctx.drawImage(image, trimInfo.trimOffsetLeft, trimInfo.trimOffsetTop)\n\n  return {\n    canvas,\n    ...trimInfo,\n  }\n}\n","import { observable, action, computed } from 'mobx'\nimport { deepObserve } from 'mobx-utils'\nimport { cancel, request } from 'requestidlecallback'\nimport { GuillotineBinPack } from 'rectangle-packer'\n// eslint-disable-next-line import/no-webpack-loader-syntax\n// import RectanglePacker from 'worker-loader?filename=static/js/RectanglePacker.[hash].worker.js!src/workers/RectanglePacker.worker'\n// eslint-disable-next-line import/no-webpack-loader-syntax\nimport AutoPacker from 'worker-loader?filename=static/js/AutoPacker.[hash].worker.js!src/workers/AutoPacker.worker'\n\nimport Ui from './base/ui'\nimport Style from './base/style'\nimport Layout from './base/layout'\nimport Metric from './base/metric'\nimport GlyphFont from './base/glyphFont'\nimport GlyphImage, { FileInfo } from './base/glyphImage'\nimport { GlyphType } from './base/glyphBase'\ninterface TextRectangle {\n  width: number\n  height: number\n  x: number\n  y: number\n  letter: string\n  type: GlyphType\n}\n\nclass Project {\n  @observable name = 'Unnamed'\n\n  id: number\n\n  worker: AutoPacker | null = null\n\n  packStart = 0\n\n  packTimer = 0\n\n  idleId = 0\n\n  @observable isPacking = false\n\n  @observable text =\n    '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!№;%:?*()_+-=.,/|\"\\'@#$^&{}[]'\n\n  @observable.shallow glyphs: Map<string, GlyphFont> = new Map()\n\n  @observable.shallow glyphImages: GlyphImage[] = []\n\n  @observable.ref style: Style\n\n  @observable.ref layout: Layout\n\n  @observable.ref globalAdjustMetric: Metric\n\n  @observable.ref packCanvas: HTMLCanvasElement | null = null\n\n  @observable.ref ui: Ui = new Ui()\n\n  constructor(project: Partial<Project> = {}) {\n    this.id = project.id || Date.now()\n    this.name = project.name || 'Unnamed'\n    this.text = project.text || this.text\n    this.ui = new Ui(project.ui)\n    this.style = new Style(project.style)\n    this.layout = new Layout(project.layout)\n    this.globalAdjustMetric = new Metric(project.globalAdjustMetric)\n\n    if (project.glyphs) {\n      project.glyphs.forEach((value, key) => {\n        this.glyphs.set(key, new GlyphFont(value, this.style))\n      })\n    }\n\n    project.glyphImages?.forEach((img) => {\n      this.glyphImages.push(new GlyphImage(img))\n    })\n\n    if (!this.glyphs.has(' '))\n      this.glyphs.set(' ', new GlyphFont({ letter: ' ' }, this.style))\n\n    this.addGlyphs(project.text || '')\n    this.addAutoRun()\n    this.pack()\n  }\n\n  @computed get glyphList(): (GlyphFont | GlyphImage)[] {\n    const obj: { [key: string]: GlyphImage } = {}\n\n    this.glyphImages.forEach((glyph) => {\n      if (glyph.letter && glyph.selected) {\n        obj[glyph.letter] = glyph\n      }\n    })\n\n    return ` ${this.text}`.split('').map((letter) => {\n      if (obj[letter]) return obj[letter]\n      return this.glyphs.get(letter) as GlyphFont\n    })\n  }\n\n  @computed get rectangleList(): TextRectangle[] {\n    const { padding, spacing } = this.layout\n    return this.glyphList.map((glyph) => {\n      const isUnEmpty = !!(glyph.width && glyph.height)\n      return {\n        letter: glyph.letter,\n        type: glyph.type,\n        width: isUnEmpty ? glyph.width + padding * 2 + spacing : 0,\n        height: isUnEmpty ? glyph.height + padding * 2 + spacing : 0,\n        x: 0,\n        y: 0,\n      }\n    })\n  }\n\n  @action.bound pack(): void {\n    if (this.idleId) return\n    if (this.worker) this.worker.terminate()\n    this.isPacking = true\n    const packList = this.rectangleList.sort((a, b) => b.height - a.height)\n    if (!this.layout.auto) {\n      const packer = new GuillotineBinPack<TextRectangle>(\n        this.layout.width + this.layout.spacing,\n        this.layout.height + this.layout.spacing,\n      )\n\n      const list = packList.filter(({ width, height }) => !!(width && height))\n\n      packer.InsertSizes(list, true, 1, 1)\n\n      this.setPack(packer.usedRectangles, list)\n\n      this.isPacking = false\n      return\n    }\n    this.worker = new AutoPacker()\n    this.worker.addEventListener(\n      'message',\n      action('PackerWorkerCallback', (messageEvent) => {\n        const { data } = messageEvent\n        this.setPack(data)\n\n        this.isPacking = false\n        this.worker?.terminate()\n        this.worker = null\n      }),\n      false,\n    )\n\n    this.worker.postMessage(\n      packList.filter(({ width, height }) => !!(width && height)),\n    )\n  }\n\n  @action.bound setPack(\n    list: TextRectangle[],\n    failedList?: TextRectangle[],\n  ): void {\n    const imgList = this.glyphImages\n    let maxWidth = 0\n    let maxHeight = 0\n    const { auto, fixedSize, width, height, spacing } = this.layout\n\n    list.forEach((rectangle) => {\n      const { letter, x, y, type, width, height } = rectangle\n      let glyph: GlyphFont | GlyphImage | undefined\n\n      if (type === 'image') {\n        glyph = imgList.find((gi) => {\n          if (gi && gi.letter === letter) return true\n          return false\n        })\n      }\n\n      if (!glyph) {\n        glyph = this.glyphs.get(letter)\n      }\n\n      if (glyph) {\n        glyph.x = x || 0\n        glyph.y = y || 0\n      }\n\n      maxWidth = Math.max(maxWidth, x + width)\n      maxHeight = Math.max(maxHeight, y + height)\n    })\n\n    if (failedList?.length) {\n      failedList.forEach((rectangle) => {\n        const { letter, type } = rectangle\n        let glyph: GlyphFont | GlyphImage | undefined\n\n        if (type === 'image') {\n          glyph = imgList.find((gi) => {\n            if (gi && gi.letter === letter) return true\n            return false\n          })\n        }\n\n        if (!glyph) {\n          glyph = this.glyphs.get(letter)\n        }\n\n        if (glyph) {\n          glyph.x = 0\n          glyph.y = 0\n        }\n      })\n      this.ui.setPackFailed(true)\n    } else {\n      this.ui.setPackFailed(false)\n    }\n\n    if (!auto && fixedSize) {\n      this.ui.setSize(width, height)\n      return\n    }\n\n    this.ui.setSize(maxWidth - spacing, maxHeight - spacing)\n  }\n\n  @action.bound packStyle(): void {\n    this.isPacking = true\n    if (this.worker) {\n      this.worker.terminate()\n      this.worker = null\n    }\n    cancel(this.idleId)\n\n    const tasks: GlyphFont[] = []\n\n    this.glyphs.forEach((glyph) => {\n      tasks.push(glyph)\n    })\n\n    const runTasks = () => {\n      this.idleId = request((deadline) => {\n        const tr = deadline.timeRemaining()\n        const start = Date.now()\n        while (tasks.length && tr - (Date.now() - start) > -100) {\n          // while (tasks.length) {\n          const glyph = tasks.shift()\n          if (glyph) glyph.setGlyphInfo(this.style)\n        }\n\n        if (tasks.length) {\n          runTasks()\n        } else {\n          this.idleId = 0\n          this.pack()\n        }\n      })\n    }\n\n    runTasks()\n  }\n\n  @action.bound throttlePack(): void {\n    if (this.idleId) return\n    window.clearTimeout(this.packTimer)\n    if (Date.now() - this.packStart > 500) {\n      Promise.resolve().then(this.pack)\n    } else {\n      this.packTimer = window.setTimeout(() => {\n        this.pack()\n      }, 500)\n    }\n    this.packStart = Date.now()\n  }\n\n  addAutoRun(): void {\n    const isName = (obj: { name?: unknown }, name: string): boolean =>\n      !!(obj.name && obj.name === name)\n\n    deepObserve(this.glyphs, () => {\n      this.throttlePack()\n    })\n\n    deepObserve(this.glyphImages, () => {\n      this.throttlePack()\n    })\n\n    deepObserve(this.layout, () => {\n      this.throttlePack()\n    })\n\n    deepObserve(this.style, (change) => {\n      if (isName(change, 'bgColor') || isName(change, 'lineHeight')) return\n      this.packStyle()\n    })\n  }\n\n  @action.bound setText(str: string): void {\n    const oldText = this.text\n    this.text = str.replace(/\\s/gm, '')\n    this.addGlyphs(oldText)\n  }\n\n  @action.bound addGlyphs(oldText = ''): void {\n    const currentList = Array.from(new Set(this.text.split('')))\n    const oldList = Array.from(new Set(oldText.split('')))\n    this.text = currentList.join('')\n    const diffList = oldText\n      ? Array.from(new Set(currentList.concat(oldList))).filter(\n          (t) => !(currentList.includes(t) && oldList.includes(t)),\n        )\n      : currentList\n\n    if (!diffList.length) return\n\n    diffList.forEach((letter) => {\n      if (currentList.includes(letter)) {\n        this.glyphs.set(letter, new GlyphFont({ letter }, this.style))\n      } else {\n        // in diff\n        this.glyphs.delete(letter)\n      }\n    })\n  }\n\n  @action.bound addImages<T extends FileInfo>(list: T[]): void {\n    Promise.all(\n      list.map((img) => {\n        const glyphImage = new GlyphImage(img)\n        this.glyphImages.push(glyphImage)\n        return glyphImage.initImage()\n      }),\n    ).then(this.pack)\n  }\n\n  @action.bound removeImage(image: GlyphImage): void {\n    const idx = this.glyphImages.indexOf(image)\n    if (idx > -1) this.glyphImages.splice(idx, 1)\n  }\n\n  @action.bound setCanvas(canvas: HTMLCanvasElement): void {\n    this.packCanvas = canvas\n  }\n\n  @action.bound setName(name: string): void {\n    this.name = name || this.name\n  }\n}\n\nexport default Project\n","import { action, observable, runInAction, computed } from 'mobx'\n\nimport Project from './project'\n\nclass Workspace {\n  @observable activeId = 0\n\n  @observable.shallow projectList: Map<number, Project> = new Map()\n\n  constructor() {\n    runInAction(() => {\n      this.activeId = Date.now()\n      const project = new Project({ id: this.activeId })\n      this.projectList.set(project.id, project)\n    })\n  }\n\n  @computed get currentProject(): Project {\n    return this.projectList.get(this.activeId) as Project\n  }\n\n  @computed get namedList(): { id: number; name: string }[] {\n    const list: { id: number; name: string }[] = []\n    this.projectList.forEach((value) => {\n      list.push({\n        id: value.id,\n        name: value.name,\n      })\n    })\n    return list\n  }\n\n  @action.bound selectProject(id: number): void {\n    if (this.projectList.has(id)) this.activeId = id\n  }\n\n  @action.bound removeProject(id: number): void {\n    const list = this.namedList.filter((item) => item.id !== id)\n    if (list.length === 0) return\n    this.activeId = list[0].id\n    this.projectList.delete(id)\n  }\n\n  @action.bound addProject(p: Partial<Project> = {}): void {\n    if (p.id && this.projectList.has(p.id)) {\n      this.activeId = p.id\n      return\n    }\n    if (!p.name) {\n      p.name = 'Unnamed'\n      const namedList: number[] = []\n      this.projectList.forEach((item) => {\n        const named = item.name.match(/^Unnamed-?(\\d+)?$/)\n        if (named) {\n          namedList.push(Number(named[1]) || 0)\n        }\n      })\n      if (namedList.length > 0) {\n        p.name += `-${Math.max(...namedList) + 1}`\n      }\n    }\n\n    const project = new Project(p)\n    this.projectList.set(project.id, project)\n    this.activeId = project.id\n  }\n\n  @action.bound setProjectName(name: string, value: number): void {\n    const project = this.projectList.get(value)\n    if (project) {\n      project.setName(name)\n    }\n  }\n}\n\nexport default Workspace\n","import { ComponentsProps } from '@material-ui/core/styles/props'\n\nconst props: ComponentsProps = {\n  MuiButton: {\n    size: 'small',\n  },\n  MuiButtonBase: {\n    disableRipple: true,\n  },\n  MuiFilledInput: {\n    margin: 'dense',\n  },\n  MuiFormControl: {\n    margin: 'dense',\n  },\n  MuiFormHelperText: {\n    margin: 'dense',\n  },\n  MuiIconButton: {\n    size: 'small',\n  },\n  MuiInputBase: {\n    margin: 'dense',\n  },\n  MuiInputLabel: {\n    margin: 'dense',\n  },\n  MuiListItem: {\n    dense: true,\n  },\n  MuiOutlinedInput: {\n    margin: 'dense',\n  },\n  MuiFab: {\n    size: 'small',\n  },\n  MuiTable: {\n    size: 'small',\n  },\n  MuiTextField: {\n    margin: 'dense',\n  },\n  MuiToolbar: {\n    variant: 'dense',\n  },\n}\n\nexport default props\n","import { Overrides } from '@material-ui/core/styles/overrides'\n\nconst overrides: Overrides = {\n  MuiCssBaseline: {\n    '@global': {\n      'html,body,#root': {\n        width: '100%',\n        height: '100%',\n      },\n      html: {\n        fontSize: '14px',\n      },\n      body: {\n        margin: 0,\n        // fontFamily: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;\n        WebkitFontSmoothing: 'antialiased',\n        MozOsxFontSmoothing: 'grayscale',\n        userSelect: 'none',\n      },\n      '#root': {\n        minWidth: 900,\n      },\n      'input::-webkit-inner-spin-button': {\n        marginLeft: '10px',\n      },\n      'input:enabled:read-write:-webkit-any(:focus,:hover)::-webkit-inner-spin-button':\n        {\n          opacity: 0.3,\n        },\n      '::-webkit-scrollbar': {\n        width: '4px',\n        height: '4px',\n      },\n      '::-webkit-scrollbar-thumb': {\n        background: 'rgba(255, 255, 255, 0.2)',\n      },\n      '::-webkit-scrollbar-track': {\n        background: 'rgba(0, 0, 0, 0.1)',\n      },\n    },\n  },\n  MuiInputBase: {\n    input: {\n      '&[type=number]': {\n        textAlign: 'right',\n      },\n    },\n  },\n  MuiSlider: {\n    root: {\n      verticalAlign: 'top',\n      '&.Mui-disabled': {\n        opacity: 0.2,\n      },\n    },\n  },\n}\n\nexport default overrides\n","import { createTheme, responsiveFontSizes } from '@material-ui/core/styles'\n\nimport props from './props'\nimport overrides from './overrides'\n\nconst theme = createTheme({\n  palette: {\n    type: 'dark',\n    primary: { main: '#444' },\n    secondary: { main: '#424242' },\n    background: {\n      paper: 'rgb(37, 37, 37)',\n      default: 'rgb(30, 30, 30)',\n      activityBar: 'rgb(51, 51, 51)',\n      titleBar: 'rgb(50, 50, 50)',\n      sidebar: 'rgb(37, 37, 37)',\n    },\n    common: {\n      black: 'rgb(30,30,30)',\n      white: 'rgb(204,204,204)',\n    },\n    action: {\n      hover: 'rgba(255, 255, 255, 0.1)',\n    },\n  },\n  bgPixel: {\n    backgroundColor: '#fff',\n    backgroundImage: `\n    linear-gradient(45deg, #ccc 25%, transparent 0, transparent 75%, #ccc 0),\n    linear-gradient(45deg, #ccc 25%, transparent 0, transparent 75%, #ccc 0)`,\n    backgroundSize: '8px 8px',\n    backgroundPosition: '0 0, 4px 4px',\n    backgroundRepeat: 'repeat',\n  },\n  spacing: 4,\n  typography: { fontSize: 13 },\n  transitions: {\n    create: () => 'none',\n  },\n  shape: { borderRadius: 0 },\n  props,\n  overrides,\n})\n\nexport default responsiveFontSizes(theme)\n","import { useContext } from 'react'\nimport { MobXProviderContext } from 'mobx-react'\nimport {\n  TStore,\n  Workspace,\n  Layout,\n  Project,\n  Style,\n  Font,\n  ProjectUi,\n  FontStyleConfig,\n} from '.'\n\nexport default function useStores(): TStore {\n  return useContext(MobXProviderContext) as TStore\n}\n\nexport function useWorkspace(): Workspace {\n  const store = useStores()\n  return store.workspace\n}\n\nexport function useLayout(): Layout {\n  const store = useStores()\n  return store.workspace.currentProject.layout\n}\n\nexport function useProject(): Project {\n  const store = useStores()\n  return store.workspace.currentProject\n}\n\nexport function useStyle(): Style {\n  const { style } = useProject()\n  return style\n}\n\nexport function useFont(): Font {\n  const { font } = useStyle()\n  return font\n}\n\nexport function useFill(): FontStyleConfig {\n  const { fill } = useStyle()\n  return fill\n}\n\nexport function useProjectUi(): ProjectUi {\n  const { ui } = useProject()\n  return ui\n}\n","function readFile(\n  file: File,\n  isText?: boolean,\n): Promise<string | ArrayBuffer | null> {\n  if (file.arrayBuffer && !isText) return file.arrayBuffer()\n\n  return new Promise((resolve) => {\n    const reader = new FileReader()\n\n    if (isText) {\n      reader.readAsText(file)\n    } else {\n      reader.readAsArrayBuffer(file)\n    }\n\n    reader.onload = (e) => {\n      resolve(e?.target?.result || null)\n    }\n  })\n}\n\nexport default readFile\n","import React, { useState, FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport { useSnackbar } from 'notistack'\nimport * as Sentry from '@sentry/react'\n\nimport Button from '@material-ui/core/Button'\nimport List from '@material-ui/core/List'\nimport ListItem from '@material-ui/core/ListItem'\nimport IconButton from '@material-ui/core/IconButton'\nimport ListItemText from '@material-ui/core/ListItemText'\nimport ListItemSecondaryAction from '@material-ui/core/ListItemSecondaryAction'\nimport FontDownload from '@material-ui/icons/FontDownload'\nimport CircularProgress from '@material-ui/core/CircularProgress'\nimport HighlightOffIcon from '@material-ui/icons/HighlightOff'\n\nimport { useFont } from 'src/store/hooks'\nimport readFile from 'src/utils/readFile'\n\nconst FontFamily: FunctionComponent<unknown> = () => {\n  const [loading, setLoading] = useState(false)\n  const { fonts, addFont, removeFont } = useFont()\n  const { enqueueSnackbar } = useSnackbar()\n\n  const hanleUploadFile = (\n    event: React.ChangeEvent<HTMLInputElement>,\n  ): void => {\n    if (\n      !event ||\n      !event.target ||\n      !event.target.files ||\n      !event.target.files[0]\n    )\n      return\n\n    const file = event.target.files[0]\n    const ext = file.name.match(/\\.([A-Z0-9]+)$/i)\n    if (!ext) return\n\n    setLoading(true)\n\n    readFile(file).then((arrBuf) => {\n      if (!(arrBuf instanceof ArrayBuffer)) {\n        setLoading(false)\n        return\n      }\n\n      event.target.value = ''\n\n      addFont(arrBuf)\n        .then(() => setLoading(false))\n        .catch((e) => {\n          setLoading(false)\n          enqueueSnackbar(e.message, { variant: 'error' })\n          Sentry.captureException(e)\n        })\n    })\n  }\n\n  // TODO: List add sort.\n  return (\n    <div>\n      <List dense={true} disablePadding={true}>\n        {fonts.map((fontResource) => (\n          <ListItem\n            key={fontResource.family}\n            disableGutters={true}\n            divider={true}\n            dense={true}\n          >\n            <ListItemText primary={fontResource.family} />\n            <ListItemSecondaryAction>\n              <IconButton\n                edge='end'\n                aria-label='delete'\n                onClick={() => removeFont(fontResource)}\n              >\n                <HighlightOffIcon />\n              </IconButton>\n            </ListItemSecondaryAction>\n          </ListItem>\n        ))}\n      </List>\n      <Button\n        component='label'\n        variant='contained'\n        color='primary'\n        fullWidth\n        size='large'\n        startIcon={\n          loading ? (\n            <CircularProgress size={22} color='inherit' />\n          ) : (\n            <FontDownload />\n          )\n        }\n        disabled={loading}\n      >\n        Add Font File\n        <input\n          hidden\n          type='file'\n          onChange={hanleUploadFile}\n          accept='.ttf,.otf,.woff'\n        />\n      </Button>\n    </div>\n  )\n}\n\nexport default observer(FontFamily)\n","import React, {\n  ReactNode,\n  FunctionComponent,\n  PropsWithChildren,\n  ElementType,\n  CSSProperties,\n} from 'react'\nimport Typography from '@material-ui/core/Typography'\nimport Grid from '@material-ui/core/Grid'\n\ninterface GridInputProps {\n  before?: ReactNode\n  after?: ReactNode\n  component?: ElementType\n  childrenWidth?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8\n  style?: CSSProperties\n}\n\nconst GridInput: FunctionComponent<GridInputProps> = (\n  props: PropsWithChildren<GridInputProps>,\n): JSX.Element => {\n  const { before, children, component, after, childrenWidth, ...other } = props\n  return (\n    <Grid\n      component={component || 'label'}\n      container\n      spacing={2}\n      wrap='nowrap'\n      justifyContent='center'\n      alignItems='center'\n      {...other}\n    >\n      <Grid item xs={4}>\n        {typeof before === 'object' ? (\n          before\n        ) : (\n          <Typography noWrap align='right'>\n            {before}\n          </Typography>\n        )}\n      </Grid>\n      <Grid item xs={childrenWidth || 5}>\n        {children}\n      </Grid>\n      <Grid item xs>\n        {typeof after === 'object' ? (\n          after\n        ) : (\n          <Typography noWrap variant='caption'>\n            {after}\n          </Typography>\n        )}\n      </Grid>\n    </Grid>\n  )\n}\n\nexport default GridInput\n","import React, { FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport Input from '@material-ui/core/Input'\n\nimport GridInput from 'src/app/components/GridInput/GridInput'\n\nimport { useFont } from 'src/store/hooks'\n\nconst FontSize: FunctionComponent<unknown> = () => {\n  const { size, setSize } = useFont()\n\n  const handleInput = (\n    event: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>,\n  ): void => {\n    setSize(Number(event.target.value))\n  }\n\n  return (\n    <GridInput before='Font Size:' after='px'>\n      <Input\n        value={size}\n        fullWidth\n        type='number'\n        inputProps={{ min: 1 }}\n        onChange={handleInput}\n      />\n    </GridInput>\n  )\n}\n\nexport default observer(FontSize)\n","import React, { FunctionComponent, ChangeEvent } from 'react'\nimport { observer } from 'mobx-react'\nimport Slider from '@material-ui/core/Slider'\n\nimport GridInput from 'src/app/components/GridInput/GridInput'\n\nimport { useFont } from 'src/store/hooks'\n\nconst Sharp: FunctionComponent<unknown> = () => {\n  const { sharp, setSharp, mainFont } = useFont()\n\n  const handleInput = (\n    event: ChangeEvent<{}>,\n    value: number | number[],\n  ): void => {\n    setSharp(value as unknown as number)\n  }\n\n  return (\n    <GridInput\n      style={!mainFont ? { opacity: 0.5 } : undefined}\n      before='Sharp:'\n      after={`${sharp}%`}\n    >\n      <Slider value={sharp} onChange={handleInput} disabled={!mainFont} />\n    </GridInput>\n  )\n}\n\nexport default observer(Sharp)\n","import React, { FunctionComponent } from 'react'\nimport Typography from '@material-ui/core/Typography'\nimport Box from '@material-ui/core/Box'\n\nimport FontFamily from './FontFamily'\nimport FontSize from './FontSize'\nimport Sharp from './Sharp'\n\nconst Font: FunctionComponent<unknown> = () => {\n  return (\n    <>\n      <Box paddingX={2} marginY={4}>\n        <Typography>Font</Typography>\n      </Box>\n      <Box paddingX={2} marginY={4}>\n        <FontFamily />\n      </Box>\n      <Box paddingX={2} marginY={4}>\n        <FontSize />\n      </Box>\n      <Box paddingX={2} marginY={4}>\n        <Sharp />\n      </Box>\n    </>\n  )\n}\n\nexport default Font\n","import React, {\n  useState,\n  FunctionComponent,\n  useCallback,\n  useEffect,\n} from 'react'\n\nimport Box from '@material-ui/core/Box'\nimport TextField from '@material-ui/core/TextField'\nimport Typography from '@material-ui/core/Typography'\n\nimport { observer } from 'mobx-react'\n\nimport { useProject } from 'src/store/hooks'\n\nconst Glyphs: FunctionComponent<unknown> = () => {\n  const { text, setText } = useProject()\n  const [isIME, setIsIME] = useState(false)\n  const [inputText, setInputText] = useState(text)\n\n  const handleInput = (event: React.ChangeEvent<HTMLTextAreaElement>): void => {\n    const { value } = event.target\n    const str = Array.from(new Set(value.split(''))).join('')\n    if (isIME) {\n      setInputText(value)\n    } else {\n      setInputText(str)\n      if (str !== text) setText(str)\n    }\n  }\n\n  const handleCompositionStart = useCallback((): void => {\n    setInputText(text)\n    setIsIME(true)\n  }, [text])\n\n  const handleCompositionEnd = (): void => {\n    setIsIME(false)\n    const str = Array.from(new Set(inputText.split(''))).join('')\n    setInputText(str)\n    if (str !== text) setText(str)\n  }\n\n  useEffect(() => {\n    setInputText(text)\n  }, [text])\n\n  return (\n    <>\n      <Box paddingX={2} marginY={4}>\n        <Typography>Glyphs</Typography>\n      </Box>\n      <Box paddingX={2} marginY={4}>\n        <TextField\n          margin='none'\n          value={isIME ? inputText : text}\n          fullWidth\n          multiline\n          rows={4}\n          variant='outlined'\n          inputProps={{ spellCheck: false }}\n          onChange={handleInput}\n          onCompositionStart={handleCompositionStart}\n          onCompositionEnd={handleCompositionEnd}\n        />\n      </Box>\n    </>\n  )\n}\n\nexport default observer(Glyphs)\n","import React, { FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport Input from '@material-ui/core/Input'\n\nimport GridInput from 'src/app/components/GridInput'\n\nimport { useLayout } from 'src/store/hooks'\n\nconst Padding: FunctionComponent<unknown> = () => {\n  const { padding, setPadding } = useLayout()\n\n  const handleInput = (event: React.ChangeEvent<HTMLInputElement>): void => {\n    setPadding(Number(event.target.value))\n  }\n\n  return (\n    <GridInput before='Padding:' after='px'>\n      <Input\n        value={padding}\n        fullWidth\n        type='number'\n        inputProps={{ min: 0 }}\n        onChange={handleInput}\n      />\n    </GridInput>\n  )\n}\n\nexport default observer(Padding)\n","import React, { FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport Input from '@material-ui/core/Input'\n\nimport { useLayout } from 'src/store/hooks'\n\nimport GridInput from 'src/app/components/GridInput'\n\nconst Spacing: FunctionComponent<unknown> = () => {\n  const { spacing, setSpacing } = useLayout()\n\n  return (\n    <GridInput before='Spacing:' after='px'>\n      <Input\n        value={spacing}\n        fullWidth\n        type='number'\n        inputProps={{ min: 0 }}\n        onChange={(e) => setSpacing(Number(e.target.value))}\n      />\n    </GridInput>\n  )\n}\n\nexport default observer(Spacing)\n","import React, { FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport Checkbox from '@material-ui/core/Checkbox'\n\nimport { useLayout } from 'src/store/hooks'\n\nimport GridInput from 'src/app/components/GridInput'\n\nconst AutoPack: FunctionComponent<unknown> = () => {\n  const { auto, setAuto } = useLayout()\n\n  return (\n    <GridInput before='Auto Pack:'>\n      <Checkbox\n        checked={auto}\n        size='small'\n        color='default'\n        onChange={(e) => setAuto(e.target.checked)}\n      />\n    </GridInput>\n  )\n}\n\nexport default observer(AutoPack)\n","import React, { FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport Checkbox from '@material-ui/core/Checkbox'\n\nimport { useLayout } from 'src/store/hooks'\n\nimport GridInput from 'src/app/components/GridInput'\n\nconst FixedSize: FunctionComponent<unknown> = () => {\n  const { auto, fixedSize, setFixedSize } = useLayout()\n\n  return (\n    <GridInput before='Fixed Size:'>\n      <Checkbox\n        checked={fixedSize}\n        size='small'\n        color='default'\n        onChange={(e) => setFixedSize(e.target.checked)}\n        disabled={auto}\n      />\n    </GridInput>\n  )\n}\n\nexport default observer(FixedSize)\n","import React, { FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport Input from '@material-ui/core/Input'\n\nimport GridInput from 'src/app/components/GridInput'\n\nimport { useLayout } from 'src/store/hooks'\n\nconst PackWidth: FunctionComponent<unknown> = () => {\n  const { width, auto, fixedSize, setWidth } = useLayout()\n\n  const handleInput = (event: React.ChangeEvent<HTMLInputElement>): void => {\n    setWidth(Number(event.target.value))\n  }\n\n  return (\n    <GridInput before={fixedSize ? 'Width:' : 'Max Width:'} after='px'>\n      <Input\n        value={width}\n        fullWidth\n        type='number'\n        inputProps={{ min: 0 }}\n        onChange={handleInput}\n        disabled={auto}\n      />\n    </GridInput>\n  )\n}\n\nexport default observer(PackWidth)\n","import React, { FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport Input from '@material-ui/core/Input'\n\nimport GridInput from 'src/app/components/GridInput'\n\nimport { useLayout } from 'src/store/hooks'\n\nconst PackHeight: FunctionComponent<unknown> = () => {\n  const { height, auto, fixedSize, setHeight } = useLayout()\n\n  const handleInput = (event: React.ChangeEvent<HTMLInputElement>): void => {\n    setHeight(Number(event.target.value))\n  }\n\n  return (\n    <GridInput before={fixedSize ? 'Height:' : 'Max Height:'} after='px'>\n      <Input\n        value={height}\n        fullWidth\n        type='number'\n        inputProps={{ min: 0 }}\n        onChange={handleInput}\n        disabled={auto}\n      />\n    </GridInput>\n  )\n}\n\nexport default observer(PackHeight)\n","import React, { FunctionComponent } from 'react'\n\nimport Typography from '@material-ui/core/Typography'\nimport Box from '@material-ui/core/Box'\n\nimport Padding from './Padding'\nimport Spacing from './Spacing'\nimport AutoPack from './AutoPack'\nimport FixedSize from './FixedSize'\nimport PackWidth from './PackWidth'\nimport PackHeight from './PackHeight'\n\nconst PackConfig: FunctionComponent<unknown> = () => {\n  return (\n    <>\n      <Box paddingX={2} marginY={4}>\n        <Typography>Layout</Typography>\n      </Box>\n      <Box paddingX={2} marginY={4}>\n        <Padding />\n      </Box>\n      <Box paddingX={2} marginY={4}>\n        <Spacing />\n      </Box>\n      <Box paddingX={2} marginY={4}>\n        <AutoPack />\n      </Box>\n      <Box paddingX={2} marginY={4}>\n        <FixedSize />\n      </Box>\n      <Box paddingX={2} marginY={4}>\n        <PackWidth />\n      </Box>\n      <Box paddingX={2} marginY={4}>\n        <PackHeight />\n      </Box>\n    </>\n  )\n}\n\nexport default PackConfig\n","import React, { FunctionComponent } from 'react'\nimport Box from '@material-ui/core/Box'\nimport Input from '@material-ui/core/Input'\nimport GridInput from 'src/app/components/GridInput'\n\ninterface SetHandle {\n  (value: number): void\n}\n\ninterface FormAdjustMetricProps {\n  xAdvance: number\n  xOffset: number\n  yOffset: number\n  setXAdvance: SetHandle\n  setXOffset: SetHandle\n  setYOffset: SetHandle\n}\n\nconst FormAdjustMetric: FunctionComponent<FormAdjustMetricProps> = (\n  props: FormAdjustMetricProps,\n) => {\n  const { xAdvance, xOffset, yOffset, setXAdvance, setXOffset, setYOffset } =\n    props\n\n  const getHandle =\n    (handleSet: SetHandle) => (e: React.ChangeEvent<HTMLInputElement>) =>\n      handleSet(Number(e.target.value))\n\n  return (\n    <>\n      <Box paddingX={2} marginY={4}>\n        <GridInput before='xAdvance:' after='px'>\n          <Input\n            value={xAdvance}\n            fullWidth\n            type='number'\n            onChange={getHandle(setXAdvance)}\n          />\n        </GridInput>\n      </Box>\n      <Box paddingX={2} marginY={4}>\n        <GridInput before='xOffset:' after='px'>\n          <Input\n            value={xOffset}\n            fullWidth\n            type='number'\n            onChange={getHandle(setXOffset)}\n          />\n        </GridInput>\n      </Box>\n      <Box paddingX={2} marginY={4}>\n        <GridInput before='yOffset:' after='px'>\n          <Input\n            value={yOffset}\n            fullWidth\n            type='number'\n            onChange={getHandle(setYOffset)}\n          />\n        </GridInput>\n      </Box>\n    </>\n  )\n}\n\nexport default FormAdjustMetric\n","import React, { FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport Box from '@material-ui/core/Box'\nimport Typography from '@material-ui/core/Typography'\n\nimport { useProject } from 'src/store/hooks'\n\nimport FormAdjustMetric from 'src/app/layout/common/FormAdjustMetric'\n\nconst GlobalMetric: FunctionComponent<unknown> = () => {\n  const { globalAdjustMetric } = useProject()\n  const { xAdvance, xOffset, yOffset, setXAdvance, setXOffset, setYOffset } =\n    globalAdjustMetric\n\n  return (\n    <>\n      <Box paddingX={2} marginY={4}>\n        <Typography>Global Metric Adjustment</Typography>\n      </Box>\n      <FormAdjustMetric\n        xAdvance={xAdvance}\n        xOffset={xOffset}\n        yOffset={yOffset}\n        setXAdvance={setXAdvance}\n        setXOffset={setXOffset}\n        setYOffset={setYOffset}\n      />\n    </>\n  )\n}\n\nexport default observer(GlobalMetric)\n","import React, { FunctionComponent } from 'react'\nimport { makeStyles, createStyles } from '@material-ui/core/styles'\nimport Box from '@material-ui/core/Box'\nimport Divider from '@material-ui/core/Divider'\nimport Typography from '@material-ui/core/Typography'\n\nimport Font from './modules/Font'\nimport Glyphs from './modules/Glyphs'\nimport PackConfig from './modules/PackConfig'\nimport GlobalMetric from './modules/GlobalMetric'\n\nconst useStyles = makeStyles(() =>\n  createStyles({\n    root: {\n      overflow: 'hidden',\n      width: '256px',\n    },\n  }),\n)\n\nconst LeftBar: FunctionComponent<unknown> = () => {\n  const classes = useStyles()\n  return (\n    <Box\n      bgcolor='background.sidebar'\n      display='flex'\n      flexDirection='column'\n      overflow='hidden'\n      className={classes.root}\n    >\n      <Box bgcolor='background.sidebar' boxShadow={2} padding={2}>\n        <Typography variant='subtitle2'>Font Config</Typography>\n      </Box>\n      <Box flex={1} height={0} overflow='hidden auto'>\n        <Glyphs />\n        <Divider />\n        <Font />\n        <Divider />\n        <PackConfig />\n        <Divider />\n        <GlobalMetric />\n      </Box>\n    </Box>\n  )\n}\n\nexport default LeftBar\n","import React, { useEffect, FunctionComponent, useCallback } from 'react'\nimport hotkeys from 'hotkeys-js'\nimport { observer } from 'mobx-react'\nimport Button from '@material-ui/core/Button'\n\nimport { useWorkspace } from 'src/store/hooks'\n\ninterface ButtonNewProps {\n  className?: string\n}\n\nconst ButtonNew: FunctionComponent<ButtonNewProps> = (\n  props: ButtonNewProps,\n) => {\n  const { className } = props\n\n  const worckSpace = useWorkspace()\n  const { addProject } = worckSpace\n\n  const handleNewProject = useCallback(\n    (e: { preventDefault(): void }) => {\n      e.preventDefault()\n      addProject()\n      return false\n    },\n    [addProject],\n  )\n\n  useEffect(() => {\n    hotkeys.unbind('alt+n,control+n')\n    hotkeys('alt+n,control+n', handleNewProject)\n    return () => {\n      hotkeys.unbind('alt+n,control+n')\n    }\n  }, [handleNewProject])\n\n  return (\n    <Button\n      className={className}\n      title='New Project (ALT + N)'\n      onClick={handleNewProject}\n    >\n      New\n    </Button>\n  )\n}\n\nexport default observer(ButtonNew)\n","function getVersionNumber(version: string | string[] | number[]): number {\n  if (typeof version === 'string') {\n    version = version.split('.')\n  }\n\n  if (!Array.isArray(version)) return 0\n\n  version = [...version] as number[]\n\n  return version\n    .reverse()\n    .reduce<number>(\n      (previousValue: number, currentValue: number, currentIndex: number) => {\n        return (\n          previousValue + Number(currentValue) * Math.pow(1000, currentIndex)\n        )\n      },\n      0,\n    )\n}\n\nexport default getVersionNumber\n","export const PREFIX_STR = 'SnowBambooBMF'\nconst prefix = (): Uint8Array =>\n  new Uint8Array([...PREFIX_STR.split('').map((s) => s.charCodeAt(0)), 1, 1, 0])\n\nexport default prefix\n","import getVersionNumber from 'src/utils/getVersionNumber'\nimport prefix from './prefix'\n\nexport default function decode(buffer: unknown): number {\n  if (!(buffer instanceof ArrayBuffer) || buffer.byteLength < 17) return 0\n  const perfixBuffer = prefix()\n  const perfixName = perfixBuffer.slice(0, perfixBuffer.byteLength - 3)\n  const u8 = new Uint8Array(buffer)\n  const filePrefix = u8.slice(0, perfixBuffer.byteLength)\n  const versionBuffer = filePrefix.slice(filePrefix.byteLength - 3)\n  let isSbf = true\n\n  perfixName.forEach((e, i) => {\n    if (filePrefix[i] !== e) isSbf = false\n  })\n\n  if (!isSbf) return 0\n\n  return getVersionNumber(Array.from(versionBuffer))\n}\n","import { CheckFunction } from '../type'\nimport getVersion from './getVersion'\n\nconst check: CheckFunction = (buffer) => getVersion(buffer) > 0\n\nexport default check\n","/* eslint-disable */\nimport * as $protobuf from 'protobufjs/minimal'\n\n// Common aliases\nconst $Reader = $protobuf.Reader,\n  $Writer = $protobuf.Writer,\n  $util = $protobuf.util\n\n// Exported root namespace\nconst $root = {}\n\nexport const Metric = ($root.Metric = (() => {\n  /**\n   * Properties of a Metric.\n   * @exports IMetric\n   * @interface IMetric\n   * @property {number|null} [xAdvance] Metric xAdvance\n   * @property {number|null} [xOffset] Metric xOffset\n   * @property {number|null} [yOffset] Metric yOffset\n   */\n\n  /**\n   * Constructs a new Metric.\n   * @exports Metric\n   * @classdesc Represents a Metric.\n   * @implements IMetric\n   * @constructor\n   * @param {IMetric=} [properties] Properties to set\n   */\n  function Metric(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Metric xAdvance.\n   * @member {number} xAdvance\n   * @memberof Metric\n   * @instance\n   */\n  Metric.prototype.xAdvance = 0\n\n  /**\n   * Metric xOffset.\n   * @member {number} xOffset\n   * @memberof Metric\n   * @instance\n   */\n  Metric.prototype.xOffset = 0\n\n  /**\n   * Metric yOffset.\n   * @member {number} yOffset\n   * @memberof Metric\n   * @instance\n   */\n  Metric.prototype.yOffset = 0\n\n  /**\n   * Creates a new Metric instance using the specified properties.\n   * @function create\n   * @memberof Metric\n   * @static\n   * @param {IMetric=} [properties] Properties to set\n   * @returns {Metric} Metric instance\n   */\n  Metric.create = function create(properties) {\n    return new Metric(properties)\n  }\n\n  /**\n   * Encodes the specified Metric message. Does not implicitly {@link Metric.verify|verify} messages.\n   * @function encode\n   * @memberof Metric\n   * @static\n   * @param {IMetric} message Metric message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Metric.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (\n      message.xAdvance != null &&\n      Object.hasOwnProperty.call(message, 'xAdvance')\n    )\n      writer.uint32(/* id 1, wireType 0 =*/ 8).sint32(message.xAdvance)\n    if (\n      message.xOffset != null &&\n      Object.hasOwnProperty.call(message, 'xOffset')\n    )\n      writer.uint32(/* id 2, wireType 0 =*/ 16).sint32(message.xOffset)\n    if (\n      message.yOffset != null &&\n      Object.hasOwnProperty.call(message, 'yOffset')\n    )\n      writer.uint32(/* id 3, wireType 0 =*/ 24).sint32(message.yOffset)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Metric message, length delimited. Does not implicitly {@link Metric.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Metric\n   * @static\n   * @param {IMetric} message Metric message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Metric.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Metric message from the specified reader or buffer.\n   * @function decode\n   * @memberof Metric\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Metric} Metric\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Metric.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Metric()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.xAdvance = reader.sint32()\n          break\n        case 2:\n          message.xOffset = reader.sint32()\n          break\n        case 3:\n          message.yOffset = reader.sint32()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Metric message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Metric\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Metric} Metric\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Metric.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Metric message.\n   * @function verify\n   * @memberof Metric\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Metric.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.xAdvance != null && message.hasOwnProperty('xAdvance'))\n      if (!$util.isInteger(message.xAdvance))\n        return 'xAdvance: integer expected'\n    if (message.xOffset != null && message.hasOwnProperty('xOffset'))\n      if (!$util.isInteger(message.xOffset)) return 'xOffset: integer expected'\n    if (message.yOffset != null && message.hasOwnProperty('yOffset'))\n      if (!$util.isInteger(message.yOffset)) return 'yOffset: integer expected'\n    return null\n  }\n\n  /**\n   * Creates a Metric message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Metric\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Metric} Metric\n   */\n  Metric.fromObject = function fromObject(object) {\n    if (object instanceof $root.Metric) return object\n    let message = new $root.Metric()\n    if (object.xAdvance != null) message.xAdvance = object.xAdvance | 0\n    if (object.xOffset != null) message.xOffset = object.xOffset | 0\n    if (object.yOffset != null) message.yOffset = object.yOffset | 0\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Metric message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Metric\n   * @static\n   * @param {Metric} message Metric\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Metric.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.xAdvance = 0\n      object.xOffset = 0\n      object.yOffset = 0\n    }\n    if (message.xAdvance != null && message.hasOwnProperty('xAdvance'))\n      object.xAdvance = message.xAdvance\n    if (message.xOffset != null && message.hasOwnProperty('xOffset'))\n      object.xOffset = message.xOffset\n    if (message.yOffset != null && message.hasOwnProperty('yOffset'))\n      object.yOffset = message.yOffset\n    return object\n  }\n\n  /**\n   * Converts this Metric to JSON.\n   * @function toJSON\n   * @memberof Metric\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Metric.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Metric\n})())\n\nexport const GradientColor = ($root.GradientColor = (() => {\n  /**\n   * Properties of a GradientColor.\n   * @exports IGradientColor\n   * @interface IGradientColor\n   * @property {number|null} [id] GradientColor id\n   * @property {number|null} [offset] GradientColor offset\n   * @property {string|null} [color] GradientColor color\n   */\n\n  /**\n   * Constructs a new GradientColor.\n   * @exports GradientColor\n   * @classdesc Represents a GradientColor.\n   * @implements IGradientColor\n   * @constructor\n   * @param {IGradientColor=} [properties] Properties to set\n   */\n  function GradientColor(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * GradientColor id.\n   * @member {number} id\n   * @memberof GradientColor\n   * @instance\n   */\n  GradientColor.prototype.id = 0\n\n  /**\n   * GradientColor offset.\n   * @member {number} offset\n   * @memberof GradientColor\n   * @instance\n   */\n  GradientColor.prototype.offset = 0\n\n  /**\n   * GradientColor color.\n   * @member {string} color\n   * @memberof GradientColor\n   * @instance\n   */\n  GradientColor.prototype.color = ''\n\n  /**\n   * Creates a new GradientColor instance using the specified properties.\n   * @function create\n   * @memberof GradientColor\n   * @static\n   * @param {IGradientColor=} [properties] Properties to set\n   * @returns {GradientColor} GradientColor instance\n   */\n  GradientColor.create = function create(properties) {\n    return new GradientColor(properties)\n  }\n\n  /**\n   * Encodes the specified GradientColor message. Does not implicitly {@link GradientColor.verify|verify} messages.\n   * @function encode\n   * @memberof GradientColor\n   * @static\n   * @param {IGradientColor} message GradientColor message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GradientColor.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.id != null && Object.hasOwnProperty.call(message, 'id'))\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.id)\n    if (message.offset != null && Object.hasOwnProperty.call(message, 'offset'))\n      writer.uint32(/* id 2, wireType 0 =*/ 16).sint32(message.offset)\n    if (message.color != null && Object.hasOwnProperty.call(message, 'color'))\n      writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.color)\n    return writer\n  }\n\n  /**\n   * Encodes the specified GradientColor message, length delimited. Does not implicitly {@link GradientColor.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof GradientColor\n   * @static\n   * @param {IGradientColor} message GradientColor message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GradientColor.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a GradientColor message from the specified reader or buffer.\n   * @function decode\n   * @memberof GradientColor\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {GradientColor} GradientColor\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GradientColor.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.GradientColor()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.int32()\n          break\n        case 2:\n          message.offset = reader.sint32()\n          break\n        case 3:\n          message.color = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a GradientColor message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof GradientColor\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {GradientColor} GradientColor\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GradientColor.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a GradientColor message.\n   * @function verify\n   * @memberof GradientColor\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  GradientColor.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.id != null && message.hasOwnProperty('id'))\n      if (!$util.isInteger(message.id)) return 'id: integer expected'\n    if (message.offset != null && message.hasOwnProperty('offset'))\n      if (!$util.isInteger(message.offset)) return 'offset: integer expected'\n    if (message.color != null && message.hasOwnProperty('color'))\n      if (!$util.isString(message.color)) return 'color: string expected'\n    return null\n  }\n\n  /**\n   * Creates a GradientColor message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof GradientColor\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {GradientColor} GradientColor\n   */\n  GradientColor.fromObject = function fromObject(object) {\n    if (object instanceof $root.GradientColor) return object\n    let message = new $root.GradientColor()\n    if (object.id != null) message.id = object.id | 0\n    if (object.offset != null) message.offset = object.offset | 0\n    if (object.color != null) message.color = String(object.color)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a GradientColor message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof GradientColor\n   * @static\n   * @param {GradientColor} message GradientColor\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  GradientColor.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.id = 0\n      object.offset = 0\n      object.color = ''\n    }\n    if (message.id != null && message.hasOwnProperty('id'))\n      object.id = message.id\n    if (message.offset != null && message.hasOwnProperty('offset'))\n      object.offset = message.offset\n    if (message.color != null && message.hasOwnProperty('color'))\n      object.color = message.color\n    return object\n  }\n\n  /**\n   * Converts this GradientColor to JSON.\n   * @function toJSON\n   * @memberof GradientColor\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  GradientColor.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return GradientColor\n})())\n\nexport const Gradient = ($root.Gradient = (() => {\n  /**\n   * Properties of a Gradient.\n   * @exports IGradient\n   * @interface IGradient\n   * @property {number|null} [type] Gradient type\n   * @property {number|null} [angle] Gradient angle\n   * @property {Array.<IGradientColor>|null} [palette] Gradient palette\n   */\n\n  /**\n   * Constructs a new Gradient.\n   * @exports Gradient\n   * @classdesc Represents a Gradient.\n   * @implements IGradient\n   * @constructor\n   * @param {IGradient=} [properties] Properties to set\n   */\n  function Gradient(properties) {\n    this.palette = []\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Gradient type.\n   * @member {number} type\n   * @memberof Gradient\n   * @instance\n   */\n  Gradient.prototype.type = 0\n\n  /**\n   * Gradient angle.\n   * @member {number} angle\n   * @memberof Gradient\n   * @instance\n   */\n  Gradient.prototype.angle = 0\n\n  /**\n   * Gradient palette.\n   * @member {Array.<IGradientColor>} palette\n   * @memberof Gradient\n   * @instance\n   */\n  Gradient.prototype.palette = $util.emptyArray\n\n  /**\n   * Creates a new Gradient instance using the specified properties.\n   * @function create\n   * @memberof Gradient\n   * @static\n   * @param {IGradient=} [properties] Properties to set\n   * @returns {Gradient} Gradient instance\n   */\n  Gradient.create = function create(properties) {\n    return new Gradient(properties)\n  }\n\n  /**\n   * Encodes the specified Gradient message. Does not implicitly {@link Gradient.verify|verify} messages.\n   * @function encode\n   * @memberof Gradient\n   * @static\n   * @param {IGradient} message Gradient message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Gradient.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.type != null && Object.hasOwnProperty.call(message, 'type'))\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.type)\n    if (message.angle != null && Object.hasOwnProperty.call(message, 'angle'))\n      writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.angle)\n    if (message.palette != null && message.palette.length)\n      for (let i = 0; i < message.palette.length; ++i)\n        $root.GradientColor.encode(\n          message.palette[i],\n          writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),\n        ).ldelim()\n    return writer\n  }\n\n  /**\n   * Encodes the specified Gradient message, length delimited. Does not implicitly {@link Gradient.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Gradient\n   * @static\n   * @param {IGradient} message Gradient message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Gradient.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Gradient message from the specified reader or buffer.\n   * @function decode\n   * @memberof Gradient\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Gradient} Gradient\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Gradient.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Gradient()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32()\n          break\n        case 2:\n          message.angle = reader.float()\n          break\n        case 3:\n          if (!(message.palette && message.palette.length)) message.palette = []\n          message.palette.push(\n            $root.GradientColor.decode(reader, reader.uint32()),\n          )\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Gradient message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Gradient\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Gradient} Gradient\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Gradient.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Gradient message.\n   * @function verify\n   * @memberof Gradient\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Gradient.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.type != null && message.hasOwnProperty('type'))\n      if (!$util.isInteger(message.type)) return 'type: integer expected'\n    if (message.angle != null && message.hasOwnProperty('angle'))\n      if (typeof message.angle !== 'number') return 'angle: number expected'\n    if (message.palette != null && message.hasOwnProperty('palette')) {\n      if (!Array.isArray(message.palette)) return 'palette: array expected'\n      for (let i = 0; i < message.palette.length; ++i) {\n        let error = $root.GradientColor.verify(message.palette[i])\n        if (error) return 'palette.' + error\n      }\n    }\n    return null\n  }\n\n  /**\n   * Creates a Gradient message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Gradient\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Gradient} Gradient\n   */\n  Gradient.fromObject = function fromObject(object) {\n    if (object instanceof $root.Gradient) return object\n    let message = new $root.Gradient()\n    if (object.type != null) message.type = object.type | 0\n    if (object.angle != null) message.angle = Number(object.angle)\n    if (object.palette) {\n      if (!Array.isArray(object.palette))\n        throw TypeError('.Gradient.palette: array expected')\n      message.palette = []\n      for (let i = 0; i < object.palette.length; ++i) {\n        if (typeof object.palette[i] !== 'object')\n          throw TypeError('.Gradient.palette: object expected')\n        message.palette[i] = $root.GradientColor.fromObject(object.palette[i])\n      }\n    }\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Gradient message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Gradient\n   * @static\n   * @param {Gradient} message Gradient\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Gradient.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.arrays || options.defaults) object.palette = []\n    if (options.defaults) {\n      object.type = 0\n      object.angle = 0\n    }\n    if (message.type != null && message.hasOwnProperty('type'))\n      object.type = message.type\n    if (message.angle != null && message.hasOwnProperty('angle'))\n      object.angle =\n        options.json && !isFinite(message.angle)\n          ? String(message.angle)\n          : message.angle\n    if (message.palette && message.palette.length) {\n      object.palette = []\n      for (let j = 0; j < message.palette.length; ++j)\n        object.palette[j] = $root.GradientColor.toObject(\n          message.palette[j],\n          options,\n        )\n    }\n    return object\n  }\n\n  /**\n   * Converts this Gradient to JSON.\n   * @function toJSON\n   * @memberof Gradient\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Gradient.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Gradient\n})())\n\nexport const PatternTexture = ($root.PatternTexture = (() => {\n  /**\n   * Properties of a PatternTexture.\n   * @exports IPatternTexture\n   * @interface IPatternTexture\n   * @property {Uint8Array|null} [buffer] PatternTexture buffer\n   * @property {number|null} [scale] PatternTexture scale\n   * @property {string|null} [repetition] PatternTexture repetition\n   */\n\n  /**\n   * Constructs a new PatternTexture.\n   * @exports PatternTexture\n   * @classdesc Represents a PatternTexture.\n   * @implements IPatternTexture\n   * @constructor\n   * @param {IPatternTexture=} [properties] Properties to set\n   */\n  function PatternTexture(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * PatternTexture buffer.\n   * @member {Uint8Array} buffer\n   * @memberof PatternTexture\n   * @instance\n   */\n  PatternTexture.prototype.buffer = $util.newBuffer([])\n\n  /**\n   * PatternTexture scale.\n   * @member {number} scale\n   * @memberof PatternTexture\n   * @instance\n   */\n  PatternTexture.prototype.scale = 0\n\n  /**\n   * PatternTexture repetition.\n   * @member {string} repetition\n   * @memberof PatternTexture\n   * @instance\n   */\n  PatternTexture.prototype.repetition = ''\n\n  /**\n   * Creates a new PatternTexture instance using the specified properties.\n   * @function create\n   * @memberof PatternTexture\n   * @static\n   * @param {IPatternTexture=} [properties] Properties to set\n   * @returns {PatternTexture} PatternTexture instance\n   */\n  PatternTexture.create = function create(properties) {\n    return new PatternTexture(properties)\n  }\n\n  /**\n   * Encodes the specified PatternTexture message. Does not implicitly {@link PatternTexture.verify|verify} messages.\n   * @function encode\n   * @memberof PatternTexture\n   * @static\n   * @param {IPatternTexture} message PatternTexture message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  PatternTexture.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.buffer != null && Object.hasOwnProperty.call(message, 'buffer'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.buffer)\n    if (message.scale != null && Object.hasOwnProperty.call(message, 'scale'))\n      writer.uint32(/* id 2, wireType 1 =*/ 17).double(message.scale)\n    if (\n      message.repetition != null &&\n      Object.hasOwnProperty.call(message, 'repetition')\n    )\n      writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.repetition)\n    return writer\n  }\n\n  /**\n   * Encodes the specified PatternTexture message, length delimited. Does not implicitly {@link PatternTexture.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof PatternTexture\n   * @static\n   * @param {IPatternTexture} message PatternTexture message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  PatternTexture.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a PatternTexture message from the specified reader or buffer.\n   * @function decode\n   * @memberof PatternTexture\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {PatternTexture} PatternTexture\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  PatternTexture.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.PatternTexture()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.buffer = reader.bytes()\n          break\n        case 2:\n          message.scale = reader.double()\n          break\n        case 3:\n          message.repetition = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a PatternTexture message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof PatternTexture\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {PatternTexture} PatternTexture\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  PatternTexture.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a PatternTexture message.\n   * @function verify\n   * @memberof PatternTexture\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  PatternTexture.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.buffer != null && message.hasOwnProperty('buffer'))\n      if (\n        !(\n          (message.buffer && typeof message.buffer.length === 'number') ||\n          $util.isString(message.buffer)\n        )\n      )\n        return 'buffer: buffer expected'\n    if (message.scale != null && message.hasOwnProperty('scale'))\n      if (typeof message.scale !== 'number') return 'scale: number expected'\n    if (message.repetition != null && message.hasOwnProperty('repetition'))\n      if (!$util.isString(message.repetition))\n        return 'repetition: string expected'\n    return null\n  }\n\n  /**\n   * Creates a PatternTexture message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof PatternTexture\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {PatternTexture} PatternTexture\n   */\n  PatternTexture.fromObject = function fromObject(object) {\n    if (object instanceof $root.PatternTexture) return object\n    let message = new $root.PatternTexture()\n    if (object.buffer != null)\n      if (typeof object.buffer === 'string')\n        $util.base64.decode(\n          object.buffer,\n          (message.buffer = $util.newBuffer(\n            $util.base64.length(object.buffer),\n          )),\n          0,\n        )\n      else if (object.buffer.length) message.buffer = object.buffer\n    if (object.scale != null) message.scale = Number(object.scale)\n    if (object.repetition != null)\n      message.repetition = String(object.repetition)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a PatternTexture message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof PatternTexture\n   * @static\n   * @param {PatternTexture} message PatternTexture\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  PatternTexture.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      if (options.bytes === String) object.buffer = ''\n      else {\n        object.buffer = []\n        if (options.bytes !== Array)\n          object.buffer = $util.newBuffer(object.buffer)\n      }\n      object.scale = 0\n      object.repetition = ''\n    }\n    if (message.buffer != null && message.hasOwnProperty('buffer'))\n      object.buffer =\n        options.bytes === String\n          ? $util.base64.encode(message.buffer, 0, message.buffer.length)\n          : options.bytes === Array\n          ? Array.prototype.slice.call(message.buffer)\n          : message.buffer\n    if (message.scale != null && message.hasOwnProperty('scale'))\n      object.scale =\n        options.json && !isFinite(message.scale)\n          ? String(message.scale)\n          : message.scale\n    if (message.repetition != null && message.hasOwnProperty('repetition'))\n      object.repetition = message.repetition\n    return object\n  }\n\n  /**\n   * Converts this PatternTexture to JSON.\n   * @function toJSON\n   * @memberof PatternTexture\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  PatternTexture.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return PatternTexture\n})())\n\nexport const Fill = ($root.Fill = (() => {\n  /**\n   * Properties of a Fill.\n   * @exports IFill\n   * @interface IFill\n   * @property {number|null} [type] Fill type\n   * @property {string|null} [color] Fill color\n   * @property {IGradient|null} [gradient] Fill gradient\n   * @property {IPatternTexture|null} [patternTexture] Fill patternTexture\n   * @property {number|null} [width] Fill width\n   * @property {string|null} [lineCap] Fill lineCap\n   * @property {string|null} [lineJoin] Fill lineJoin\n   */\n\n  /**\n   * Constructs a new Fill.\n   * @exports Fill\n   * @classdesc Represents a Fill.\n   * @implements IFill\n   * @constructor\n   * @param {IFill=} [properties] Properties to set\n   */\n  function Fill(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Fill type.\n   * @member {number} type\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.type = 0\n\n  /**\n   * Fill color.\n   * @member {string} color\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.color = ''\n\n  /**\n   * Fill gradient.\n   * @member {IGradient|null|undefined} gradient\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.gradient = null\n\n  /**\n   * Fill patternTexture.\n   * @member {IPatternTexture|null|undefined} patternTexture\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.patternTexture = null\n\n  /**\n   * Fill width.\n   * @member {number} width\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.width = 0\n\n  /**\n   * Fill lineCap.\n   * @member {string} lineCap\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.lineCap = ''\n\n  /**\n   * Fill lineJoin.\n   * @member {string} lineJoin\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.lineJoin = ''\n\n  /**\n   * Creates a new Fill instance using the specified properties.\n   * @function create\n   * @memberof Fill\n   * @static\n   * @param {IFill=} [properties] Properties to set\n   * @returns {Fill} Fill instance\n   */\n  Fill.create = function create(properties) {\n    return new Fill(properties)\n  }\n\n  /**\n   * Encodes the specified Fill message. Does not implicitly {@link Fill.verify|verify} messages.\n   * @function encode\n   * @memberof Fill\n   * @static\n   * @param {IFill} message Fill message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Fill.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.type != null && Object.hasOwnProperty.call(message, 'type'))\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.type)\n    if (message.color != null && Object.hasOwnProperty.call(message, 'color'))\n      writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.color)\n    if (\n      message.gradient != null &&\n      Object.hasOwnProperty.call(message, 'gradient')\n    )\n      $root.Gradient.encode(\n        message.gradient,\n        writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),\n      ).ldelim()\n    if (\n      message.patternTexture != null &&\n      Object.hasOwnProperty.call(message, 'patternTexture')\n    )\n      $root.PatternTexture.encode(\n        message.patternTexture,\n        writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),\n      ).ldelim()\n    if (message.width != null && Object.hasOwnProperty.call(message, 'width'))\n      writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.width)\n    if (\n      message.lineCap != null &&\n      Object.hasOwnProperty.call(message, 'lineCap')\n    )\n      writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.lineCap)\n    if (\n      message.lineJoin != null &&\n      Object.hasOwnProperty.call(message, 'lineJoin')\n    )\n      writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.lineJoin)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Fill message, length delimited. Does not implicitly {@link Fill.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Fill\n   * @static\n   * @param {IFill} message Fill message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Fill.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Fill message from the specified reader or buffer.\n   * @function decode\n   * @memberof Fill\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Fill} Fill\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Fill.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Fill()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32()\n          break\n        case 2:\n          message.color = reader.string()\n          break\n        case 3:\n          message.gradient = $root.Gradient.decode(reader, reader.uint32())\n          break\n        case 4:\n          message.patternTexture = $root.PatternTexture.decode(\n            reader,\n            reader.uint32(),\n          )\n          break\n        case 5:\n          message.width = reader.int32()\n          break\n        case 6:\n          message.lineCap = reader.string()\n          break\n        case 7:\n          message.lineJoin = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Fill message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Fill\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Fill} Fill\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Fill.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Fill message.\n   * @function verify\n   * @memberof Fill\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Fill.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.type != null && message.hasOwnProperty('type'))\n      if (!$util.isInteger(message.type)) return 'type: integer expected'\n    if (message.color != null && message.hasOwnProperty('color'))\n      if (!$util.isString(message.color)) return 'color: string expected'\n    if (message.gradient != null && message.hasOwnProperty('gradient')) {\n      let error = $root.Gradient.verify(message.gradient)\n      if (error) return 'gradient.' + error\n    }\n    if (\n      message.patternTexture != null &&\n      message.hasOwnProperty('patternTexture')\n    ) {\n      let error = $root.PatternTexture.verify(message.patternTexture)\n      if (error) return 'patternTexture.' + error\n    }\n    if (message.width != null && message.hasOwnProperty('width'))\n      if (!$util.isInteger(message.width)) return 'width: integer expected'\n    if (message.lineCap != null && message.hasOwnProperty('lineCap'))\n      if (!$util.isString(message.lineCap)) return 'lineCap: string expected'\n    if (message.lineJoin != null && message.hasOwnProperty('lineJoin'))\n      if (!$util.isString(message.lineJoin)) return 'lineJoin: string expected'\n    return null\n  }\n\n  /**\n   * Creates a Fill message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Fill\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Fill} Fill\n   */\n  Fill.fromObject = function fromObject(object) {\n    if (object instanceof $root.Fill) return object\n    let message = new $root.Fill()\n    if (object.type != null) message.type = object.type | 0\n    if (object.color != null) message.color = String(object.color)\n    if (object.gradient != null) {\n      if (typeof object.gradient !== 'object')\n        throw TypeError('.Fill.gradient: object expected')\n      message.gradient = $root.Gradient.fromObject(object.gradient)\n    }\n    if (object.patternTexture != null) {\n      if (typeof object.patternTexture !== 'object')\n        throw TypeError('.Fill.patternTexture: object expected')\n      message.patternTexture = $root.PatternTexture.fromObject(\n        object.patternTexture,\n      )\n    }\n    if (object.width != null) message.width = object.width | 0\n    if (object.lineCap != null) message.lineCap = String(object.lineCap)\n    if (object.lineJoin != null) message.lineJoin = String(object.lineJoin)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Fill message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Fill\n   * @static\n   * @param {Fill} message Fill\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Fill.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.type = 0\n      object.color = ''\n      object.gradient = null\n      object.patternTexture = null\n      object.width = 0\n      object.lineCap = ''\n      object.lineJoin = ''\n    }\n    if (message.type != null && message.hasOwnProperty('type'))\n      object.type = message.type\n    if (message.color != null && message.hasOwnProperty('color'))\n      object.color = message.color\n    if (message.gradient != null && message.hasOwnProperty('gradient'))\n      object.gradient = $root.Gradient.toObject(message.gradient, options)\n    if (\n      message.patternTexture != null &&\n      message.hasOwnProperty('patternTexture')\n    )\n      object.patternTexture = $root.PatternTexture.toObject(\n        message.patternTexture,\n        options,\n      )\n    if (message.width != null && message.hasOwnProperty('width'))\n      object.width = message.width\n    if (message.lineCap != null && message.hasOwnProperty('lineCap'))\n      object.lineCap = message.lineCap\n    if (message.lineJoin != null && message.hasOwnProperty('lineJoin'))\n      object.lineJoin = message.lineJoin\n    return object\n  }\n\n  /**\n   * Converts this Fill to JSON.\n   * @function toJSON\n   * @memberof Fill\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Fill.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Fill\n})())\n\nexport const Font = ($root.Font = (() => {\n  /**\n   * Properties of a Font.\n   * @exports IFont\n   * @interface IFont\n   * @property {Uint8Array|null} [font] Font font\n   * @property {string|null} [family] Font family\n   * @property {number|null} [size] Font size\n   * @property {number|null} [lineHeight] Font lineHeight\n   */\n\n  /**\n   * Constructs a new Font.\n   * @exports Font\n   * @classdesc Represents a Font.\n   * @implements IFont\n   * @constructor\n   * @param {IFont=} [properties] Properties to set\n   */\n  function Font(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Font font.\n   * @member {Uint8Array} font\n   * @memberof Font\n   * @instance\n   */\n  Font.prototype.font = $util.newBuffer([])\n\n  /**\n   * Font family.\n   * @member {string} family\n   * @memberof Font\n   * @instance\n   */\n  Font.prototype.family = ''\n\n  /**\n   * Font size.\n   * @member {number} size\n   * @memberof Font\n   * @instance\n   */\n  Font.prototype.size = 0\n\n  /**\n   * Font lineHeight.\n   * @member {number} lineHeight\n   * @memberof Font\n   * @instance\n   */\n  Font.prototype.lineHeight = 0\n\n  /**\n   * Creates a new Font instance using the specified properties.\n   * @function create\n   * @memberof Font\n   * @static\n   * @param {IFont=} [properties] Properties to set\n   * @returns {Font} Font instance\n   */\n  Font.create = function create(properties) {\n    return new Font(properties)\n  }\n\n  /**\n   * Encodes the specified Font message. Does not implicitly {@link Font.verify|verify} messages.\n   * @function encode\n   * @memberof Font\n   * @static\n   * @param {IFont} message Font message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Font.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.font != null && Object.hasOwnProperty.call(message, 'font'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.font)\n    if (message.family != null && Object.hasOwnProperty.call(message, 'family'))\n      writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.family)\n    if (message.size != null && Object.hasOwnProperty.call(message, 'size'))\n      writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.size)\n    if (\n      message.lineHeight != null &&\n      Object.hasOwnProperty.call(message, 'lineHeight')\n    )\n      writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.lineHeight)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Font message, length delimited. Does not implicitly {@link Font.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Font\n   * @static\n   * @param {IFont} message Font message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Font.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Font message from the specified reader or buffer.\n   * @function decode\n   * @memberof Font\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Font} Font\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Font.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Font()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.font = reader.bytes()\n          break\n        case 2:\n          message.family = reader.string()\n          break\n        case 3:\n          message.size = reader.int32()\n          break\n        case 4:\n          message.lineHeight = reader.int32()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Font message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Font\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Font} Font\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Font.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Font message.\n   * @function verify\n   * @memberof Font\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Font.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.font != null && message.hasOwnProperty('font'))\n      if (\n        !(\n          (message.font && typeof message.font.length === 'number') ||\n          $util.isString(message.font)\n        )\n      )\n        return 'font: buffer expected'\n    if (message.family != null && message.hasOwnProperty('family'))\n      if (!$util.isString(message.family)) return 'family: string expected'\n    if (message.size != null && message.hasOwnProperty('size'))\n      if (!$util.isInteger(message.size)) return 'size: integer expected'\n    if (message.lineHeight != null && message.hasOwnProperty('lineHeight'))\n      if (!$util.isInteger(message.lineHeight))\n        return 'lineHeight: integer expected'\n    return null\n  }\n\n  /**\n   * Creates a Font message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Font\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Font} Font\n   */\n  Font.fromObject = function fromObject(object) {\n    if (object instanceof $root.Font) return object\n    let message = new $root.Font()\n    if (object.font != null)\n      if (typeof object.font === 'string')\n        $util.base64.decode(\n          object.font,\n          (message.font = $util.newBuffer($util.base64.length(object.font))),\n          0,\n        )\n      else if (object.font.length) message.font = object.font\n    if (object.family != null) message.family = String(object.family)\n    if (object.size != null) message.size = object.size | 0\n    if (object.lineHeight != null) message.lineHeight = object.lineHeight | 0\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Font message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Font\n   * @static\n   * @param {Font} message Font\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Font.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      if (options.bytes === String) object.font = ''\n      else {\n        object.font = []\n        if (options.bytes !== Array) object.font = $util.newBuffer(object.font)\n      }\n      object.family = ''\n      object.size = 0\n      object.lineHeight = 0\n    }\n    if (message.font != null && message.hasOwnProperty('font'))\n      object.font =\n        options.bytes === String\n          ? $util.base64.encode(message.font, 0, message.font.length)\n          : options.bytes === Array\n          ? Array.prototype.slice.call(message.font)\n          : message.font\n    if (message.family != null && message.hasOwnProperty('family'))\n      object.family = message.family\n    if (message.size != null && message.hasOwnProperty('size'))\n      object.size = message.size\n    if (message.lineHeight != null && message.hasOwnProperty('lineHeight'))\n      object.lineHeight = message.lineHeight\n    return object\n  }\n\n  /**\n   * Converts this Font to JSON.\n   * @function toJSON\n   * @memberof Font\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Font.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Font\n})())\n\nexport const GlyphFont = ($root.GlyphFont = (() => {\n  /**\n   * Properties of a GlyphFont.\n   * @exports IGlyphFont\n   * @interface IGlyphFont\n   * @property {string|null} [letter] GlyphFont letter\n   * @property {IMetric|null} [adjustMetric] GlyphFont adjustMetric\n   * @property {Object.<string,number>|null} [kerning] GlyphFont kerning\n   */\n\n  /**\n   * Constructs a new GlyphFont.\n   * @exports GlyphFont\n   * @classdesc Represents a GlyphFont.\n   * @implements IGlyphFont\n   * @constructor\n   * @param {IGlyphFont=} [properties] Properties to set\n   */\n  function GlyphFont(properties) {\n    this.kerning = {}\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * GlyphFont letter.\n   * @member {string} letter\n   * @memberof GlyphFont\n   * @instance\n   */\n  GlyphFont.prototype.letter = ''\n\n  /**\n   * GlyphFont adjustMetric.\n   * @member {IMetric|null|undefined} adjustMetric\n   * @memberof GlyphFont\n   * @instance\n   */\n  GlyphFont.prototype.adjustMetric = null\n\n  /**\n   * GlyphFont kerning.\n   * @member {Object.<string,number>} kerning\n   * @memberof GlyphFont\n   * @instance\n   */\n  GlyphFont.prototype.kerning = $util.emptyObject\n\n  /**\n   * Creates a new GlyphFont instance using the specified properties.\n   * @function create\n   * @memberof GlyphFont\n   * @static\n   * @param {IGlyphFont=} [properties] Properties to set\n   * @returns {GlyphFont} GlyphFont instance\n   */\n  GlyphFont.create = function create(properties) {\n    return new GlyphFont(properties)\n  }\n\n  /**\n   * Encodes the specified GlyphFont message. Does not implicitly {@link GlyphFont.verify|verify} messages.\n   * @function encode\n   * @memberof GlyphFont\n   * @static\n   * @param {IGlyphFont} message GlyphFont message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GlyphFont.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.letter != null && Object.hasOwnProperty.call(message, 'letter'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.letter)\n    if (\n      message.adjustMetric != null &&\n      Object.hasOwnProperty.call(message, 'adjustMetric')\n    )\n      $root.Metric.encode(\n        message.adjustMetric,\n        writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n      ).ldelim()\n    if (\n      message.kerning != null &&\n      Object.hasOwnProperty.call(message, 'kerning')\n    )\n      for (let keys = Object.keys(message.kerning), i = 0; i < keys.length; ++i)\n        writer\n          .uint32(/* id 3, wireType 2 =*/ 26)\n          .fork()\n          .uint32(/* id 1, wireType 2 =*/ 10)\n          .string(keys[i])\n          .uint32(/* id 2, wireType 0 =*/ 16)\n          .int32(message.kerning[keys[i]])\n          .ldelim()\n    return writer\n  }\n\n  /**\n   * Encodes the specified GlyphFont message, length delimited. Does not implicitly {@link GlyphFont.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof GlyphFont\n   * @static\n   * @param {IGlyphFont} message GlyphFont message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GlyphFont.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a GlyphFont message from the specified reader or buffer.\n   * @function decode\n   * @memberof GlyphFont\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {GlyphFont} GlyphFont\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GlyphFont.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.GlyphFont(),\n      key,\n      value\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.letter = reader.string()\n          break\n        case 2:\n          message.adjustMetric = $root.Metric.decode(reader, reader.uint32())\n          break\n        case 3:\n          if (message.kerning === $util.emptyObject) message.kerning = {}\n          let end2 = reader.uint32() + reader.pos\n          key = ''\n          value = 0\n          while (reader.pos < end2) {\n            let tag2 = reader.uint32()\n            switch (tag2 >>> 3) {\n              case 1:\n                key = reader.string()\n                break\n              case 2:\n                value = reader.int32()\n                break\n              default:\n                reader.skipType(tag2 & 7)\n                break\n            }\n          }\n          message.kerning[key] = value\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a GlyphFont message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof GlyphFont\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {GlyphFont} GlyphFont\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GlyphFont.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a GlyphFont message.\n   * @function verify\n   * @memberof GlyphFont\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  GlyphFont.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.letter != null && message.hasOwnProperty('letter'))\n      if (!$util.isString(message.letter)) return 'letter: string expected'\n    if (\n      message.adjustMetric != null &&\n      message.hasOwnProperty('adjustMetric')\n    ) {\n      let error = $root.Metric.verify(message.adjustMetric)\n      if (error) return 'adjustMetric.' + error\n    }\n    if (message.kerning != null && message.hasOwnProperty('kerning')) {\n      if (!$util.isObject(message.kerning)) return 'kerning: object expected'\n      let key = Object.keys(message.kerning)\n      for (let i = 0; i < key.length; ++i)\n        if (!$util.isInteger(message.kerning[key[i]]))\n          return 'kerning: integer{k:string} expected'\n    }\n    return null\n  }\n\n  /**\n   * Creates a GlyphFont message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof GlyphFont\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {GlyphFont} GlyphFont\n   */\n  GlyphFont.fromObject = function fromObject(object) {\n    if (object instanceof $root.GlyphFont) return object\n    let message = new $root.GlyphFont()\n    if (object.letter != null) message.letter = String(object.letter)\n    if (object.adjustMetric != null) {\n      if (typeof object.adjustMetric !== 'object')\n        throw TypeError('.GlyphFont.adjustMetric: object expected')\n      message.adjustMetric = $root.Metric.fromObject(object.adjustMetric)\n    }\n    if (object.kerning) {\n      if (typeof object.kerning !== 'object')\n        throw TypeError('.GlyphFont.kerning: object expected')\n      message.kerning = {}\n      for (let keys = Object.keys(object.kerning), i = 0; i < keys.length; ++i)\n        message.kerning[keys[i]] = object.kerning[keys[i]] | 0\n    }\n    return message\n  }\n\n  /**\n   * Creates a plain object from a GlyphFont message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof GlyphFont\n   * @static\n   * @param {GlyphFont} message GlyphFont\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  GlyphFont.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.objects || options.defaults) object.kerning = {}\n    if (options.defaults) {\n      object.letter = ''\n      object.adjustMetric = null\n    }\n    if (message.letter != null && message.hasOwnProperty('letter'))\n      object.letter = message.letter\n    if (message.adjustMetric != null && message.hasOwnProperty('adjustMetric'))\n      object.adjustMetric = $root.Metric.toObject(message.adjustMetric, options)\n    let keys2\n    if (message.kerning && (keys2 = Object.keys(message.kerning)).length) {\n      object.kerning = {}\n      for (let j = 0; j < keys2.length; ++j)\n        object.kerning[keys2[j]] = message.kerning[keys2[j]]\n    }\n    return object\n  }\n\n  /**\n   * Converts this GlyphFont to JSON.\n   * @function toJSON\n   * @memberof GlyphFont\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  GlyphFont.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return GlyphFont\n})())\n\nexport const GlyphImage = ($root.GlyphImage = (() => {\n  /**\n   * Properties of a GlyphImage.\n   * @exports IGlyphImage\n   * @interface IGlyphImage\n   * @property {string|null} [letter] GlyphImage letter\n   * @property {IMetric|null} [adjustMetric] GlyphImage adjustMetric\n   * @property {Uint8Array|null} [buffer] GlyphImage buffer\n   * @property {string|null} [fileName] GlyphImage fileName\n   * @property {string|null} [fileType] GlyphImage fileType\n   * @property {boolean|null} [selected] GlyphImage selected\n   * @property {Object.<string,number>|null} [kerning] GlyphImage kerning\n   */\n\n  /**\n   * Constructs a new GlyphImage.\n   * @exports GlyphImage\n   * @classdesc Represents a GlyphImage.\n   * @implements IGlyphImage\n   * @constructor\n   * @param {IGlyphImage=} [properties] Properties to set\n   */\n  function GlyphImage(properties) {\n    this.kerning = {}\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * GlyphImage letter.\n   * @member {string} letter\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.letter = ''\n\n  /**\n   * GlyphImage adjustMetric.\n   * @member {IMetric|null|undefined} adjustMetric\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.adjustMetric = null\n\n  /**\n   * GlyphImage buffer.\n   * @member {Uint8Array} buffer\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.buffer = $util.newBuffer([])\n\n  /**\n   * GlyphImage fileName.\n   * @member {string} fileName\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.fileName = ''\n\n  /**\n   * GlyphImage fileType.\n   * @member {string} fileType\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.fileType = ''\n\n  /**\n   * GlyphImage selected.\n   * @member {boolean} selected\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.selected = false\n\n  /**\n   * GlyphImage kerning.\n   * @member {Object.<string,number>} kerning\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.kerning = $util.emptyObject\n\n  /**\n   * Creates a new GlyphImage instance using the specified properties.\n   * @function create\n   * @memberof GlyphImage\n   * @static\n   * @param {IGlyphImage=} [properties] Properties to set\n   * @returns {GlyphImage} GlyphImage instance\n   */\n  GlyphImage.create = function create(properties) {\n    return new GlyphImage(properties)\n  }\n\n  /**\n   * Encodes the specified GlyphImage message. Does not implicitly {@link GlyphImage.verify|verify} messages.\n   * @function encode\n   * @memberof GlyphImage\n   * @static\n   * @param {IGlyphImage} message GlyphImage message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GlyphImage.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.letter != null && Object.hasOwnProperty.call(message, 'letter'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.letter)\n    if (\n      message.adjustMetric != null &&\n      Object.hasOwnProperty.call(message, 'adjustMetric')\n    )\n      $root.Metric.encode(\n        message.adjustMetric,\n        writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n      ).ldelim()\n    if (message.buffer != null && Object.hasOwnProperty.call(message, 'buffer'))\n      writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.buffer)\n    if (\n      message.fileName != null &&\n      Object.hasOwnProperty.call(message, 'fileName')\n    )\n      writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.fileName)\n    if (\n      message.fileType != null &&\n      Object.hasOwnProperty.call(message, 'fileType')\n    )\n      writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.fileType)\n    if (\n      message.selected != null &&\n      Object.hasOwnProperty.call(message, 'selected')\n    )\n      writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.selected)\n    if (\n      message.kerning != null &&\n      Object.hasOwnProperty.call(message, 'kerning')\n    )\n      for (let keys = Object.keys(message.kerning), i = 0; i < keys.length; ++i)\n        writer\n          .uint32(/* id 7, wireType 2 =*/ 58)\n          .fork()\n          .uint32(/* id 1, wireType 2 =*/ 10)\n          .string(keys[i])\n          .uint32(/* id 2, wireType 0 =*/ 16)\n          .int32(message.kerning[keys[i]])\n          .ldelim()\n    return writer\n  }\n\n  /**\n   * Encodes the specified GlyphImage message, length delimited. Does not implicitly {@link GlyphImage.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof GlyphImage\n   * @static\n   * @param {IGlyphImage} message GlyphImage message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GlyphImage.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a GlyphImage message from the specified reader or buffer.\n   * @function decode\n   * @memberof GlyphImage\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {GlyphImage} GlyphImage\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GlyphImage.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.GlyphImage(),\n      key,\n      value\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.letter = reader.string()\n          break\n        case 2:\n          message.adjustMetric = $root.Metric.decode(reader, reader.uint32())\n          break\n        case 3:\n          message.buffer = reader.bytes()\n          break\n        case 4:\n          message.fileName = reader.string()\n          break\n        case 5:\n          message.fileType = reader.string()\n          break\n        case 6:\n          message.selected = reader.bool()\n          break\n        case 7:\n          if (message.kerning === $util.emptyObject) message.kerning = {}\n          let end2 = reader.uint32() + reader.pos\n          key = ''\n          value = 0\n          while (reader.pos < end2) {\n            let tag2 = reader.uint32()\n            switch (tag2 >>> 3) {\n              case 1:\n                key = reader.string()\n                break\n              case 2:\n                value = reader.int32()\n                break\n              default:\n                reader.skipType(tag2 & 7)\n                break\n            }\n          }\n          message.kerning[key] = value\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a GlyphImage message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof GlyphImage\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {GlyphImage} GlyphImage\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GlyphImage.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a GlyphImage message.\n   * @function verify\n   * @memberof GlyphImage\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  GlyphImage.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.letter != null && message.hasOwnProperty('letter'))\n      if (!$util.isString(message.letter)) return 'letter: string expected'\n    if (\n      message.adjustMetric != null &&\n      message.hasOwnProperty('adjustMetric')\n    ) {\n      let error = $root.Metric.verify(message.adjustMetric)\n      if (error) return 'adjustMetric.' + error\n    }\n    if (message.buffer != null && message.hasOwnProperty('buffer'))\n      if (\n        !(\n          (message.buffer && typeof message.buffer.length === 'number') ||\n          $util.isString(message.buffer)\n        )\n      )\n        return 'buffer: buffer expected'\n    if (message.fileName != null && message.hasOwnProperty('fileName'))\n      if (!$util.isString(message.fileName)) return 'fileName: string expected'\n    if (message.fileType != null && message.hasOwnProperty('fileType'))\n      if (!$util.isString(message.fileType)) return 'fileType: string expected'\n    if (message.selected != null && message.hasOwnProperty('selected'))\n      if (typeof message.selected !== 'boolean')\n        return 'selected: boolean expected'\n    if (message.kerning != null && message.hasOwnProperty('kerning')) {\n      if (!$util.isObject(message.kerning)) return 'kerning: object expected'\n      let key = Object.keys(message.kerning)\n      for (let i = 0; i < key.length; ++i)\n        if (!$util.isInteger(message.kerning[key[i]]))\n          return 'kerning: integer{k:string} expected'\n    }\n    return null\n  }\n\n  /**\n   * Creates a GlyphImage message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof GlyphImage\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {GlyphImage} GlyphImage\n   */\n  GlyphImage.fromObject = function fromObject(object) {\n    if (object instanceof $root.GlyphImage) return object\n    let message = new $root.GlyphImage()\n    if (object.letter != null) message.letter = String(object.letter)\n    if (object.adjustMetric != null) {\n      if (typeof object.adjustMetric !== 'object')\n        throw TypeError('.GlyphImage.adjustMetric: object expected')\n      message.adjustMetric = $root.Metric.fromObject(object.adjustMetric)\n    }\n    if (object.buffer != null)\n      if (typeof object.buffer === 'string')\n        $util.base64.decode(\n          object.buffer,\n          (message.buffer = $util.newBuffer(\n            $util.base64.length(object.buffer),\n          )),\n          0,\n        )\n      else if (object.buffer.length) message.buffer = object.buffer\n    if (object.fileName != null) message.fileName = String(object.fileName)\n    if (object.fileType != null) message.fileType = String(object.fileType)\n    if (object.selected != null) message.selected = Boolean(object.selected)\n    if (object.kerning) {\n      if (typeof object.kerning !== 'object')\n        throw TypeError('.GlyphImage.kerning: object expected')\n      message.kerning = {}\n      for (let keys = Object.keys(object.kerning), i = 0; i < keys.length; ++i)\n        message.kerning[keys[i]] = object.kerning[keys[i]] | 0\n    }\n    return message\n  }\n\n  /**\n   * Creates a plain object from a GlyphImage message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof GlyphImage\n   * @static\n   * @param {GlyphImage} message GlyphImage\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  GlyphImage.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.objects || options.defaults) object.kerning = {}\n    if (options.defaults) {\n      object.letter = ''\n      object.adjustMetric = null\n      if (options.bytes === String) object.buffer = ''\n      else {\n        object.buffer = []\n        if (options.bytes !== Array)\n          object.buffer = $util.newBuffer(object.buffer)\n      }\n      object.fileName = ''\n      object.fileType = ''\n      object.selected = false\n    }\n    if (message.letter != null && message.hasOwnProperty('letter'))\n      object.letter = message.letter\n    if (message.adjustMetric != null && message.hasOwnProperty('adjustMetric'))\n      object.adjustMetric = $root.Metric.toObject(message.adjustMetric, options)\n    if (message.buffer != null && message.hasOwnProperty('buffer'))\n      object.buffer =\n        options.bytes === String\n          ? $util.base64.encode(message.buffer, 0, message.buffer.length)\n          : options.bytes === Array\n          ? Array.prototype.slice.call(message.buffer)\n          : message.buffer\n    if (message.fileName != null && message.hasOwnProperty('fileName'))\n      object.fileName = message.fileName\n    if (message.fileType != null && message.hasOwnProperty('fileType'))\n      object.fileType = message.fileType\n    if (message.selected != null && message.hasOwnProperty('selected'))\n      object.selected = message.selected\n    let keys2\n    if (message.kerning && (keys2 = Object.keys(message.kerning)).length) {\n      object.kerning = {}\n      for (let j = 0; j < keys2.length; ++j)\n        object.kerning[keys2[j]] = message.kerning[keys2[j]]\n    }\n    return object\n  }\n\n  /**\n   * Converts this GlyphImage to JSON.\n   * @function toJSON\n   * @memberof GlyphImage\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  GlyphImage.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return GlyphImage\n})())\n\nexport const Layout = ($root.Layout = (() => {\n  /**\n   * Properties of a Layout.\n   * @exports ILayout\n   * @interface ILayout\n   * @property {number|null} [padding] Layout padding\n   * @property {number|null} [spacing] Layout spacing\n   * @property {boolean|null} [power] Layout power\n   */\n\n  /**\n   * Constructs a new Layout.\n   * @exports Layout\n   * @classdesc Represents a Layout.\n   * @implements ILayout\n   * @constructor\n   * @param {ILayout=} [properties] Properties to set\n   */\n  function Layout(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Layout padding.\n   * @member {number} padding\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.padding = 0\n\n  /**\n   * Layout spacing.\n   * @member {number} spacing\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.spacing = 0\n\n  /**\n   * Layout power.\n   * @member {boolean} power\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.power = false\n\n  /**\n   * Creates a new Layout instance using the specified properties.\n   * @function create\n   * @memberof Layout\n   * @static\n   * @param {ILayout=} [properties] Properties to set\n   * @returns {Layout} Layout instance\n   */\n  Layout.create = function create(properties) {\n    return new Layout(properties)\n  }\n\n  /**\n   * Encodes the specified Layout message. Does not implicitly {@link Layout.verify|verify} messages.\n   * @function encode\n   * @memberof Layout\n   * @static\n   * @param {ILayout} message Layout message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Layout.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (\n      message.padding != null &&\n      Object.hasOwnProperty.call(message, 'padding')\n    )\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.padding)\n    if (\n      message.spacing != null &&\n      Object.hasOwnProperty.call(message, 'spacing')\n    )\n      writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.spacing)\n    if (message.power != null && Object.hasOwnProperty.call(message, 'power'))\n      writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.power)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Layout message, length delimited. Does not implicitly {@link Layout.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Layout\n   * @static\n   * @param {ILayout} message Layout message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Layout.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Layout message from the specified reader or buffer.\n   * @function decode\n   * @memberof Layout\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Layout} Layout\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Layout.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Layout()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.padding = reader.int32()\n          break\n        case 2:\n          message.spacing = reader.int32()\n          break\n        case 3:\n          message.power = reader.bool()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Layout message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Layout\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Layout} Layout\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Layout.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Layout message.\n   * @function verify\n   * @memberof Layout\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Layout.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.padding != null && message.hasOwnProperty('padding'))\n      if (!$util.isInteger(message.padding)) return 'padding: integer expected'\n    if (message.spacing != null && message.hasOwnProperty('spacing'))\n      if (!$util.isInteger(message.spacing)) return 'spacing: integer expected'\n    if (message.power != null && message.hasOwnProperty('power'))\n      if (typeof message.power !== 'boolean') return 'power: boolean expected'\n    return null\n  }\n\n  /**\n   * Creates a Layout message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Layout\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Layout} Layout\n   */\n  Layout.fromObject = function fromObject(object) {\n    if (object instanceof $root.Layout) return object\n    let message = new $root.Layout()\n    if (object.padding != null) message.padding = object.padding | 0\n    if (object.spacing != null) message.spacing = object.spacing | 0\n    if (object.power != null) message.power = Boolean(object.power)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Layout message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Layout\n   * @static\n   * @param {Layout} message Layout\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Layout.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.padding = 0\n      object.spacing = 0\n      object.power = false\n    }\n    if (message.padding != null && message.hasOwnProperty('padding'))\n      object.padding = message.padding\n    if (message.spacing != null && message.hasOwnProperty('spacing'))\n      object.spacing = message.spacing\n    if (message.power != null && message.hasOwnProperty('power'))\n      object.power = message.power\n    return object\n  }\n\n  /**\n   * Converts this Layout to JSON.\n   * @function toJSON\n   * @memberof Layout\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Layout.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Layout\n})())\n\nexport const Shadow = ($root.Shadow = (() => {\n  /**\n   * Properties of a Shadow.\n   * @exports IShadow\n   * @interface IShadow\n   * @property {string|null} [color] Shadow color\n   * @property {number|null} [blur] Shadow blur\n   * @property {number|null} [offsetX] Shadow offsetX\n   * @property {number|null} [offsetY] Shadow offsetY\n   */\n\n  /**\n   * Constructs a new Shadow.\n   * @exports Shadow\n   * @classdesc Represents a Shadow.\n   * @implements IShadow\n   * @constructor\n   * @param {IShadow=} [properties] Properties to set\n   */\n  function Shadow(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Shadow color.\n   * @member {string} color\n   * @memberof Shadow\n   * @instance\n   */\n  Shadow.prototype.color = ''\n\n  /**\n   * Shadow blur.\n   * @member {number} blur\n   * @memberof Shadow\n   * @instance\n   */\n  Shadow.prototype.blur = 0\n\n  /**\n   * Shadow offsetX.\n   * @member {number} offsetX\n   * @memberof Shadow\n   * @instance\n   */\n  Shadow.prototype.offsetX = 0\n\n  /**\n   * Shadow offsetY.\n   * @member {number} offsetY\n   * @memberof Shadow\n   * @instance\n   */\n  Shadow.prototype.offsetY = 0\n\n  /**\n   * Creates a new Shadow instance using the specified properties.\n   * @function create\n   * @memberof Shadow\n   * @static\n   * @param {IShadow=} [properties] Properties to set\n   * @returns {Shadow} Shadow instance\n   */\n  Shadow.create = function create(properties) {\n    return new Shadow(properties)\n  }\n\n  /**\n   * Encodes the specified Shadow message. Does not implicitly {@link Shadow.verify|verify} messages.\n   * @function encode\n   * @memberof Shadow\n   * @static\n   * @param {IShadow} message Shadow message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Shadow.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.color != null && Object.hasOwnProperty.call(message, 'color'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.color)\n    if (message.blur != null && Object.hasOwnProperty.call(message, 'blur'))\n      writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.blur)\n    if (\n      message.offsetX != null &&\n      Object.hasOwnProperty.call(message, 'offsetX')\n    )\n      writer.uint32(/* id 3, wireType 0 =*/ 24).sint32(message.offsetX)\n    if (\n      message.offsetY != null &&\n      Object.hasOwnProperty.call(message, 'offsetY')\n    )\n      writer.uint32(/* id 4, wireType 0 =*/ 32).sint32(message.offsetY)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Shadow message, length delimited. Does not implicitly {@link Shadow.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Shadow\n   * @static\n   * @param {IShadow} message Shadow message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Shadow.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Shadow message from the specified reader or buffer.\n   * @function decode\n   * @memberof Shadow\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Shadow} Shadow\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Shadow.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Shadow()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.color = reader.string()\n          break\n        case 2:\n          message.blur = reader.int32()\n          break\n        case 3:\n          message.offsetX = reader.sint32()\n          break\n        case 4:\n          message.offsetY = reader.sint32()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Shadow message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Shadow\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Shadow} Shadow\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Shadow.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Shadow message.\n   * @function verify\n   * @memberof Shadow\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Shadow.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.color != null && message.hasOwnProperty('color'))\n      if (!$util.isString(message.color)) return 'color: string expected'\n    if (message.blur != null && message.hasOwnProperty('blur'))\n      if (!$util.isInteger(message.blur)) return 'blur: integer expected'\n    if (message.offsetX != null && message.hasOwnProperty('offsetX'))\n      if (!$util.isInteger(message.offsetX)) return 'offsetX: integer expected'\n    if (message.offsetY != null && message.hasOwnProperty('offsetY'))\n      if (!$util.isInteger(message.offsetY)) return 'offsetY: integer expected'\n    return null\n  }\n\n  /**\n   * Creates a Shadow message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Shadow\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Shadow} Shadow\n   */\n  Shadow.fromObject = function fromObject(object) {\n    if (object instanceof $root.Shadow) return object\n    let message = new $root.Shadow()\n    if (object.color != null) message.color = String(object.color)\n    if (object.blur != null) message.blur = object.blur | 0\n    if (object.offsetX != null) message.offsetX = object.offsetX | 0\n    if (object.offsetY != null) message.offsetY = object.offsetY | 0\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Shadow message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Shadow\n   * @static\n   * @param {Shadow} message Shadow\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Shadow.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.color = ''\n      object.blur = 0\n      object.offsetX = 0\n      object.offsetY = 0\n    }\n    if (message.color != null && message.hasOwnProperty('color'))\n      object.color = message.color\n    if (message.blur != null && message.hasOwnProperty('blur'))\n      object.blur = message.blur\n    if (message.offsetX != null && message.hasOwnProperty('offsetX'))\n      object.offsetX = message.offsetX\n    if (message.offsetY != null && message.hasOwnProperty('offsetY'))\n      object.offsetY = message.offsetY\n    return object\n  }\n\n  /**\n   * Converts this Shadow to JSON.\n   * @function toJSON\n   * @memberof Shadow\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Shadow.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Shadow\n})())\n\nexport const Style = ($root.Style = (() => {\n  /**\n   * Properties of a Style.\n   * @exports IStyle\n   * @interface IStyle\n   * @property {IFont|null} [font] Style font\n   * @property {IFill|null} [fill] Style fill\n   * @property {boolean|null} [useStroke] Style useStroke\n   * @property {IFill|null} [stroke] Style stroke\n   * @property {boolean|null} [useShadow] Style useShadow\n   * @property {IShadow|null} [shadow] Style shadow\n   * @property {string|null} [bgColor] Style bgColor\n   */\n\n  /**\n   * Constructs a new Style.\n   * @exports Style\n   * @classdesc Represents a Style.\n   * @implements IStyle\n   * @constructor\n   * @param {IStyle=} [properties] Properties to set\n   */\n  function Style(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Style font.\n   * @member {IFont|null|undefined} font\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.font = null\n\n  /**\n   * Style fill.\n   * @member {IFill|null|undefined} fill\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.fill = null\n\n  /**\n   * Style useStroke.\n   * @member {boolean} useStroke\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.useStroke = false\n\n  /**\n   * Style stroke.\n   * @member {IFill|null|undefined} stroke\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.stroke = null\n\n  /**\n   * Style useShadow.\n   * @member {boolean} useShadow\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.useShadow = false\n\n  /**\n   * Style shadow.\n   * @member {IShadow|null|undefined} shadow\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.shadow = null\n\n  /**\n   * Style bgColor.\n   * @member {string} bgColor\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.bgColor = ''\n\n  /**\n   * Creates a new Style instance using the specified properties.\n   * @function create\n   * @memberof Style\n   * @static\n   * @param {IStyle=} [properties] Properties to set\n   * @returns {Style} Style instance\n   */\n  Style.create = function create(properties) {\n    return new Style(properties)\n  }\n\n  /**\n   * Encodes the specified Style message. Does not implicitly {@link Style.verify|verify} messages.\n   * @function encode\n   * @memberof Style\n   * @static\n   * @param {IStyle} message Style message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Style.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.font != null && Object.hasOwnProperty.call(message, 'font'))\n      $root.Font.encode(\n        message.font,\n        writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),\n      ).ldelim()\n    if (message.fill != null && Object.hasOwnProperty.call(message, 'fill'))\n      $root.Fill.encode(\n        message.fill,\n        writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n      ).ldelim()\n    if (\n      message.useStroke != null &&\n      Object.hasOwnProperty.call(message, 'useStroke')\n    )\n      writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.useStroke)\n    if (message.stroke != null && Object.hasOwnProperty.call(message, 'stroke'))\n      $root.Fill.encode(\n        message.stroke,\n        writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),\n      ).ldelim()\n    if (\n      message.useShadow != null &&\n      Object.hasOwnProperty.call(message, 'useShadow')\n    )\n      writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.useShadow)\n    if (message.shadow != null && Object.hasOwnProperty.call(message, 'shadow'))\n      $root.Shadow.encode(\n        message.shadow,\n        writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),\n      ).ldelim()\n    if (\n      message.bgColor != null &&\n      Object.hasOwnProperty.call(message, 'bgColor')\n    )\n      writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.bgColor)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Style message, length delimited. Does not implicitly {@link Style.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Style\n   * @static\n   * @param {IStyle} message Style message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Style.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Style message from the specified reader or buffer.\n   * @function decode\n   * @memberof Style\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Style} Style\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Style.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Style()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.font = $root.Font.decode(reader, reader.uint32())\n          break\n        case 2:\n          message.fill = $root.Fill.decode(reader, reader.uint32())\n          break\n        case 3:\n          message.useStroke = reader.bool()\n          break\n        case 4:\n          message.stroke = $root.Fill.decode(reader, reader.uint32())\n          break\n        case 5:\n          message.useShadow = reader.bool()\n          break\n        case 6:\n          message.shadow = $root.Shadow.decode(reader, reader.uint32())\n          break\n        case 7:\n          message.bgColor = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Style message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Style\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Style} Style\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Style.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Style message.\n   * @function verify\n   * @memberof Style\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Style.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.font != null && message.hasOwnProperty('font')) {\n      let error = $root.Font.verify(message.font)\n      if (error) return 'font.' + error\n    }\n    if (message.fill != null && message.hasOwnProperty('fill')) {\n      let error = $root.Fill.verify(message.fill)\n      if (error) return 'fill.' + error\n    }\n    if (message.useStroke != null && message.hasOwnProperty('useStroke'))\n      if (typeof message.useStroke !== 'boolean')\n        return 'useStroke: boolean expected'\n    if (message.stroke != null && message.hasOwnProperty('stroke')) {\n      let error = $root.Fill.verify(message.stroke)\n      if (error) return 'stroke.' + error\n    }\n    if (message.useShadow != null && message.hasOwnProperty('useShadow'))\n      if (typeof message.useShadow !== 'boolean')\n        return 'useShadow: boolean expected'\n    if (message.shadow != null && message.hasOwnProperty('shadow')) {\n      let error = $root.Shadow.verify(message.shadow)\n      if (error) return 'shadow.' + error\n    }\n    if (message.bgColor != null && message.hasOwnProperty('bgColor'))\n      if (!$util.isString(message.bgColor)) return 'bgColor: string expected'\n    return null\n  }\n\n  /**\n   * Creates a Style message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Style\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Style} Style\n   */\n  Style.fromObject = function fromObject(object) {\n    if (object instanceof $root.Style) return object\n    let message = new $root.Style()\n    if (object.font != null) {\n      if (typeof object.font !== 'object')\n        throw TypeError('.Style.font: object expected')\n      message.font = $root.Font.fromObject(object.font)\n    }\n    if (object.fill != null) {\n      if (typeof object.fill !== 'object')\n        throw TypeError('.Style.fill: object expected')\n      message.fill = $root.Fill.fromObject(object.fill)\n    }\n    if (object.useStroke != null) message.useStroke = Boolean(object.useStroke)\n    if (object.stroke != null) {\n      if (typeof object.stroke !== 'object')\n        throw TypeError('.Style.stroke: object expected')\n      message.stroke = $root.Fill.fromObject(object.stroke)\n    }\n    if (object.useShadow != null) message.useShadow = Boolean(object.useShadow)\n    if (object.shadow != null) {\n      if (typeof object.shadow !== 'object')\n        throw TypeError('.Style.shadow: object expected')\n      message.shadow = $root.Shadow.fromObject(object.shadow)\n    }\n    if (object.bgColor != null) message.bgColor = String(object.bgColor)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Style message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Style\n   * @static\n   * @param {Style} message Style\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Style.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.font = null\n      object.fill = null\n      object.useStroke = false\n      object.stroke = null\n      object.useShadow = false\n      object.shadow = null\n      object.bgColor = ''\n    }\n    if (message.font != null && message.hasOwnProperty('font'))\n      object.font = $root.Font.toObject(message.font, options)\n    if (message.fill != null && message.hasOwnProperty('fill'))\n      object.fill = $root.Fill.toObject(message.fill, options)\n    if (message.useStroke != null && message.hasOwnProperty('useStroke'))\n      object.useStroke = message.useStroke\n    if (message.stroke != null && message.hasOwnProperty('stroke'))\n      object.stroke = $root.Fill.toObject(message.stroke, options)\n    if (message.useShadow != null && message.hasOwnProperty('useShadow'))\n      object.useShadow = message.useShadow\n    if (message.shadow != null && message.hasOwnProperty('shadow'))\n      object.shadow = $root.Shadow.toObject(message.shadow, options)\n    if (message.bgColor != null && message.hasOwnProperty('bgColor'))\n      object.bgColor = message.bgColor\n    return object\n  }\n\n  /**\n   * Converts this Style to JSON.\n   * @function toJSON\n   * @memberof Style\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Style.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Style\n})())\n\nexport const Ui = ($root.Ui = (() => {\n  /**\n   * Properties of an Ui.\n   * @exports IUi\n   * @interface IUi\n   * @property {string|null} [previewText] Ui previewText\n   */\n\n  /**\n   * Constructs a new Ui.\n   * @exports Ui\n   * @classdesc Represents an Ui.\n   * @implements IUi\n   * @constructor\n   * @param {IUi=} [properties] Properties to set\n   */\n  function Ui(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Ui previewText.\n   * @member {string} previewText\n   * @memberof Ui\n   * @instance\n   */\n  Ui.prototype.previewText = ''\n\n  /**\n   * Creates a new Ui instance using the specified properties.\n   * @function create\n   * @memberof Ui\n   * @static\n   * @param {IUi=} [properties] Properties to set\n   * @returns {Ui} Ui instance\n   */\n  Ui.create = function create(properties) {\n    return new Ui(properties)\n  }\n\n  /**\n   * Encodes the specified Ui message. Does not implicitly {@link Ui.verify|verify} messages.\n   * @function encode\n   * @memberof Ui\n   * @static\n   * @param {IUi} message Ui message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Ui.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (\n      message.previewText != null &&\n      Object.hasOwnProperty.call(message, 'previewText')\n    )\n      writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.previewText)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Ui message, length delimited. Does not implicitly {@link Ui.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Ui\n   * @static\n   * @param {IUi} message Ui message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Ui.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes an Ui message from the specified reader or buffer.\n   * @function decode\n   * @memberof Ui\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Ui} Ui\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Ui.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Ui()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.previewText = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes an Ui message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Ui\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Ui} Ui\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Ui.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies an Ui message.\n   * @function verify\n   * @memberof Ui\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Ui.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.previewText != null && message.hasOwnProperty('previewText'))\n      if (!$util.isString(message.previewText))\n        return 'previewText: string expected'\n    return null\n  }\n\n  /**\n   * Creates an Ui message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Ui\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Ui} Ui\n   */\n  Ui.fromObject = function fromObject(object) {\n    if (object instanceof $root.Ui) return object\n    let message = new $root.Ui()\n    if (object.previewText != null)\n      message.previewText = String(object.previewText)\n    return message\n  }\n\n  /**\n   * Creates a plain object from an Ui message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Ui\n   * @static\n   * @param {Ui} message Ui\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Ui.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) object.previewText = ''\n    if (message.previewText != null && message.hasOwnProperty('previewText'))\n      object.previewText = message.previewText\n    return object\n  }\n\n  /**\n   * Converts this Ui to JSON.\n   * @function toJSON\n   * @memberof Ui\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Ui.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Ui\n})())\n\nexport const Project = ($root.Project = (() => {\n  /**\n   * Properties of a Project.\n   * @exports IProject\n   * @interface IProject\n   * @property {number|Long|null} [id] Project id\n   * @property {string|null} [name] Project name\n   * @property {string|null} [text] Project text\n   * @property {Object.<string,IGlyphFont>|null} [glyphs] Project glyphs\n   * @property {Array.<IGlyphImage>|null} [glyphImages] Project glyphImages\n   * @property {IStyle|null} [style] Project style\n   * @property {ILayout|null} [layout] Project layout\n   * @property {IMetric|null} [globalAdjustMetric] Project globalAdjustMetric\n   * @property {IUi|null} [ui] Project ui\n   */\n\n  /**\n   * Constructs a new Project.\n   * @exports Project\n   * @classdesc Represents a Project.\n   * @implements IProject\n   * @constructor\n   * @param {IProject=} [properties] Properties to set\n   */\n  function Project(properties) {\n    this.glyphs = {}\n    this.glyphImages = []\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Project id.\n   * @member {number|Long} id\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, false) : 0\n\n  /**\n   * Project name.\n   * @member {string} name\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.name = ''\n\n  /**\n   * Project text.\n   * @member {string} text\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.text = ''\n\n  /**\n   * Project glyphs.\n   * @member {Object.<string,IGlyphFont>} glyphs\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.glyphs = $util.emptyObject\n\n  /**\n   * Project glyphImages.\n   * @member {Array.<IGlyphImage>} glyphImages\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.glyphImages = $util.emptyArray\n\n  /**\n   * Project style.\n   * @member {IStyle|null|undefined} style\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.style = null\n\n  /**\n   * Project layout.\n   * @member {ILayout|null|undefined} layout\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.layout = null\n\n  /**\n   * Project globalAdjustMetric.\n   * @member {IMetric|null|undefined} globalAdjustMetric\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.globalAdjustMetric = null\n\n  /**\n   * Project ui.\n   * @member {IUi|null|undefined} ui\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.ui = null\n\n  /**\n   * Creates a new Project instance using the specified properties.\n   * @function create\n   * @memberof Project\n   * @static\n   * @param {IProject=} [properties] Properties to set\n   * @returns {Project} Project instance\n   */\n  Project.create = function create(properties) {\n    return new Project(properties)\n  }\n\n  /**\n   * Encodes the specified Project message. Does not implicitly {@link Project.verify|verify} messages.\n   * @function encode\n   * @memberof Project\n   * @static\n   * @param {IProject} message Project message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Project.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.id != null && Object.hasOwnProperty.call(message, 'id'))\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.id)\n    if (message.name != null && Object.hasOwnProperty.call(message, 'name'))\n      writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name)\n    if (message.text != null && Object.hasOwnProperty.call(message, 'text'))\n      writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.text)\n    if (message.glyphs != null && Object.hasOwnProperty.call(message, 'glyphs'))\n      for (\n        let keys = Object.keys(message.glyphs), i = 0;\n        i < keys.length;\n        ++i\n      ) {\n        writer\n          .uint32(/* id 4, wireType 2 =*/ 34)\n          .fork()\n          .uint32(/* id 1, wireType 2 =*/ 10)\n          .string(keys[i])\n        $root.GlyphFont.encode(\n          message.glyphs[keys[i]],\n          writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n        )\n          .ldelim()\n          .ldelim()\n      }\n    if (message.glyphImages != null && message.glyphImages.length)\n      for (let i = 0; i < message.glyphImages.length; ++i)\n        $root.GlyphImage.encode(\n          message.glyphImages[i],\n          writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),\n        ).ldelim()\n    if (message.style != null && Object.hasOwnProperty.call(message, 'style'))\n      $root.Style.encode(\n        message.style,\n        writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),\n      ).ldelim()\n    if (message.layout != null && Object.hasOwnProperty.call(message, 'layout'))\n      $root.Layout.encode(\n        message.layout,\n        writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),\n      ).ldelim()\n    if (\n      message.globalAdjustMetric != null &&\n      Object.hasOwnProperty.call(message, 'globalAdjustMetric')\n    )\n      $root.Metric.encode(\n        message.globalAdjustMetric,\n        writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),\n      ).ldelim()\n    if (message.ui != null && Object.hasOwnProperty.call(message, 'ui'))\n      $root.Ui.encode(\n        message.ui,\n        writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),\n      ).ldelim()\n    return writer\n  }\n\n  /**\n   * Encodes the specified Project message, length delimited. Does not implicitly {@link Project.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Project\n   * @static\n   * @param {IProject} message Project message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Project.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Project message from the specified reader or buffer.\n   * @function decode\n   * @memberof Project\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Project} Project\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Project.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Project(),\n      key,\n      value\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.int64()\n          break\n        case 2:\n          message.name = reader.string()\n          break\n        case 3:\n          message.text = reader.string()\n          break\n        case 4:\n          if (message.glyphs === $util.emptyObject) message.glyphs = {}\n          let end2 = reader.uint32() + reader.pos\n          key = ''\n          value = null\n          while (reader.pos < end2) {\n            let tag2 = reader.uint32()\n            switch (tag2 >>> 3) {\n              case 1:\n                key = reader.string()\n                break\n              case 2:\n                value = $root.GlyphFont.decode(reader, reader.uint32())\n                break\n              default:\n                reader.skipType(tag2 & 7)\n                break\n            }\n          }\n          message.glyphs[key] = value\n          break\n        case 5:\n          if (!(message.glyphImages && message.glyphImages.length))\n            message.glyphImages = []\n          message.glyphImages.push(\n            $root.GlyphImage.decode(reader, reader.uint32()),\n          )\n          break\n        case 6:\n          message.style = $root.Style.decode(reader, reader.uint32())\n          break\n        case 7:\n          message.layout = $root.Layout.decode(reader, reader.uint32())\n          break\n        case 8:\n          message.globalAdjustMetric = $root.Metric.decode(\n            reader,\n            reader.uint32(),\n          )\n          break\n        case 9:\n          message.ui = $root.Ui.decode(reader, reader.uint32())\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Project message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Project\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Project} Project\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Project.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Project message.\n   * @function verify\n   * @memberof Project\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Project.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.id != null && message.hasOwnProperty('id'))\n      if (\n        !$util.isInteger(message.id) &&\n        !(\n          message.id &&\n          $util.isInteger(message.id.low) &&\n          $util.isInteger(message.id.high)\n        )\n      )\n        return 'id: integer|Long expected'\n    if (message.name != null && message.hasOwnProperty('name'))\n      if (!$util.isString(message.name)) return 'name: string expected'\n    if (message.text != null && message.hasOwnProperty('text'))\n      if (!$util.isString(message.text)) return 'text: string expected'\n    if (message.glyphs != null && message.hasOwnProperty('glyphs')) {\n      if (!$util.isObject(message.glyphs)) return 'glyphs: object expected'\n      let key = Object.keys(message.glyphs)\n      for (let i = 0; i < key.length; ++i) {\n        let error = $root.GlyphFont.verify(message.glyphs[key[i]])\n        if (error) return 'glyphs.' + error\n      }\n    }\n    if (message.glyphImages != null && message.hasOwnProperty('glyphImages')) {\n      if (!Array.isArray(message.glyphImages))\n        return 'glyphImages: array expected'\n      for (let i = 0; i < message.glyphImages.length; ++i) {\n        let error = $root.GlyphImage.verify(message.glyphImages[i])\n        if (error) return 'glyphImages.' + error\n      }\n    }\n    if (message.style != null && message.hasOwnProperty('style')) {\n      let error = $root.Style.verify(message.style)\n      if (error) return 'style.' + error\n    }\n    if (message.layout != null && message.hasOwnProperty('layout')) {\n      let error = $root.Layout.verify(message.layout)\n      if (error) return 'layout.' + error\n    }\n    if (\n      message.globalAdjustMetric != null &&\n      message.hasOwnProperty('globalAdjustMetric')\n    ) {\n      let error = $root.Metric.verify(message.globalAdjustMetric)\n      if (error) return 'globalAdjustMetric.' + error\n    }\n    if (message.ui != null && message.hasOwnProperty('ui')) {\n      let error = $root.Ui.verify(message.ui)\n      if (error) return 'ui.' + error\n    }\n    return null\n  }\n\n  /**\n   * Creates a Project message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Project\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Project} Project\n   */\n  Project.fromObject = function fromObject(object) {\n    if (object instanceof $root.Project) return object\n    let message = new $root.Project()\n    if (object.id != null)\n      if ($util.Long)\n        (message.id = $util.Long.fromValue(object.id)).unsigned = false\n      else if (typeof object.id === 'string')\n        message.id = parseInt(object.id, 10)\n      else if (typeof object.id === 'number') message.id = object.id\n      else if (typeof object.id === 'object')\n        message.id = new $util.LongBits(\n          object.id.low >>> 0,\n          object.id.high >>> 0,\n        ).toNumber()\n    if (object.name != null) message.name = String(object.name)\n    if (object.text != null) message.text = String(object.text)\n    if (object.glyphs) {\n      if (typeof object.glyphs !== 'object')\n        throw TypeError('.Project.glyphs: object expected')\n      message.glyphs = {}\n      for (let keys = Object.keys(object.glyphs), i = 0; i < keys.length; ++i) {\n        if (typeof object.glyphs[keys[i]] !== 'object')\n          throw TypeError('.Project.glyphs: object expected')\n        message.glyphs[keys[i]] = $root.GlyphFont.fromObject(\n          object.glyphs[keys[i]],\n        )\n      }\n    }\n    if (object.glyphImages) {\n      if (!Array.isArray(object.glyphImages))\n        throw TypeError('.Project.glyphImages: array expected')\n      message.glyphImages = []\n      for (let i = 0; i < object.glyphImages.length; ++i) {\n        if (typeof object.glyphImages[i] !== 'object')\n          throw TypeError('.Project.glyphImages: object expected')\n        message.glyphImages[i] = $root.GlyphImage.fromObject(\n          object.glyphImages[i],\n        )\n      }\n    }\n    if (object.style != null) {\n      if (typeof object.style !== 'object')\n        throw TypeError('.Project.style: object expected')\n      message.style = $root.Style.fromObject(object.style)\n    }\n    if (object.layout != null) {\n      if (typeof object.layout !== 'object')\n        throw TypeError('.Project.layout: object expected')\n      message.layout = $root.Layout.fromObject(object.layout)\n    }\n    if (object.globalAdjustMetric != null) {\n      if (typeof object.globalAdjustMetric !== 'object')\n        throw TypeError('.Project.globalAdjustMetric: object expected')\n      message.globalAdjustMetric = $root.Metric.fromObject(\n        object.globalAdjustMetric,\n      )\n    }\n    if (object.ui != null) {\n      if (typeof object.ui !== 'object')\n        throw TypeError('.Project.ui: object expected')\n      message.ui = $root.Ui.fromObject(object.ui)\n    }\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Project message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Project\n   * @static\n   * @param {Project} message Project\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Project.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.arrays || options.defaults) object.glyphImages = []\n    if (options.objects || options.defaults) object.glyphs = {}\n    if (options.defaults) {\n      if ($util.Long) {\n        let long = new $util.Long(0, 0, false)\n        object.id =\n          options.longs === String\n            ? long.toString()\n            : options.longs === Number\n            ? long.toNumber()\n            : long\n      } else object.id = options.longs === String ? '0' : 0\n      object.name = ''\n      object.text = ''\n      object.style = null\n      object.layout = null\n      object.globalAdjustMetric = null\n      object.ui = null\n    }\n    if (message.id != null && message.hasOwnProperty('id'))\n      if (typeof message.id === 'number')\n        object.id = options.longs === String ? String(message.id) : message.id\n      else\n        object.id =\n          options.longs === String\n            ? $util.Long.prototype.toString.call(message.id)\n            : options.longs === Number\n            ? new $util.LongBits(\n                message.id.low >>> 0,\n                message.id.high >>> 0,\n              ).toNumber()\n            : message.id\n    if (message.name != null && message.hasOwnProperty('name'))\n      object.name = message.name\n    if (message.text != null && message.hasOwnProperty('text'))\n      object.text = message.text\n    let keys2\n    if (message.glyphs && (keys2 = Object.keys(message.glyphs)).length) {\n      object.glyphs = {}\n      for (let j = 0; j < keys2.length; ++j)\n        object.glyphs[keys2[j]] = $root.GlyphFont.toObject(\n          message.glyphs[keys2[j]],\n          options,\n        )\n    }\n    if (message.glyphImages && message.glyphImages.length) {\n      object.glyphImages = []\n      for (let j = 0; j < message.glyphImages.length; ++j)\n        object.glyphImages[j] = $root.GlyphImage.toObject(\n          message.glyphImages[j],\n          options,\n        )\n    }\n    if (message.style != null && message.hasOwnProperty('style'))\n      object.style = $root.Style.toObject(message.style, options)\n    if (message.layout != null && message.hasOwnProperty('layout'))\n      object.layout = $root.Layout.toObject(message.layout, options)\n    if (\n      message.globalAdjustMetric != null &&\n      message.hasOwnProperty('globalAdjustMetric')\n    )\n      object.globalAdjustMetric = $root.Metric.toObject(\n        message.globalAdjustMetric,\n        options,\n      )\n    if (message.ui != null && message.hasOwnProperty('ui'))\n      object.ui = $root.Ui.toObject(message.ui, options)\n    return object\n  }\n\n  /**\n   * Converts this Project to JSON.\n   * @function toJSON\n   * @memberof Project\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Project.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Project\n})())\n\nexport { $root as default }\n","import { IProject } from './project'\nimport { IProject as IProjectNext } from '../1.0.1'\n\nexport default function updateToNext(project: IProject): IProjectNext {\n  const next = project as IProjectNext\n  next.layout = { ...project.layout }\n  next.layout.width = 1024\n  next.layout.height = 1024\n  next.layout.auto = true\n  next.layout.fixedSize = false\n  return next\n}\n","/* eslint-disable */\nimport * as $protobuf from 'protobufjs/minimal'\n\n// Common aliases\nconst $Reader = $protobuf.Reader,\n  $Writer = $protobuf.Writer,\n  $util = $protobuf.util\n\n// Exported root namespace\nconst $root = {}\n\nexport const Metric = ($root.Metric = (() => {\n  /**\n   * Properties of a Metric.\n   * @exports IMetric\n   * @interface IMetric\n   * @property {number|null} [xAdvance] Metric xAdvance\n   * @property {number|null} [xOffset] Metric xOffset\n   * @property {number|null} [yOffset] Metric yOffset\n   */\n\n  /**\n   * Constructs a new Metric.\n   * @exports Metric\n   * @classdesc Represents a Metric.\n   * @implements IMetric\n   * @constructor\n   * @param {IMetric=} [properties] Properties to set\n   */\n  function Metric(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Metric xAdvance.\n   * @member {number} xAdvance\n   * @memberof Metric\n   * @instance\n   */\n  Metric.prototype.xAdvance = 0\n\n  /**\n   * Metric xOffset.\n   * @member {number} xOffset\n   * @memberof Metric\n   * @instance\n   */\n  Metric.prototype.xOffset = 0\n\n  /**\n   * Metric yOffset.\n   * @member {number} yOffset\n   * @memberof Metric\n   * @instance\n   */\n  Metric.prototype.yOffset = 0\n\n  /**\n   * Creates a new Metric instance using the specified properties.\n   * @function create\n   * @memberof Metric\n   * @static\n   * @param {IMetric=} [properties] Properties to set\n   * @returns {Metric} Metric instance\n   */\n  Metric.create = function create(properties) {\n    return new Metric(properties)\n  }\n\n  /**\n   * Encodes the specified Metric message. Does not implicitly {@link Metric.verify|verify} messages.\n   * @function encode\n   * @memberof Metric\n   * @static\n   * @param {IMetric} message Metric message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Metric.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (\n      message.xAdvance != null &&\n      Object.hasOwnProperty.call(message, 'xAdvance')\n    )\n      writer.uint32(/* id 1, wireType 0 =*/ 8).sint32(message.xAdvance)\n    if (\n      message.xOffset != null &&\n      Object.hasOwnProperty.call(message, 'xOffset')\n    )\n      writer.uint32(/* id 2, wireType 0 =*/ 16).sint32(message.xOffset)\n    if (\n      message.yOffset != null &&\n      Object.hasOwnProperty.call(message, 'yOffset')\n    )\n      writer.uint32(/* id 3, wireType 0 =*/ 24).sint32(message.yOffset)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Metric message, length delimited. Does not implicitly {@link Metric.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Metric\n   * @static\n   * @param {IMetric} message Metric message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Metric.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Metric message from the specified reader or buffer.\n   * @function decode\n   * @memberof Metric\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Metric} Metric\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Metric.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Metric()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.xAdvance = reader.sint32()\n          break\n        case 2:\n          message.xOffset = reader.sint32()\n          break\n        case 3:\n          message.yOffset = reader.sint32()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Metric message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Metric\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Metric} Metric\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Metric.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Metric message.\n   * @function verify\n   * @memberof Metric\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Metric.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.xAdvance != null && message.hasOwnProperty('xAdvance'))\n      if (!$util.isInteger(message.xAdvance))\n        return 'xAdvance: integer expected'\n    if (message.xOffset != null && message.hasOwnProperty('xOffset'))\n      if (!$util.isInteger(message.xOffset)) return 'xOffset: integer expected'\n    if (message.yOffset != null && message.hasOwnProperty('yOffset'))\n      if (!$util.isInteger(message.yOffset)) return 'yOffset: integer expected'\n    return null\n  }\n\n  /**\n   * Creates a Metric message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Metric\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Metric} Metric\n   */\n  Metric.fromObject = function fromObject(object) {\n    if (object instanceof $root.Metric) return object\n    let message = new $root.Metric()\n    if (object.xAdvance != null) message.xAdvance = object.xAdvance | 0\n    if (object.xOffset != null) message.xOffset = object.xOffset | 0\n    if (object.yOffset != null) message.yOffset = object.yOffset | 0\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Metric message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Metric\n   * @static\n   * @param {Metric} message Metric\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Metric.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.xAdvance = 0\n      object.xOffset = 0\n      object.yOffset = 0\n    }\n    if (message.xAdvance != null && message.hasOwnProperty('xAdvance'))\n      object.xAdvance = message.xAdvance\n    if (message.xOffset != null && message.hasOwnProperty('xOffset'))\n      object.xOffset = message.xOffset\n    if (message.yOffset != null && message.hasOwnProperty('yOffset'))\n      object.yOffset = message.yOffset\n    return object\n  }\n\n  /**\n   * Converts this Metric to JSON.\n   * @function toJSON\n   * @memberof Metric\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Metric.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Metric\n})())\n\nexport const GradientColor = ($root.GradientColor = (() => {\n  /**\n   * Properties of a GradientColor.\n   * @exports IGradientColor\n   * @interface IGradientColor\n   * @property {number|null} [id] GradientColor id\n   * @property {number|null} [offset] GradientColor offset\n   * @property {string|null} [color] GradientColor color\n   */\n\n  /**\n   * Constructs a new GradientColor.\n   * @exports GradientColor\n   * @classdesc Represents a GradientColor.\n   * @implements IGradientColor\n   * @constructor\n   * @param {IGradientColor=} [properties] Properties to set\n   */\n  function GradientColor(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * GradientColor id.\n   * @member {number} id\n   * @memberof GradientColor\n   * @instance\n   */\n  GradientColor.prototype.id = 0\n\n  /**\n   * GradientColor offset.\n   * @member {number} offset\n   * @memberof GradientColor\n   * @instance\n   */\n  GradientColor.prototype.offset = 0\n\n  /**\n   * GradientColor color.\n   * @member {string} color\n   * @memberof GradientColor\n   * @instance\n   */\n  GradientColor.prototype.color = ''\n\n  /**\n   * Creates a new GradientColor instance using the specified properties.\n   * @function create\n   * @memberof GradientColor\n   * @static\n   * @param {IGradientColor=} [properties] Properties to set\n   * @returns {GradientColor} GradientColor instance\n   */\n  GradientColor.create = function create(properties) {\n    return new GradientColor(properties)\n  }\n\n  /**\n   * Encodes the specified GradientColor message. Does not implicitly {@link GradientColor.verify|verify} messages.\n   * @function encode\n   * @memberof GradientColor\n   * @static\n   * @param {IGradientColor} message GradientColor message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GradientColor.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.id != null && Object.hasOwnProperty.call(message, 'id'))\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.id)\n    if (message.offset != null && Object.hasOwnProperty.call(message, 'offset'))\n      writer.uint32(/* id 2, wireType 0 =*/ 16).sint32(message.offset)\n    if (message.color != null && Object.hasOwnProperty.call(message, 'color'))\n      writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.color)\n    return writer\n  }\n\n  /**\n   * Encodes the specified GradientColor message, length delimited. Does not implicitly {@link GradientColor.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof GradientColor\n   * @static\n   * @param {IGradientColor} message GradientColor message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GradientColor.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a GradientColor message from the specified reader or buffer.\n   * @function decode\n   * @memberof GradientColor\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {GradientColor} GradientColor\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GradientColor.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.GradientColor()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.int32()\n          break\n        case 2:\n          message.offset = reader.sint32()\n          break\n        case 3:\n          message.color = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a GradientColor message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof GradientColor\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {GradientColor} GradientColor\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GradientColor.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a GradientColor message.\n   * @function verify\n   * @memberof GradientColor\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  GradientColor.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.id != null && message.hasOwnProperty('id'))\n      if (!$util.isInteger(message.id)) return 'id: integer expected'\n    if (message.offset != null && message.hasOwnProperty('offset'))\n      if (!$util.isInteger(message.offset)) return 'offset: integer expected'\n    if (message.color != null && message.hasOwnProperty('color'))\n      if (!$util.isString(message.color)) return 'color: string expected'\n    return null\n  }\n\n  /**\n   * Creates a GradientColor message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof GradientColor\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {GradientColor} GradientColor\n   */\n  GradientColor.fromObject = function fromObject(object) {\n    if (object instanceof $root.GradientColor) return object\n    let message = new $root.GradientColor()\n    if (object.id != null) message.id = object.id | 0\n    if (object.offset != null) message.offset = object.offset | 0\n    if (object.color != null) message.color = String(object.color)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a GradientColor message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof GradientColor\n   * @static\n   * @param {GradientColor} message GradientColor\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  GradientColor.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.id = 0\n      object.offset = 0\n      object.color = ''\n    }\n    if (message.id != null && message.hasOwnProperty('id'))\n      object.id = message.id\n    if (message.offset != null && message.hasOwnProperty('offset'))\n      object.offset = message.offset\n    if (message.color != null && message.hasOwnProperty('color'))\n      object.color = message.color\n    return object\n  }\n\n  /**\n   * Converts this GradientColor to JSON.\n   * @function toJSON\n   * @memberof GradientColor\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  GradientColor.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return GradientColor\n})())\n\nexport const Gradient = ($root.Gradient = (() => {\n  /**\n   * Properties of a Gradient.\n   * @exports IGradient\n   * @interface IGradient\n   * @property {number|null} [type] Gradient type\n   * @property {number|null} [angle] Gradient angle\n   * @property {Array.<IGradientColor>|null} [palette] Gradient palette\n   */\n\n  /**\n   * Constructs a new Gradient.\n   * @exports Gradient\n   * @classdesc Represents a Gradient.\n   * @implements IGradient\n   * @constructor\n   * @param {IGradient=} [properties] Properties to set\n   */\n  function Gradient(properties) {\n    this.palette = []\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Gradient type.\n   * @member {number} type\n   * @memberof Gradient\n   * @instance\n   */\n  Gradient.prototype.type = 0\n\n  /**\n   * Gradient angle.\n   * @member {number} angle\n   * @memberof Gradient\n   * @instance\n   */\n  Gradient.prototype.angle = 0\n\n  /**\n   * Gradient palette.\n   * @member {Array.<IGradientColor>} palette\n   * @memberof Gradient\n   * @instance\n   */\n  Gradient.prototype.palette = $util.emptyArray\n\n  /**\n   * Creates a new Gradient instance using the specified properties.\n   * @function create\n   * @memberof Gradient\n   * @static\n   * @param {IGradient=} [properties] Properties to set\n   * @returns {Gradient} Gradient instance\n   */\n  Gradient.create = function create(properties) {\n    return new Gradient(properties)\n  }\n\n  /**\n   * Encodes the specified Gradient message. Does not implicitly {@link Gradient.verify|verify} messages.\n   * @function encode\n   * @memberof Gradient\n   * @static\n   * @param {IGradient} message Gradient message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Gradient.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.type != null && Object.hasOwnProperty.call(message, 'type'))\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.type)\n    if (message.angle != null && Object.hasOwnProperty.call(message, 'angle'))\n      writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.angle)\n    if (message.palette != null && message.palette.length)\n      for (let i = 0; i < message.palette.length; ++i)\n        $root.GradientColor.encode(\n          message.palette[i],\n          writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),\n        ).ldelim()\n    return writer\n  }\n\n  /**\n   * Encodes the specified Gradient message, length delimited. Does not implicitly {@link Gradient.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Gradient\n   * @static\n   * @param {IGradient} message Gradient message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Gradient.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Gradient message from the specified reader or buffer.\n   * @function decode\n   * @memberof Gradient\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Gradient} Gradient\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Gradient.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Gradient()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32()\n          break\n        case 2:\n          message.angle = reader.float()\n          break\n        case 3:\n          if (!(message.palette && message.palette.length)) message.palette = []\n          message.palette.push(\n            $root.GradientColor.decode(reader, reader.uint32()),\n          )\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Gradient message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Gradient\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Gradient} Gradient\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Gradient.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Gradient message.\n   * @function verify\n   * @memberof Gradient\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Gradient.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.type != null && message.hasOwnProperty('type'))\n      if (!$util.isInteger(message.type)) return 'type: integer expected'\n    if (message.angle != null && message.hasOwnProperty('angle'))\n      if (typeof message.angle !== 'number') return 'angle: number expected'\n    if (message.palette != null && message.hasOwnProperty('palette')) {\n      if (!Array.isArray(message.palette)) return 'palette: array expected'\n      for (let i = 0; i < message.palette.length; ++i) {\n        let error = $root.GradientColor.verify(message.palette[i])\n        if (error) return 'palette.' + error\n      }\n    }\n    return null\n  }\n\n  /**\n   * Creates a Gradient message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Gradient\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Gradient} Gradient\n   */\n  Gradient.fromObject = function fromObject(object) {\n    if (object instanceof $root.Gradient) return object\n    let message = new $root.Gradient()\n    if (object.type != null) message.type = object.type | 0\n    if (object.angle != null) message.angle = Number(object.angle)\n    if (object.palette) {\n      if (!Array.isArray(object.palette))\n        throw TypeError('.Gradient.palette: array expected')\n      message.palette = []\n      for (let i = 0; i < object.palette.length; ++i) {\n        if (typeof object.palette[i] !== 'object')\n          throw TypeError('.Gradient.palette: object expected')\n        message.palette[i] = $root.GradientColor.fromObject(object.palette[i])\n      }\n    }\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Gradient message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Gradient\n   * @static\n   * @param {Gradient} message Gradient\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Gradient.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.arrays || options.defaults) object.palette = []\n    if (options.defaults) {\n      object.type = 0\n      object.angle = 0\n    }\n    if (message.type != null && message.hasOwnProperty('type'))\n      object.type = message.type\n    if (message.angle != null && message.hasOwnProperty('angle'))\n      object.angle =\n        options.json && !isFinite(message.angle)\n          ? String(message.angle)\n          : message.angle\n    if (message.palette && message.palette.length) {\n      object.palette = []\n      for (let j = 0; j < message.palette.length; ++j)\n        object.palette[j] = $root.GradientColor.toObject(\n          message.palette[j],\n          options,\n        )\n    }\n    return object\n  }\n\n  /**\n   * Converts this Gradient to JSON.\n   * @function toJSON\n   * @memberof Gradient\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Gradient.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Gradient\n})())\n\nexport const PatternTexture = ($root.PatternTexture = (() => {\n  /**\n   * Properties of a PatternTexture.\n   * @exports IPatternTexture\n   * @interface IPatternTexture\n   * @property {Uint8Array|null} [buffer] PatternTexture buffer\n   * @property {number|null} [scale] PatternTexture scale\n   * @property {string|null} [repetition] PatternTexture repetition\n   */\n\n  /**\n   * Constructs a new PatternTexture.\n   * @exports PatternTexture\n   * @classdesc Represents a PatternTexture.\n   * @implements IPatternTexture\n   * @constructor\n   * @param {IPatternTexture=} [properties] Properties to set\n   */\n  function PatternTexture(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * PatternTexture buffer.\n   * @member {Uint8Array} buffer\n   * @memberof PatternTexture\n   * @instance\n   */\n  PatternTexture.prototype.buffer = $util.newBuffer([])\n\n  /**\n   * PatternTexture scale.\n   * @member {number} scale\n   * @memberof PatternTexture\n   * @instance\n   */\n  PatternTexture.prototype.scale = 0\n\n  /**\n   * PatternTexture repetition.\n   * @member {string} repetition\n   * @memberof PatternTexture\n   * @instance\n   */\n  PatternTexture.prototype.repetition = ''\n\n  /**\n   * Creates a new PatternTexture instance using the specified properties.\n   * @function create\n   * @memberof PatternTexture\n   * @static\n   * @param {IPatternTexture=} [properties] Properties to set\n   * @returns {PatternTexture} PatternTexture instance\n   */\n  PatternTexture.create = function create(properties) {\n    return new PatternTexture(properties)\n  }\n\n  /**\n   * Encodes the specified PatternTexture message. Does not implicitly {@link PatternTexture.verify|verify} messages.\n   * @function encode\n   * @memberof PatternTexture\n   * @static\n   * @param {IPatternTexture} message PatternTexture message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  PatternTexture.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.buffer != null && Object.hasOwnProperty.call(message, 'buffer'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.buffer)\n    if (message.scale != null && Object.hasOwnProperty.call(message, 'scale'))\n      writer.uint32(/* id 2, wireType 1 =*/ 17).double(message.scale)\n    if (\n      message.repetition != null &&\n      Object.hasOwnProperty.call(message, 'repetition')\n    )\n      writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.repetition)\n    return writer\n  }\n\n  /**\n   * Encodes the specified PatternTexture message, length delimited. Does not implicitly {@link PatternTexture.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof PatternTexture\n   * @static\n   * @param {IPatternTexture} message PatternTexture message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  PatternTexture.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a PatternTexture message from the specified reader or buffer.\n   * @function decode\n   * @memberof PatternTexture\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {PatternTexture} PatternTexture\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  PatternTexture.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.PatternTexture()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.buffer = reader.bytes()\n          break\n        case 2:\n          message.scale = reader.double()\n          break\n        case 3:\n          message.repetition = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a PatternTexture message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof PatternTexture\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {PatternTexture} PatternTexture\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  PatternTexture.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a PatternTexture message.\n   * @function verify\n   * @memberof PatternTexture\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  PatternTexture.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.buffer != null && message.hasOwnProperty('buffer'))\n      if (\n        !(\n          (message.buffer && typeof message.buffer.length === 'number') ||\n          $util.isString(message.buffer)\n        )\n      )\n        return 'buffer: buffer expected'\n    if (message.scale != null && message.hasOwnProperty('scale'))\n      if (typeof message.scale !== 'number') return 'scale: number expected'\n    if (message.repetition != null && message.hasOwnProperty('repetition'))\n      if (!$util.isString(message.repetition))\n        return 'repetition: string expected'\n    return null\n  }\n\n  /**\n   * Creates a PatternTexture message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof PatternTexture\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {PatternTexture} PatternTexture\n   */\n  PatternTexture.fromObject = function fromObject(object) {\n    if (object instanceof $root.PatternTexture) return object\n    let message = new $root.PatternTexture()\n    if (object.buffer != null)\n      if (typeof object.buffer === 'string')\n        $util.base64.decode(\n          object.buffer,\n          (message.buffer = $util.newBuffer(\n            $util.base64.length(object.buffer),\n          )),\n          0,\n        )\n      else if (object.buffer.length) message.buffer = object.buffer\n    if (object.scale != null) message.scale = Number(object.scale)\n    if (object.repetition != null)\n      message.repetition = String(object.repetition)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a PatternTexture message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof PatternTexture\n   * @static\n   * @param {PatternTexture} message PatternTexture\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  PatternTexture.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      if (options.bytes === String) object.buffer = ''\n      else {\n        object.buffer = []\n        if (options.bytes !== Array)\n          object.buffer = $util.newBuffer(object.buffer)\n      }\n      object.scale = 0\n      object.repetition = ''\n    }\n    if (message.buffer != null && message.hasOwnProperty('buffer'))\n      object.buffer =\n        options.bytes === String\n          ? $util.base64.encode(message.buffer, 0, message.buffer.length)\n          : options.bytes === Array\n          ? Array.prototype.slice.call(message.buffer)\n          : message.buffer\n    if (message.scale != null && message.hasOwnProperty('scale'))\n      object.scale =\n        options.json && !isFinite(message.scale)\n          ? String(message.scale)\n          : message.scale\n    if (message.repetition != null && message.hasOwnProperty('repetition'))\n      object.repetition = message.repetition\n    return object\n  }\n\n  /**\n   * Converts this PatternTexture to JSON.\n   * @function toJSON\n   * @memberof PatternTexture\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  PatternTexture.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return PatternTexture\n})())\n\nexport const Fill = ($root.Fill = (() => {\n  /**\n   * Properties of a Fill.\n   * @exports IFill\n   * @interface IFill\n   * @property {number|null} [type] Fill type\n   * @property {string|null} [color] Fill color\n   * @property {IGradient|null} [gradient] Fill gradient\n   * @property {IPatternTexture|null} [patternTexture] Fill patternTexture\n   * @property {number|null} [width] Fill width\n   * @property {string|null} [lineCap] Fill lineCap\n   * @property {string|null} [lineJoin] Fill lineJoin\n   */\n\n  /**\n   * Constructs a new Fill.\n   * @exports Fill\n   * @classdesc Represents a Fill.\n   * @implements IFill\n   * @constructor\n   * @param {IFill=} [properties] Properties to set\n   */\n  function Fill(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Fill type.\n   * @member {number} type\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.type = 0\n\n  /**\n   * Fill color.\n   * @member {string} color\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.color = ''\n\n  /**\n   * Fill gradient.\n   * @member {IGradient|null|undefined} gradient\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.gradient = null\n\n  /**\n   * Fill patternTexture.\n   * @member {IPatternTexture|null|undefined} patternTexture\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.patternTexture = null\n\n  /**\n   * Fill width.\n   * @member {number} width\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.width = 0\n\n  /**\n   * Fill lineCap.\n   * @member {string} lineCap\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.lineCap = ''\n\n  /**\n   * Fill lineJoin.\n   * @member {string} lineJoin\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.lineJoin = ''\n\n  /**\n   * Creates a new Fill instance using the specified properties.\n   * @function create\n   * @memberof Fill\n   * @static\n   * @param {IFill=} [properties] Properties to set\n   * @returns {Fill} Fill instance\n   */\n  Fill.create = function create(properties) {\n    return new Fill(properties)\n  }\n\n  /**\n   * Encodes the specified Fill message. Does not implicitly {@link Fill.verify|verify} messages.\n   * @function encode\n   * @memberof Fill\n   * @static\n   * @param {IFill} message Fill message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Fill.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.type != null && Object.hasOwnProperty.call(message, 'type'))\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.type)\n    if (message.color != null && Object.hasOwnProperty.call(message, 'color'))\n      writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.color)\n    if (\n      message.gradient != null &&\n      Object.hasOwnProperty.call(message, 'gradient')\n    )\n      $root.Gradient.encode(\n        message.gradient,\n        writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),\n      ).ldelim()\n    if (\n      message.patternTexture != null &&\n      Object.hasOwnProperty.call(message, 'patternTexture')\n    )\n      $root.PatternTexture.encode(\n        message.patternTexture,\n        writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),\n      ).ldelim()\n    if (message.width != null && Object.hasOwnProperty.call(message, 'width'))\n      writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.width)\n    if (\n      message.lineCap != null &&\n      Object.hasOwnProperty.call(message, 'lineCap')\n    )\n      writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.lineCap)\n    if (\n      message.lineJoin != null &&\n      Object.hasOwnProperty.call(message, 'lineJoin')\n    )\n      writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.lineJoin)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Fill message, length delimited. Does not implicitly {@link Fill.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Fill\n   * @static\n   * @param {IFill} message Fill message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Fill.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Fill message from the specified reader or buffer.\n   * @function decode\n   * @memberof Fill\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Fill} Fill\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Fill.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Fill()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32()\n          break\n        case 2:\n          message.color = reader.string()\n          break\n        case 3:\n          message.gradient = $root.Gradient.decode(reader, reader.uint32())\n          break\n        case 4:\n          message.patternTexture = $root.PatternTexture.decode(\n            reader,\n            reader.uint32(),\n          )\n          break\n        case 5:\n          message.width = reader.int32()\n          break\n        case 6:\n          message.lineCap = reader.string()\n          break\n        case 7:\n          message.lineJoin = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Fill message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Fill\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Fill} Fill\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Fill.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Fill message.\n   * @function verify\n   * @memberof Fill\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Fill.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.type != null && message.hasOwnProperty('type'))\n      if (!$util.isInteger(message.type)) return 'type: integer expected'\n    if (message.color != null && message.hasOwnProperty('color'))\n      if (!$util.isString(message.color)) return 'color: string expected'\n    if (message.gradient != null && message.hasOwnProperty('gradient')) {\n      let error = $root.Gradient.verify(message.gradient)\n      if (error) return 'gradient.' + error\n    }\n    if (\n      message.patternTexture != null &&\n      message.hasOwnProperty('patternTexture')\n    ) {\n      let error = $root.PatternTexture.verify(message.patternTexture)\n      if (error) return 'patternTexture.' + error\n    }\n    if (message.width != null && message.hasOwnProperty('width'))\n      if (!$util.isInteger(message.width)) return 'width: integer expected'\n    if (message.lineCap != null && message.hasOwnProperty('lineCap'))\n      if (!$util.isString(message.lineCap)) return 'lineCap: string expected'\n    if (message.lineJoin != null && message.hasOwnProperty('lineJoin'))\n      if (!$util.isString(message.lineJoin)) return 'lineJoin: string expected'\n    return null\n  }\n\n  /**\n   * Creates a Fill message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Fill\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Fill} Fill\n   */\n  Fill.fromObject = function fromObject(object) {\n    if (object instanceof $root.Fill) return object\n    let message = new $root.Fill()\n    if (object.type != null) message.type = object.type | 0\n    if (object.color != null) message.color = String(object.color)\n    if (object.gradient != null) {\n      if (typeof object.gradient !== 'object')\n        throw TypeError('.Fill.gradient: object expected')\n      message.gradient = $root.Gradient.fromObject(object.gradient)\n    }\n    if (object.patternTexture != null) {\n      if (typeof object.patternTexture !== 'object')\n        throw TypeError('.Fill.patternTexture: object expected')\n      message.patternTexture = $root.PatternTexture.fromObject(\n        object.patternTexture,\n      )\n    }\n    if (object.width != null) message.width = object.width | 0\n    if (object.lineCap != null) message.lineCap = String(object.lineCap)\n    if (object.lineJoin != null) message.lineJoin = String(object.lineJoin)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Fill message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Fill\n   * @static\n   * @param {Fill} message Fill\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Fill.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.type = 0\n      object.color = ''\n      object.gradient = null\n      object.patternTexture = null\n      object.width = 0\n      object.lineCap = ''\n      object.lineJoin = ''\n    }\n    if (message.type != null && message.hasOwnProperty('type'))\n      object.type = message.type\n    if (message.color != null && message.hasOwnProperty('color'))\n      object.color = message.color\n    if (message.gradient != null && message.hasOwnProperty('gradient'))\n      object.gradient = $root.Gradient.toObject(message.gradient, options)\n    if (\n      message.patternTexture != null &&\n      message.hasOwnProperty('patternTexture')\n    )\n      object.patternTexture = $root.PatternTexture.toObject(\n        message.patternTexture,\n        options,\n      )\n    if (message.width != null && message.hasOwnProperty('width'))\n      object.width = message.width\n    if (message.lineCap != null && message.hasOwnProperty('lineCap'))\n      object.lineCap = message.lineCap\n    if (message.lineJoin != null && message.hasOwnProperty('lineJoin'))\n      object.lineJoin = message.lineJoin\n    return object\n  }\n\n  /**\n   * Converts this Fill to JSON.\n   * @function toJSON\n   * @memberof Fill\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Fill.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Fill\n})())\n\nexport const Font = ($root.Font = (() => {\n  /**\n   * Properties of a Font.\n   * @exports IFont\n   * @interface IFont\n   * @property {Uint8Array|null} [font] Font font\n   * @property {string|null} [family] Font family\n   * @property {number|null} [size] Font size\n   * @property {number|null} [lineHeight] Font lineHeight\n   */\n\n  /**\n   * Constructs a new Font.\n   * @exports Font\n   * @classdesc Represents a Font.\n   * @implements IFont\n   * @constructor\n   * @param {IFont=} [properties] Properties to set\n   */\n  function Font(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Font font.\n   * @member {Uint8Array} font\n   * @memberof Font\n   * @instance\n   */\n  Font.prototype.font = $util.newBuffer([])\n\n  /**\n   * Font family.\n   * @member {string} family\n   * @memberof Font\n   * @instance\n   */\n  Font.prototype.family = ''\n\n  /**\n   * Font size.\n   * @member {number} size\n   * @memberof Font\n   * @instance\n   */\n  Font.prototype.size = 0\n\n  /**\n   * Font lineHeight.\n   * @member {number} lineHeight\n   * @memberof Font\n   * @instance\n   */\n  Font.prototype.lineHeight = 0\n\n  /**\n   * Creates a new Font instance using the specified properties.\n   * @function create\n   * @memberof Font\n   * @static\n   * @param {IFont=} [properties] Properties to set\n   * @returns {Font} Font instance\n   */\n  Font.create = function create(properties) {\n    return new Font(properties)\n  }\n\n  /**\n   * Encodes the specified Font message. Does not implicitly {@link Font.verify|verify} messages.\n   * @function encode\n   * @memberof Font\n   * @static\n   * @param {IFont} message Font message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Font.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.font != null && Object.hasOwnProperty.call(message, 'font'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.font)\n    if (message.family != null && Object.hasOwnProperty.call(message, 'family'))\n      writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.family)\n    if (message.size != null && Object.hasOwnProperty.call(message, 'size'))\n      writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.size)\n    if (\n      message.lineHeight != null &&\n      Object.hasOwnProperty.call(message, 'lineHeight')\n    )\n      writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.lineHeight)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Font message, length delimited. Does not implicitly {@link Font.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Font\n   * @static\n   * @param {IFont} message Font message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Font.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Font message from the specified reader or buffer.\n   * @function decode\n   * @memberof Font\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Font} Font\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Font.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Font()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.font = reader.bytes()\n          break\n        case 2:\n          message.family = reader.string()\n          break\n        case 3:\n          message.size = reader.int32()\n          break\n        case 4:\n          message.lineHeight = reader.int32()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Font message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Font\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Font} Font\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Font.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Font message.\n   * @function verify\n   * @memberof Font\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Font.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.font != null && message.hasOwnProperty('font'))\n      if (\n        !(\n          (message.font && typeof message.font.length === 'number') ||\n          $util.isString(message.font)\n        )\n      )\n        return 'font: buffer expected'\n    if (message.family != null && message.hasOwnProperty('family'))\n      if (!$util.isString(message.family)) return 'family: string expected'\n    if (message.size != null && message.hasOwnProperty('size'))\n      if (!$util.isInteger(message.size)) return 'size: integer expected'\n    if (message.lineHeight != null && message.hasOwnProperty('lineHeight'))\n      if (!$util.isInteger(message.lineHeight))\n        return 'lineHeight: integer expected'\n    return null\n  }\n\n  /**\n   * Creates a Font message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Font\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Font} Font\n   */\n  Font.fromObject = function fromObject(object) {\n    if (object instanceof $root.Font) return object\n    let message = new $root.Font()\n    if (object.font != null)\n      if (typeof object.font === 'string')\n        $util.base64.decode(\n          object.font,\n          (message.font = $util.newBuffer($util.base64.length(object.font))),\n          0,\n        )\n      else if (object.font.length) message.font = object.font\n    if (object.family != null) message.family = String(object.family)\n    if (object.size != null) message.size = object.size | 0\n    if (object.lineHeight != null) message.lineHeight = object.lineHeight | 0\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Font message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Font\n   * @static\n   * @param {Font} message Font\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Font.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      if (options.bytes === String) object.font = ''\n      else {\n        object.font = []\n        if (options.bytes !== Array) object.font = $util.newBuffer(object.font)\n      }\n      object.family = ''\n      object.size = 0\n      object.lineHeight = 0\n    }\n    if (message.font != null && message.hasOwnProperty('font'))\n      object.font =\n        options.bytes === String\n          ? $util.base64.encode(message.font, 0, message.font.length)\n          : options.bytes === Array\n          ? Array.prototype.slice.call(message.font)\n          : message.font\n    if (message.family != null && message.hasOwnProperty('family'))\n      object.family = message.family\n    if (message.size != null && message.hasOwnProperty('size'))\n      object.size = message.size\n    if (message.lineHeight != null && message.hasOwnProperty('lineHeight'))\n      object.lineHeight = message.lineHeight\n    return object\n  }\n\n  /**\n   * Converts this Font to JSON.\n   * @function toJSON\n   * @memberof Font\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Font.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Font\n})())\n\nexport const GlyphFont = ($root.GlyphFont = (() => {\n  /**\n   * Properties of a GlyphFont.\n   * @exports IGlyphFont\n   * @interface IGlyphFont\n   * @property {string|null} [letter] GlyphFont letter\n   * @property {IMetric|null} [adjustMetric] GlyphFont adjustMetric\n   * @property {Object.<string,number>|null} [kerning] GlyphFont kerning\n   */\n\n  /**\n   * Constructs a new GlyphFont.\n   * @exports GlyphFont\n   * @classdesc Represents a GlyphFont.\n   * @implements IGlyphFont\n   * @constructor\n   * @param {IGlyphFont=} [properties] Properties to set\n   */\n  function GlyphFont(properties) {\n    this.kerning = {}\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * GlyphFont letter.\n   * @member {string} letter\n   * @memberof GlyphFont\n   * @instance\n   */\n  GlyphFont.prototype.letter = ''\n\n  /**\n   * GlyphFont adjustMetric.\n   * @member {IMetric|null|undefined} adjustMetric\n   * @memberof GlyphFont\n   * @instance\n   */\n  GlyphFont.prototype.adjustMetric = null\n\n  /**\n   * GlyphFont kerning.\n   * @member {Object.<string,number>} kerning\n   * @memberof GlyphFont\n   * @instance\n   */\n  GlyphFont.prototype.kerning = $util.emptyObject\n\n  /**\n   * Creates a new GlyphFont instance using the specified properties.\n   * @function create\n   * @memberof GlyphFont\n   * @static\n   * @param {IGlyphFont=} [properties] Properties to set\n   * @returns {GlyphFont} GlyphFont instance\n   */\n  GlyphFont.create = function create(properties) {\n    return new GlyphFont(properties)\n  }\n\n  /**\n   * Encodes the specified GlyphFont message. Does not implicitly {@link GlyphFont.verify|verify} messages.\n   * @function encode\n   * @memberof GlyphFont\n   * @static\n   * @param {IGlyphFont} message GlyphFont message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GlyphFont.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.letter != null && Object.hasOwnProperty.call(message, 'letter'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.letter)\n    if (\n      message.adjustMetric != null &&\n      Object.hasOwnProperty.call(message, 'adjustMetric')\n    )\n      $root.Metric.encode(\n        message.adjustMetric,\n        writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n      ).ldelim()\n    if (\n      message.kerning != null &&\n      Object.hasOwnProperty.call(message, 'kerning')\n    )\n      for (let keys = Object.keys(message.kerning), i = 0; i < keys.length; ++i)\n        writer\n          .uint32(/* id 3, wireType 2 =*/ 26)\n          .fork()\n          .uint32(/* id 1, wireType 2 =*/ 10)\n          .string(keys[i])\n          .uint32(/* id 2, wireType 0 =*/ 16)\n          .int32(message.kerning[keys[i]])\n          .ldelim()\n    return writer\n  }\n\n  /**\n   * Encodes the specified GlyphFont message, length delimited. Does not implicitly {@link GlyphFont.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof GlyphFont\n   * @static\n   * @param {IGlyphFont} message GlyphFont message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GlyphFont.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a GlyphFont message from the specified reader or buffer.\n   * @function decode\n   * @memberof GlyphFont\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {GlyphFont} GlyphFont\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GlyphFont.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.GlyphFont(),\n      key,\n      value\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.letter = reader.string()\n          break\n        case 2:\n          message.adjustMetric = $root.Metric.decode(reader, reader.uint32())\n          break\n        case 3:\n          if (message.kerning === $util.emptyObject) message.kerning = {}\n          let end2 = reader.uint32() + reader.pos\n          key = ''\n          value = 0\n          while (reader.pos < end2) {\n            let tag2 = reader.uint32()\n            switch (tag2 >>> 3) {\n              case 1:\n                key = reader.string()\n                break\n              case 2:\n                value = reader.int32()\n                break\n              default:\n                reader.skipType(tag2 & 7)\n                break\n            }\n          }\n          message.kerning[key] = value\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a GlyphFont message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof GlyphFont\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {GlyphFont} GlyphFont\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GlyphFont.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a GlyphFont message.\n   * @function verify\n   * @memberof GlyphFont\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  GlyphFont.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.letter != null && message.hasOwnProperty('letter'))\n      if (!$util.isString(message.letter)) return 'letter: string expected'\n    if (\n      message.adjustMetric != null &&\n      message.hasOwnProperty('adjustMetric')\n    ) {\n      let error = $root.Metric.verify(message.adjustMetric)\n      if (error) return 'adjustMetric.' + error\n    }\n    if (message.kerning != null && message.hasOwnProperty('kerning')) {\n      if (!$util.isObject(message.kerning)) return 'kerning: object expected'\n      let key = Object.keys(message.kerning)\n      for (let i = 0; i < key.length; ++i)\n        if (!$util.isInteger(message.kerning[key[i]]))\n          return 'kerning: integer{k:string} expected'\n    }\n    return null\n  }\n\n  /**\n   * Creates a GlyphFont message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof GlyphFont\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {GlyphFont} GlyphFont\n   */\n  GlyphFont.fromObject = function fromObject(object) {\n    if (object instanceof $root.GlyphFont) return object\n    let message = new $root.GlyphFont()\n    if (object.letter != null) message.letter = String(object.letter)\n    if (object.adjustMetric != null) {\n      if (typeof object.adjustMetric !== 'object')\n        throw TypeError('.GlyphFont.adjustMetric: object expected')\n      message.adjustMetric = $root.Metric.fromObject(object.adjustMetric)\n    }\n    if (object.kerning) {\n      if (typeof object.kerning !== 'object')\n        throw TypeError('.GlyphFont.kerning: object expected')\n      message.kerning = {}\n      for (let keys = Object.keys(object.kerning), i = 0; i < keys.length; ++i)\n        message.kerning[keys[i]] = object.kerning[keys[i]] | 0\n    }\n    return message\n  }\n\n  /**\n   * Creates a plain object from a GlyphFont message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof GlyphFont\n   * @static\n   * @param {GlyphFont} message GlyphFont\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  GlyphFont.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.objects || options.defaults) object.kerning = {}\n    if (options.defaults) {\n      object.letter = ''\n      object.adjustMetric = null\n    }\n    if (message.letter != null && message.hasOwnProperty('letter'))\n      object.letter = message.letter\n    if (message.adjustMetric != null && message.hasOwnProperty('adjustMetric'))\n      object.adjustMetric = $root.Metric.toObject(message.adjustMetric, options)\n    let keys2\n    if (message.kerning && (keys2 = Object.keys(message.kerning)).length) {\n      object.kerning = {}\n      for (let j = 0; j < keys2.length; ++j)\n        object.kerning[keys2[j]] = message.kerning[keys2[j]]\n    }\n    return object\n  }\n\n  /**\n   * Converts this GlyphFont to JSON.\n   * @function toJSON\n   * @memberof GlyphFont\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  GlyphFont.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return GlyphFont\n})())\n\nexport const GlyphImage = ($root.GlyphImage = (() => {\n  /**\n   * Properties of a GlyphImage.\n   * @exports IGlyphImage\n   * @interface IGlyphImage\n   * @property {string|null} [letter] GlyphImage letter\n   * @property {IMetric|null} [adjustMetric] GlyphImage adjustMetric\n   * @property {Uint8Array|null} [buffer] GlyphImage buffer\n   * @property {string|null} [fileName] GlyphImage fileName\n   * @property {string|null} [fileType] GlyphImage fileType\n   * @property {boolean|null} [selected] GlyphImage selected\n   * @property {Object.<string,number>|null} [kerning] GlyphImage kerning\n   */\n\n  /**\n   * Constructs a new GlyphImage.\n   * @exports GlyphImage\n   * @classdesc Represents a GlyphImage.\n   * @implements IGlyphImage\n   * @constructor\n   * @param {IGlyphImage=} [properties] Properties to set\n   */\n  function GlyphImage(properties) {\n    this.kerning = {}\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * GlyphImage letter.\n   * @member {string} letter\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.letter = ''\n\n  /**\n   * GlyphImage adjustMetric.\n   * @member {IMetric|null|undefined} adjustMetric\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.adjustMetric = null\n\n  /**\n   * GlyphImage buffer.\n   * @member {Uint8Array} buffer\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.buffer = $util.newBuffer([])\n\n  /**\n   * GlyphImage fileName.\n   * @member {string} fileName\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.fileName = ''\n\n  /**\n   * GlyphImage fileType.\n   * @member {string} fileType\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.fileType = ''\n\n  /**\n   * GlyphImage selected.\n   * @member {boolean} selected\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.selected = false\n\n  /**\n   * GlyphImage kerning.\n   * @member {Object.<string,number>} kerning\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.kerning = $util.emptyObject\n\n  /**\n   * Creates a new GlyphImage instance using the specified properties.\n   * @function create\n   * @memberof GlyphImage\n   * @static\n   * @param {IGlyphImage=} [properties] Properties to set\n   * @returns {GlyphImage} GlyphImage instance\n   */\n  GlyphImage.create = function create(properties) {\n    return new GlyphImage(properties)\n  }\n\n  /**\n   * Encodes the specified GlyphImage message. Does not implicitly {@link GlyphImage.verify|verify} messages.\n   * @function encode\n   * @memberof GlyphImage\n   * @static\n   * @param {IGlyphImage} message GlyphImage message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GlyphImage.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.letter != null && Object.hasOwnProperty.call(message, 'letter'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.letter)\n    if (\n      message.adjustMetric != null &&\n      Object.hasOwnProperty.call(message, 'adjustMetric')\n    )\n      $root.Metric.encode(\n        message.adjustMetric,\n        writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n      ).ldelim()\n    if (message.buffer != null && Object.hasOwnProperty.call(message, 'buffer'))\n      writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.buffer)\n    if (\n      message.fileName != null &&\n      Object.hasOwnProperty.call(message, 'fileName')\n    )\n      writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.fileName)\n    if (\n      message.fileType != null &&\n      Object.hasOwnProperty.call(message, 'fileType')\n    )\n      writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.fileType)\n    if (\n      message.selected != null &&\n      Object.hasOwnProperty.call(message, 'selected')\n    )\n      writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.selected)\n    if (\n      message.kerning != null &&\n      Object.hasOwnProperty.call(message, 'kerning')\n    )\n      for (let keys = Object.keys(message.kerning), i = 0; i < keys.length; ++i)\n        writer\n          .uint32(/* id 7, wireType 2 =*/ 58)\n          .fork()\n          .uint32(/* id 1, wireType 2 =*/ 10)\n          .string(keys[i])\n          .uint32(/* id 2, wireType 0 =*/ 16)\n          .int32(message.kerning[keys[i]])\n          .ldelim()\n    return writer\n  }\n\n  /**\n   * Encodes the specified GlyphImage message, length delimited. Does not implicitly {@link GlyphImage.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof GlyphImage\n   * @static\n   * @param {IGlyphImage} message GlyphImage message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GlyphImage.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a GlyphImage message from the specified reader or buffer.\n   * @function decode\n   * @memberof GlyphImage\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {GlyphImage} GlyphImage\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GlyphImage.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.GlyphImage(),\n      key,\n      value\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.letter = reader.string()\n          break\n        case 2:\n          message.adjustMetric = $root.Metric.decode(reader, reader.uint32())\n          break\n        case 3:\n          message.buffer = reader.bytes()\n          break\n        case 4:\n          message.fileName = reader.string()\n          break\n        case 5:\n          message.fileType = reader.string()\n          break\n        case 6:\n          message.selected = reader.bool()\n          break\n        case 7:\n          if (message.kerning === $util.emptyObject) message.kerning = {}\n          let end2 = reader.uint32() + reader.pos\n          key = ''\n          value = 0\n          while (reader.pos < end2) {\n            let tag2 = reader.uint32()\n            switch (tag2 >>> 3) {\n              case 1:\n                key = reader.string()\n                break\n              case 2:\n                value = reader.int32()\n                break\n              default:\n                reader.skipType(tag2 & 7)\n                break\n            }\n          }\n          message.kerning[key] = value\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a GlyphImage message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof GlyphImage\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {GlyphImage} GlyphImage\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GlyphImage.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a GlyphImage message.\n   * @function verify\n   * @memberof GlyphImage\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  GlyphImage.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.letter != null && message.hasOwnProperty('letter'))\n      if (!$util.isString(message.letter)) return 'letter: string expected'\n    if (\n      message.adjustMetric != null &&\n      message.hasOwnProperty('adjustMetric')\n    ) {\n      let error = $root.Metric.verify(message.adjustMetric)\n      if (error) return 'adjustMetric.' + error\n    }\n    if (message.buffer != null && message.hasOwnProperty('buffer'))\n      if (\n        !(\n          (message.buffer && typeof message.buffer.length === 'number') ||\n          $util.isString(message.buffer)\n        )\n      )\n        return 'buffer: buffer expected'\n    if (message.fileName != null && message.hasOwnProperty('fileName'))\n      if (!$util.isString(message.fileName)) return 'fileName: string expected'\n    if (message.fileType != null && message.hasOwnProperty('fileType'))\n      if (!$util.isString(message.fileType)) return 'fileType: string expected'\n    if (message.selected != null && message.hasOwnProperty('selected'))\n      if (typeof message.selected !== 'boolean')\n        return 'selected: boolean expected'\n    if (message.kerning != null && message.hasOwnProperty('kerning')) {\n      if (!$util.isObject(message.kerning)) return 'kerning: object expected'\n      let key = Object.keys(message.kerning)\n      for (let i = 0; i < key.length; ++i)\n        if (!$util.isInteger(message.kerning[key[i]]))\n          return 'kerning: integer{k:string} expected'\n    }\n    return null\n  }\n\n  /**\n   * Creates a GlyphImage message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof GlyphImage\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {GlyphImage} GlyphImage\n   */\n  GlyphImage.fromObject = function fromObject(object) {\n    if (object instanceof $root.GlyphImage) return object\n    let message = new $root.GlyphImage()\n    if (object.letter != null) message.letter = String(object.letter)\n    if (object.adjustMetric != null) {\n      if (typeof object.adjustMetric !== 'object')\n        throw TypeError('.GlyphImage.adjustMetric: object expected')\n      message.adjustMetric = $root.Metric.fromObject(object.adjustMetric)\n    }\n    if (object.buffer != null)\n      if (typeof object.buffer === 'string')\n        $util.base64.decode(\n          object.buffer,\n          (message.buffer = $util.newBuffer(\n            $util.base64.length(object.buffer),\n          )),\n          0,\n        )\n      else if (object.buffer.length) message.buffer = object.buffer\n    if (object.fileName != null) message.fileName = String(object.fileName)\n    if (object.fileType != null) message.fileType = String(object.fileType)\n    if (object.selected != null) message.selected = Boolean(object.selected)\n    if (object.kerning) {\n      if (typeof object.kerning !== 'object')\n        throw TypeError('.GlyphImage.kerning: object expected')\n      message.kerning = {}\n      for (let keys = Object.keys(object.kerning), i = 0; i < keys.length; ++i)\n        message.kerning[keys[i]] = object.kerning[keys[i]] | 0\n    }\n    return message\n  }\n\n  /**\n   * Creates a plain object from a GlyphImage message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof GlyphImage\n   * @static\n   * @param {GlyphImage} message GlyphImage\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  GlyphImage.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.objects || options.defaults) object.kerning = {}\n    if (options.defaults) {\n      object.letter = ''\n      object.adjustMetric = null\n      if (options.bytes === String) object.buffer = ''\n      else {\n        object.buffer = []\n        if (options.bytes !== Array)\n          object.buffer = $util.newBuffer(object.buffer)\n      }\n      object.fileName = ''\n      object.fileType = ''\n      object.selected = false\n    }\n    if (message.letter != null && message.hasOwnProperty('letter'))\n      object.letter = message.letter\n    if (message.adjustMetric != null && message.hasOwnProperty('adjustMetric'))\n      object.adjustMetric = $root.Metric.toObject(message.adjustMetric, options)\n    if (message.buffer != null && message.hasOwnProperty('buffer'))\n      object.buffer =\n        options.bytes === String\n          ? $util.base64.encode(message.buffer, 0, message.buffer.length)\n          : options.bytes === Array\n          ? Array.prototype.slice.call(message.buffer)\n          : message.buffer\n    if (message.fileName != null && message.hasOwnProperty('fileName'))\n      object.fileName = message.fileName\n    if (message.fileType != null && message.hasOwnProperty('fileType'))\n      object.fileType = message.fileType\n    if (message.selected != null && message.hasOwnProperty('selected'))\n      object.selected = message.selected\n    let keys2\n    if (message.kerning && (keys2 = Object.keys(message.kerning)).length) {\n      object.kerning = {}\n      for (let j = 0; j < keys2.length; ++j)\n        object.kerning[keys2[j]] = message.kerning[keys2[j]]\n    }\n    return object\n  }\n\n  /**\n   * Converts this GlyphImage to JSON.\n   * @function toJSON\n   * @memberof GlyphImage\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  GlyphImage.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return GlyphImage\n})())\n\nexport const Layout = ($root.Layout = (() => {\n  /**\n   * Properties of a Layout.\n   * @exports ILayout\n   * @interface ILayout\n   * @property {number|null} [padding] Layout padding\n   * @property {number|null} [spacing] Layout spacing\n   * @property {number|null} [width] Layout width\n   * @property {number|null} [height] Layout height\n   * @property {boolean|null} [auto] Layout auto\n   * @property {boolean|null} [fixedSize] Layout fixedSize\n   */\n\n  /**\n   * Constructs a new Layout.\n   * @exports Layout\n   * @classdesc Represents a Layout.\n   * @implements ILayout\n   * @constructor\n   * @param {ILayout=} [properties] Properties to set\n   */\n  function Layout(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Layout padding.\n   * @member {number} padding\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.padding = 0\n\n  /**\n   * Layout spacing.\n   * @member {number} spacing\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.spacing = 0\n\n  /**\n   * Layout width.\n   * @member {number} width\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.width = 0\n\n  /**\n   * Layout height.\n   * @member {number} height\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.height = 0\n\n  /**\n   * Layout auto.\n   * @member {boolean} auto\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.auto = false\n\n  /**\n   * Layout fixedSize.\n   * @member {boolean} fixedSize\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.fixedSize = false\n\n  /**\n   * Creates a new Layout instance using the specified properties.\n   * @function create\n   * @memberof Layout\n   * @static\n   * @param {ILayout=} [properties] Properties to set\n   * @returns {Layout} Layout instance\n   */\n  Layout.create = function create(properties) {\n    return new Layout(properties)\n  }\n\n  /**\n   * Encodes the specified Layout message. Does not implicitly {@link Layout.verify|verify} messages.\n   * @function encode\n   * @memberof Layout\n   * @static\n   * @param {ILayout} message Layout message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Layout.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (\n      message.padding != null &&\n      Object.hasOwnProperty.call(message, 'padding')\n    )\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.padding)\n    if (\n      message.spacing != null &&\n      Object.hasOwnProperty.call(message, 'spacing')\n    )\n      writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.spacing)\n    if (message.width != null && Object.hasOwnProperty.call(message, 'width'))\n      writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.width)\n    if (message.height != null && Object.hasOwnProperty.call(message, 'height'))\n      writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.height)\n    if (message.auto != null && Object.hasOwnProperty.call(message, 'auto'))\n      writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.auto)\n    if (\n      message.fixedSize != null &&\n      Object.hasOwnProperty.call(message, 'fixedSize')\n    )\n      writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.fixedSize)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Layout message, length delimited. Does not implicitly {@link Layout.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Layout\n   * @static\n   * @param {ILayout} message Layout message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Layout.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Layout message from the specified reader or buffer.\n   * @function decode\n   * @memberof Layout\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Layout} Layout\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Layout.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Layout()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.padding = reader.int32()\n          break\n        case 2:\n          message.spacing = reader.int32()\n          break\n        case 3:\n          message.width = reader.int32()\n          break\n        case 4:\n          message.height = reader.int32()\n          break\n        case 5:\n          message.auto = reader.bool()\n          break\n        case 6:\n          message.fixedSize = reader.bool()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Layout message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Layout\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Layout} Layout\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Layout.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Layout message.\n   * @function verify\n   * @memberof Layout\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Layout.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.padding != null && message.hasOwnProperty('padding'))\n      if (!$util.isInteger(message.padding)) return 'padding: integer expected'\n    if (message.spacing != null && message.hasOwnProperty('spacing'))\n      if (!$util.isInteger(message.spacing)) return 'spacing: integer expected'\n    if (message.width != null && message.hasOwnProperty('width'))\n      if (!$util.isInteger(message.width)) return 'width: integer expected'\n    if (message.height != null && message.hasOwnProperty('height'))\n      if (!$util.isInteger(message.height)) return 'height: integer expected'\n    if (message.auto != null && message.hasOwnProperty('auto'))\n      if (typeof message.auto !== 'boolean') return 'auto: boolean expected'\n    if (message.fixedSize != null && message.hasOwnProperty('fixedSize'))\n      if (typeof message.fixedSize !== 'boolean')\n        return 'fixedSize: boolean expected'\n    return null\n  }\n\n  /**\n   * Creates a Layout message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Layout\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Layout} Layout\n   */\n  Layout.fromObject = function fromObject(object) {\n    if (object instanceof $root.Layout) return object\n    let message = new $root.Layout()\n    if (object.padding != null) message.padding = object.padding | 0\n    if (object.spacing != null) message.spacing = object.spacing | 0\n    if (object.width != null) message.width = object.width | 0\n    if (object.height != null) message.height = object.height | 0\n    if (object.auto != null) message.auto = Boolean(object.auto)\n    if (object.fixedSize != null) message.fixedSize = Boolean(object.fixedSize)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Layout message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Layout\n   * @static\n   * @param {Layout} message Layout\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Layout.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.padding = 0\n      object.spacing = 0\n      object.width = 0\n      object.height = 0\n      object.auto = false\n      object.fixedSize = false\n    }\n    if (message.padding != null && message.hasOwnProperty('padding'))\n      object.padding = message.padding\n    if (message.spacing != null && message.hasOwnProperty('spacing'))\n      object.spacing = message.spacing\n    if (message.width != null && message.hasOwnProperty('width'))\n      object.width = message.width\n    if (message.height != null && message.hasOwnProperty('height'))\n      object.height = message.height\n    if (message.auto != null && message.hasOwnProperty('auto'))\n      object.auto = message.auto\n    if (message.fixedSize != null && message.hasOwnProperty('fixedSize'))\n      object.fixedSize = message.fixedSize\n    return object\n  }\n\n  /**\n   * Converts this Layout to JSON.\n   * @function toJSON\n   * @memberof Layout\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Layout.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Layout\n})())\n\nexport const Shadow = ($root.Shadow = (() => {\n  /**\n   * Properties of a Shadow.\n   * @exports IShadow\n   * @interface IShadow\n   * @property {string|null} [color] Shadow color\n   * @property {number|null} [blur] Shadow blur\n   * @property {number|null} [offsetX] Shadow offsetX\n   * @property {number|null} [offsetY] Shadow offsetY\n   */\n\n  /**\n   * Constructs a new Shadow.\n   * @exports Shadow\n   * @classdesc Represents a Shadow.\n   * @implements IShadow\n   * @constructor\n   * @param {IShadow=} [properties] Properties to set\n   */\n  function Shadow(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Shadow color.\n   * @member {string} color\n   * @memberof Shadow\n   * @instance\n   */\n  Shadow.prototype.color = ''\n\n  /**\n   * Shadow blur.\n   * @member {number} blur\n   * @memberof Shadow\n   * @instance\n   */\n  Shadow.prototype.blur = 0\n\n  /**\n   * Shadow offsetX.\n   * @member {number} offsetX\n   * @memberof Shadow\n   * @instance\n   */\n  Shadow.prototype.offsetX = 0\n\n  /**\n   * Shadow offsetY.\n   * @member {number} offsetY\n   * @memberof Shadow\n   * @instance\n   */\n  Shadow.prototype.offsetY = 0\n\n  /**\n   * Creates a new Shadow instance using the specified properties.\n   * @function create\n   * @memberof Shadow\n   * @static\n   * @param {IShadow=} [properties] Properties to set\n   * @returns {Shadow} Shadow instance\n   */\n  Shadow.create = function create(properties) {\n    return new Shadow(properties)\n  }\n\n  /**\n   * Encodes the specified Shadow message. Does not implicitly {@link Shadow.verify|verify} messages.\n   * @function encode\n   * @memberof Shadow\n   * @static\n   * @param {IShadow} message Shadow message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Shadow.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.color != null && Object.hasOwnProperty.call(message, 'color'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.color)\n    if (message.blur != null && Object.hasOwnProperty.call(message, 'blur'))\n      writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.blur)\n    if (\n      message.offsetX != null &&\n      Object.hasOwnProperty.call(message, 'offsetX')\n    )\n      writer.uint32(/* id 3, wireType 0 =*/ 24).sint32(message.offsetX)\n    if (\n      message.offsetY != null &&\n      Object.hasOwnProperty.call(message, 'offsetY')\n    )\n      writer.uint32(/* id 4, wireType 0 =*/ 32).sint32(message.offsetY)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Shadow message, length delimited. Does not implicitly {@link Shadow.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Shadow\n   * @static\n   * @param {IShadow} message Shadow message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Shadow.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Shadow message from the specified reader or buffer.\n   * @function decode\n   * @memberof Shadow\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Shadow} Shadow\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Shadow.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Shadow()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.color = reader.string()\n          break\n        case 2:\n          message.blur = reader.int32()\n          break\n        case 3:\n          message.offsetX = reader.sint32()\n          break\n        case 4:\n          message.offsetY = reader.sint32()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Shadow message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Shadow\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Shadow} Shadow\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Shadow.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Shadow message.\n   * @function verify\n   * @memberof Shadow\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Shadow.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.color != null && message.hasOwnProperty('color'))\n      if (!$util.isString(message.color)) return 'color: string expected'\n    if (message.blur != null && message.hasOwnProperty('blur'))\n      if (!$util.isInteger(message.blur)) return 'blur: integer expected'\n    if (message.offsetX != null && message.hasOwnProperty('offsetX'))\n      if (!$util.isInteger(message.offsetX)) return 'offsetX: integer expected'\n    if (message.offsetY != null && message.hasOwnProperty('offsetY'))\n      if (!$util.isInteger(message.offsetY)) return 'offsetY: integer expected'\n    return null\n  }\n\n  /**\n   * Creates a Shadow message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Shadow\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Shadow} Shadow\n   */\n  Shadow.fromObject = function fromObject(object) {\n    if (object instanceof $root.Shadow) return object\n    let message = new $root.Shadow()\n    if (object.color != null) message.color = String(object.color)\n    if (object.blur != null) message.blur = object.blur | 0\n    if (object.offsetX != null) message.offsetX = object.offsetX | 0\n    if (object.offsetY != null) message.offsetY = object.offsetY | 0\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Shadow message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Shadow\n   * @static\n   * @param {Shadow} message Shadow\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Shadow.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.color = ''\n      object.blur = 0\n      object.offsetX = 0\n      object.offsetY = 0\n    }\n    if (message.color != null && message.hasOwnProperty('color'))\n      object.color = message.color\n    if (message.blur != null && message.hasOwnProperty('blur'))\n      object.blur = message.blur\n    if (message.offsetX != null && message.hasOwnProperty('offsetX'))\n      object.offsetX = message.offsetX\n    if (message.offsetY != null && message.hasOwnProperty('offsetY'))\n      object.offsetY = message.offsetY\n    return object\n  }\n\n  /**\n   * Converts this Shadow to JSON.\n   * @function toJSON\n   * @memberof Shadow\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Shadow.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Shadow\n})())\n\nexport const Style = ($root.Style = (() => {\n  /**\n   * Properties of a Style.\n   * @exports IStyle\n   * @interface IStyle\n   * @property {IFont|null} [font] Style font\n   * @property {IFill|null} [fill] Style fill\n   * @property {boolean|null} [useStroke] Style useStroke\n   * @property {IFill|null} [stroke] Style stroke\n   * @property {boolean|null} [useShadow] Style useShadow\n   * @property {IShadow|null} [shadow] Style shadow\n   * @property {string|null} [bgColor] Style bgColor\n   */\n\n  /**\n   * Constructs a new Style.\n   * @exports Style\n   * @classdesc Represents a Style.\n   * @implements IStyle\n   * @constructor\n   * @param {IStyle=} [properties] Properties to set\n   */\n  function Style(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Style font.\n   * @member {IFont|null|undefined} font\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.font = null\n\n  /**\n   * Style fill.\n   * @member {IFill|null|undefined} fill\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.fill = null\n\n  /**\n   * Style useStroke.\n   * @member {boolean} useStroke\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.useStroke = false\n\n  /**\n   * Style stroke.\n   * @member {IFill|null|undefined} stroke\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.stroke = null\n\n  /**\n   * Style useShadow.\n   * @member {boolean} useShadow\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.useShadow = false\n\n  /**\n   * Style shadow.\n   * @member {IShadow|null|undefined} shadow\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.shadow = null\n\n  /**\n   * Style bgColor.\n   * @member {string} bgColor\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.bgColor = ''\n\n  /**\n   * Creates a new Style instance using the specified properties.\n   * @function create\n   * @memberof Style\n   * @static\n   * @param {IStyle=} [properties] Properties to set\n   * @returns {Style} Style instance\n   */\n  Style.create = function create(properties) {\n    return new Style(properties)\n  }\n\n  /**\n   * Encodes the specified Style message. Does not implicitly {@link Style.verify|verify} messages.\n   * @function encode\n   * @memberof Style\n   * @static\n   * @param {IStyle} message Style message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Style.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.font != null && Object.hasOwnProperty.call(message, 'font'))\n      $root.Font.encode(\n        message.font,\n        writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),\n      ).ldelim()\n    if (message.fill != null && Object.hasOwnProperty.call(message, 'fill'))\n      $root.Fill.encode(\n        message.fill,\n        writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n      ).ldelim()\n    if (\n      message.useStroke != null &&\n      Object.hasOwnProperty.call(message, 'useStroke')\n    )\n      writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.useStroke)\n    if (message.stroke != null && Object.hasOwnProperty.call(message, 'stroke'))\n      $root.Fill.encode(\n        message.stroke,\n        writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),\n      ).ldelim()\n    if (\n      message.useShadow != null &&\n      Object.hasOwnProperty.call(message, 'useShadow')\n    )\n      writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.useShadow)\n    if (message.shadow != null && Object.hasOwnProperty.call(message, 'shadow'))\n      $root.Shadow.encode(\n        message.shadow,\n        writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),\n      ).ldelim()\n    if (\n      message.bgColor != null &&\n      Object.hasOwnProperty.call(message, 'bgColor')\n    )\n      writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.bgColor)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Style message, length delimited. Does not implicitly {@link Style.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Style\n   * @static\n   * @param {IStyle} message Style message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Style.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Style message from the specified reader or buffer.\n   * @function decode\n   * @memberof Style\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Style} Style\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Style.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Style()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.font = $root.Font.decode(reader, reader.uint32())\n          break\n        case 2:\n          message.fill = $root.Fill.decode(reader, reader.uint32())\n          break\n        case 3:\n          message.useStroke = reader.bool()\n          break\n        case 4:\n          message.stroke = $root.Fill.decode(reader, reader.uint32())\n          break\n        case 5:\n          message.useShadow = reader.bool()\n          break\n        case 6:\n          message.shadow = $root.Shadow.decode(reader, reader.uint32())\n          break\n        case 7:\n          message.bgColor = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Style message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Style\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Style} Style\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Style.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Style message.\n   * @function verify\n   * @memberof Style\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Style.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.font != null && message.hasOwnProperty('font')) {\n      let error = $root.Font.verify(message.font)\n      if (error) return 'font.' + error\n    }\n    if (message.fill != null && message.hasOwnProperty('fill')) {\n      let error = $root.Fill.verify(message.fill)\n      if (error) return 'fill.' + error\n    }\n    if (message.useStroke != null && message.hasOwnProperty('useStroke'))\n      if (typeof message.useStroke !== 'boolean')\n        return 'useStroke: boolean expected'\n    if (message.stroke != null && message.hasOwnProperty('stroke')) {\n      let error = $root.Fill.verify(message.stroke)\n      if (error) return 'stroke.' + error\n    }\n    if (message.useShadow != null && message.hasOwnProperty('useShadow'))\n      if (typeof message.useShadow !== 'boolean')\n        return 'useShadow: boolean expected'\n    if (message.shadow != null && message.hasOwnProperty('shadow')) {\n      let error = $root.Shadow.verify(message.shadow)\n      if (error) return 'shadow.' + error\n    }\n    if (message.bgColor != null && message.hasOwnProperty('bgColor'))\n      if (!$util.isString(message.bgColor)) return 'bgColor: string expected'\n    return null\n  }\n\n  /**\n   * Creates a Style message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Style\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Style} Style\n   */\n  Style.fromObject = function fromObject(object) {\n    if (object instanceof $root.Style) return object\n    let message = new $root.Style()\n    if (object.font != null) {\n      if (typeof object.font !== 'object')\n        throw TypeError('.Style.font: object expected')\n      message.font = $root.Font.fromObject(object.font)\n    }\n    if (object.fill != null) {\n      if (typeof object.fill !== 'object')\n        throw TypeError('.Style.fill: object expected')\n      message.fill = $root.Fill.fromObject(object.fill)\n    }\n    if (object.useStroke != null) message.useStroke = Boolean(object.useStroke)\n    if (object.stroke != null) {\n      if (typeof object.stroke !== 'object')\n        throw TypeError('.Style.stroke: object expected')\n      message.stroke = $root.Fill.fromObject(object.stroke)\n    }\n    if (object.useShadow != null) message.useShadow = Boolean(object.useShadow)\n    if (object.shadow != null) {\n      if (typeof object.shadow !== 'object')\n        throw TypeError('.Style.shadow: object expected')\n      message.shadow = $root.Shadow.fromObject(object.shadow)\n    }\n    if (object.bgColor != null) message.bgColor = String(object.bgColor)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Style message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Style\n   * @static\n   * @param {Style} message Style\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Style.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.font = null\n      object.fill = null\n      object.useStroke = false\n      object.stroke = null\n      object.useShadow = false\n      object.shadow = null\n      object.bgColor = ''\n    }\n    if (message.font != null && message.hasOwnProperty('font'))\n      object.font = $root.Font.toObject(message.font, options)\n    if (message.fill != null && message.hasOwnProperty('fill'))\n      object.fill = $root.Fill.toObject(message.fill, options)\n    if (message.useStroke != null && message.hasOwnProperty('useStroke'))\n      object.useStroke = message.useStroke\n    if (message.stroke != null && message.hasOwnProperty('stroke'))\n      object.stroke = $root.Fill.toObject(message.stroke, options)\n    if (message.useShadow != null && message.hasOwnProperty('useShadow'))\n      object.useShadow = message.useShadow\n    if (message.shadow != null && message.hasOwnProperty('shadow'))\n      object.shadow = $root.Shadow.toObject(message.shadow, options)\n    if (message.bgColor != null && message.hasOwnProperty('bgColor'))\n      object.bgColor = message.bgColor\n    return object\n  }\n\n  /**\n   * Converts this Style to JSON.\n   * @function toJSON\n   * @memberof Style\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Style.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Style\n})())\n\nexport const Ui = ($root.Ui = (() => {\n  /**\n   * Properties of an Ui.\n   * @exports IUi\n   * @interface IUi\n   * @property {string|null} [previewText] Ui previewText\n   */\n\n  /**\n   * Constructs a new Ui.\n   * @exports Ui\n   * @classdesc Represents an Ui.\n   * @implements IUi\n   * @constructor\n   * @param {IUi=} [properties] Properties to set\n   */\n  function Ui(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Ui previewText.\n   * @member {string} previewText\n   * @memberof Ui\n   * @instance\n   */\n  Ui.prototype.previewText = ''\n\n  /**\n   * Creates a new Ui instance using the specified properties.\n   * @function create\n   * @memberof Ui\n   * @static\n   * @param {IUi=} [properties] Properties to set\n   * @returns {Ui} Ui instance\n   */\n  Ui.create = function create(properties) {\n    return new Ui(properties)\n  }\n\n  /**\n   * Encodes the specified Ui message. Does not implicitly {@link Ui.verify|verify} messages.\n   * @function encode\n   * @memberof Ui\n   * @static\n   * @param {IUi} message Ui message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Ui.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (\n      message.previewText != null &&\n      Object.hasOwnProperty.call(message, 'previewText')\n    )\n      writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.previewText)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Ui message, length delimited. Does not implicitly {@link Ui.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Ui\n   * @static\n   * @param {IUi} message Ui message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Ui.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes an Ui message from the specified reader or buffer.\n   * @function decode\n   * @memberof Ui\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Ui} Ui\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Ui.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Ui()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.previewText = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes an Ui message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Ui\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Ui} Ui\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Ui.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies an Ui message.\n   * @function verify\n   * @memberof Ui\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Ui.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.previewText != null && message.hasOwnProperty('previewText'))\n      if (!$util.isString(message.previewText))\n        return 'previewText: string expected'\n    return null\n  }\n\n  /**\n   * Creates an Ui message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Ui\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Ui} Ui\n   */\n  Ui.fromObject = function fromObject(object) {\n    if (object instanceof $root.Ui) return object\n    let message = new $root.Ui()\n    if (object.previewText != null)\n      message.previewText = String(object.previewText)\n    return message\n  }\n\n  /**\n   * Creates a plain object from an Ui message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Ui\n   * @static\n   * @param {Ui} message Ui\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Ui.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) object.previewText = ''\n    if (message.previewText != null && message.hasOwnProperty('previewText'))\n      object.previewText = message.previewText\n    return object\n  }\n\n  /**\n   * Converts this Ui to JSON.\n   * @function toJSON\n   * @memberof Ui\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Ui.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Ui\n})())\n\nexport const Project = ($root.Project = (() => {\n  /**\n   * Properties of a Project.\n   * @exports IProject\n   * @interface IProject\n   * @property {number|Long|null} [id] Project id\n   * @property {string|null} [name] Project name\n   * @property {string|null} [text] Project text\n   * @property {Object.<string,IGlyphFont>|null} [glyphs] Project glyphs\n   * @property {Array.<IGlyphImage>|null} [glyphImages] Project glyphImages\n   * @property {IStyle|null} [style] Project style\n   * @property {ILayout|null} [layout] Project layout\n   * @property {IMetric|null} [globalAdjustMetric] Project globalAdjustMetric\n   * @property {IUi|null} [ui] Project ui\n   */\n\n  /**\n   * Constructs a new Project.\n   * @exports Project\n   * @classdesc Represents a Project.\n   * @implements IProject\n   * @constructor\n   * @param {IProject=} [properties] Properties to set\n   */\n  function Project(properties) {\n    this.glyphs = {}\n    this.glyphImages = []\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Project id.\n   * @member {number|Long} id\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, false) : 0\n\n  /**\n   * Project name.\n   * @member {string} name\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.name = ''\n\n  /**\n   * Project text.\n   * @member {string} text\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.text = ''\n\n  /**\n   * Project glyphs.\n   * @member {Object.<string,IGlyphFont>} glyphs\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.glyphs = $util.emptyObject\n\n  /**\n   * Project glyphImages.\n   * @member {Array.<IGlyphImage>} glyphImages\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.glyphImages = $util.emptyArray\n\n  /**\n   * Project style.\n   * @member {IStyle|null|undefined} style\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.style = null\n\n  /**\n   * Project layout.\n   * @member {ILayout|null|undefined} layout\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.layout = null\n\n  /**\n   * Project globalAdjustMetric.\n   * @member {IMetric|null|undefined} globalAdjustMetric\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.globalAdjustMetric = null\n\n  /**\n   * Project ui.\n   * @member {IUi|null|undefined} ui\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.ui = null\n\n  /**\n   * Creates a new Project instance using the specified properties.\n   * @function create\n   * @memberof Project\n   * @static\n   * @param {IProject=} [properties] Properties to set\n   * @returns {Project} Project instance\n   */\n  Project.create = function create(properties) {\n    return new Project(properties)\n  }\n\n  /**\n   * Encodes the specified Project message. Does not implicitly {@link Project.verify|verify} messages.\n   * @function encode\n   * @memberof Project\n   * @static\n   * @param {IProject} message Project message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Project.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.id != null && Object.hasOwnProperty.call(message, 'id'))\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.id)\n    if (message.name != null && Object.hasOwnProperty.call(message, 'name'))\n      writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name)\n    if (message.text != null && Object.hasOwnProperty.call(message, 'text'))\n      writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.text)\n    if (message.glyphs != null && Object.hasOwnProperty.call(message, 'glyphs'))\n      for (\n        let keys = Object.keys(message.glyphs), i = 0;\n        i < keys.length;\n        ++i\n      ) {\n        writer\n          .uint32(/* id 4, wireType 2 =*/ 34)\n          .fork()\n          .uint32(/* id 1, wireType 2 =*/ 10)\n          .string(keys[i])\n        $root.GlyphFont.encode(\n          message.glyphs[keys[i]],\n          writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n        )\n          .ldelim()\n          .ldelim()\n      }\n    if (message.glyphImages != null && message.glyphImages.length)\n      for (let i = 0; i < message.glyphImages.length; ++i)\n        $root.GlyphImage.encode(\n          message.glyphImages[i],\n          writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),\n        ).ldelim()\n    if (message.style != null && Object.hasOwnProperty.call(message, 'style'))\n      $root.Style.encode(\n        message.style,\n        writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),\n      ).ldelim()\n    if (message.layout != null && Object.hasOwnProperty.call(message, 'layout'))\n      $root.Layout.encode(\n        message.layout,\n        writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),\n      ).ldelim()\n    if (\n      message.globalAdjustMetric != null &&\n      Object.hasOwnProperty.call(message, 'globalAdjustMetric')\n    )\n      $root.Metric.encode(\n        message.globalAdjustMetric,\n        writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),\n      ).ldelim()\n    if (message.ui != null && Object.hasOwnProperty.call(message, 'ui'))\n      $root.Ui.encode(\n        message.ui,\n        writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),\n      ).ldelim()\n    return writer\n  }\n\n  /**\n   * Encodes the specified Project message, length delimited. Does not implicitly {@link Project.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Project\n   * @static\n   * @param {IProject} message Project message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Project.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Project message from the specified reader or buffer.\n   * @function decode\n   * @memberof Project\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Project} Project\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Project.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Project(),\n      key,\n      value\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.int64()\n          break\n        case 2:\n          message.name = reader.string()\n          break\n        case 3:\n          message.text = reader.string()\n          break\n        case 4:\n          if (message.glyphs === $util.emptyObject) message.glyphs = {}\n          let end2 = reader.uint32() + reader.pos\n          key = ''\n          value = null\n          while (reader.pos < end2) {\n            let tag2 = reader.uint32()\n            switch (tag2 >>> 3) {\n              case 1:\n                key = reader.string()\n                break\n              case 2:\n                value = $root.GlyphFont.decode(reader, reader.uint32())\n                break\n              default:\n                reader.skipType(tag2 & 7)\n                break\n            }\n          }\n          message.glyphs[key] = value\n          break\n        case 5:\n          if (!(message.glyphImages && message.glyphImages.length))\n            message.glyphImages = []\n          message.glyphImages.push(\n            $root.GlyphImage.decode(reader, reader.uint32()),\n          )\n          break\n        case 6:\n          message.style = $root.Style.decode(reader, reader.uint32())\n          break\n        case 7:\n          message.layout = $root.Layout.decode(reader, reader.uint32())\n          break\n        case 8:\n          message.globalAdjustMetric = $root.Metric.decode(\n            reader,\n            reader.uint32(),\n          )\n          break\n        case 9:\n          message.ui = $root.Ui.decode(reader, reader.uint32())\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Project message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Project\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Project} Project\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Project.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Project message.\n   * @function verify\n   * @memberof Project\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Project.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.id != null && message.hasOwnProperty('id'))\n      if (\n        !$util.isInteger(message.id) &&\n        !(\n          message.id &&\n          $util.isInteger(message.id.low) &&\n          $util.isInteger(message.id.high)\n        )\n      )\n        return 'id: integer|Long expected'\n    if (message.name != null && message.hasOwnProperty('name'))\n      if (!$util.isString(message.name)) return 'name: string expected'\n    if (message.text != null && message.hasOwnProperty('text'))\n      if (!$util.isString(message.text)) return 'text: string expected'\n    if (message.glyphs != null && message.hasOwnProperty('glyphs')) {\n      if (!$util.isObject(message.glyphs)) return 'glyphs: object expected'\n      let key = Object.keys(message.glyphs)\n      for (let i = 0; i < key.length; ++i) {\n        let error = $root.GlyphFont.verify(message.glyphs[key[i]])\n        if (error) return 'glyphs.' + error\n      }\n    }\n    if (message.glyphImages != null && message.hasOwnProperty('glyphImages')) {\n      if (!Array.isArray(message.glyphImages))\n        return 'glyphImages: array expected'\n      for (let i = 0; i < message.glyphImages.length; ++i) {\n        let error = $root.GlyphImage.verify(message.glyphImages[i])\n        if (error) return 'glyphImages.' + error\n      }\n    }\n    if (message.style != null && message.hasOwnProperty('style')) {\n      let error = $root.Style.verify(message.style)\n      if (error) return 'style.' + error\n    }\n    if (message.layout != null && message.hasOwnProperty('layout')) {\n      let error = $root.Layout.verify(message.layout)\n      if (error) return 'layout.' + error\n    }\n    if (\n      message.globalAdjustMetric != null &&\n      message.hasOwnProperty('globalAdjustMetric')\n    ) {\n      let error = $root.Metric.verify(message.globalAdjustMetric)\n      if (error) return 'globalAdjustMetric.' + error\n    }\n    if (message.ui != null && message.hasOwnProperty('ui')) {\n      let error = $root.Ui.verify(message.ui)\n      if (error) return 'ui.' + error\n    }\n    return null\n  }\n\n  /**\n   * Creates a Project message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Project\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Project} Project\n   */\n  Project.fromObject = function fromObject(object) {\n    if (object instanceof $root.Project) return object\n    let message = new $root.Project()\n    if (object.id != null)\n      if ($util.Long)\n        (message.id = $util.Long.fromValue(object.id)).unsigned = false\n      else if (typeof object.id === 'string')\n        message.id = parseInt(object.id, 10)\n      else if (typeof object.id === 'number') message.id = object.id\n      else if (typeof object.id === 'object')\n        message.id = new $util.LongBits(\n          object.id.low >>> 0,\n          object.id.high >>> 0,\n        ).toNumber()\n    if (object.name != null) message.name = String(object.name)\n    if (object.text != null) message.text = String(object.text)\n    if (object.glyphs) {\n      if (typeof object.glyphs !== 'object')\n        throw TypeError('.Project.glyphs: object expected')\n      message.glyphs = {}\n      for (let keys = Object.keys(object.glyphs), i = 0; i < keys.length; ++i) {\n        if (typeof object.glyphs[keys[i]] !== 'object')\n          throw TypeError('.Project.glyphs: object expected')\n        message.glyphs[keys[i]] = $root.GlyphFont.fromObject(\n          object.glyphs[keys[i]],\n        )\n      }\n    }\n    if (object.glyphImages) {\n      if (!Array.isArray(object.glyphImages))\n        throw TypeError('.Project.glyphImages: array expected')\n      message.glyphImages = []\n      for (let i = 0; i < object.glyphImages.length; ++i) {\n        if (typeof object.glyphImages[i] !== 'object')\n          throw TypeError('.Project.glyphImages: object expected')\n        message.glyphImages[i] = $root.GlyphImage.fromObject(\n          object.glyphImages[i],\n        )\n      }\n    }\n    if (object.style != null) {\n      if (typeof object.style !== 'object')\n        throw TypeError('.Project.style: object expected')\n      message.style = $root.Style.fromObject(object.style)\n    }\n    if (object.layout != null) {\n      if (typeof object.layout !== 'object')\n        throw TypeError('.Project.layout: object expected')\n      message.layout = $root.Layout.fromObject(object.layout)\n    }\n    if (object.globalAdjustMetric != null) {\n      if (typeof object.globalAdjustMetric !== 'object')\n        throw TypeError('.Project.globalAdjustMetric: object expected')\n      message.globalAdjustMetric = $root.Metric.fromObject(\n        object.globalAdjustMetric,\n      )\n    }\n    if (object.ui != null) {\n      if (typeof object.ui !== 'object')\n        throw TypeError('.Project.ui: object expected')\n      message.ui = $root.Ui.fromObject(object.ui)\n    }\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Project message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Project\n   * @static\n   * @param {Project} message Project\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Project.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.arrays || options.defaults) object.glyphImages = []\n    if (options.objects || options.defaults) object.glyphs = {}\n    if (options.defaults) {\n      if ($util.Long) {\n        let long = new $util.Long(0, 0, false)\n        object.id =\n          options.longs === String\n            ? long.toString()\n            : options.longs === Number\n            ? long.toNumber()\n            : long\n      } else object.id = options.longs === String ? '0' : 0\n      object.name = ''\n      object.text = ''\n      object.style = null\n      object.layout = null\n      object.globalAdjustMetric = null\n      object.ui = null\n    }\n    if (message.id != null && message.hasOwnProperty('id'))\n      if (typeof message.id === 'number')\n        object.id = options.longs === String ? String(message.id) : message.id\n      else\n        object.id =\n          options.longs === String\n            ? $util.Long.prototype.toString.call(message.id)\n            : options.longs === Number\n            ? new $util.LongBits(\n                message.id.low >>> 0,\n                message.id.high >>> 0,\n              ).toNumber()\n            : message.id\n    if (message.name != null && message.hasOwnProperty('name'))\n      object.name = message.name\n    if (message.text != null && message.hasOwnProperty('text'))\n      object.text = message.text\n    let keys2\n    if (message.glyphs && (keys2 = Object.keys(message.glyphs)).length) {\n      object.glyphs = {}\n      for (let j = 0; j < keys2.length; ++j)\n        object.glyphs[keys2[j]] = $root.GlyphFont.toObject(\n          message.glyphs[keys2[j]],\n          options,\n        )\n    }\n    if (message.glyphImages && message.glyphImages.length) {\n      object.glyphImages = []\n      for (let j = 0; j < message.glyphImages.length; ++j)\n        object.glyphImages[j] = $root.GlyphImage.toObject(\n          message.glyphImages[j],\n          options,\n        )\n    }\n    if (message.style != null && message.hasOwnProperty('style'))\n      object.style = $root.Style.toObject(message.style, options)\n    if (message.layout != null && message.hasOwnProperty('layout'))\n      object.layout = $root.Layout.toObject(message.layout, options)\n    if (\n      message.globalAdjustMetric != null &&\n      message.hasOwnProperty('globalAdjustMetric')\n    )\n      object.globalAdjustMetric = $root.Metric.toObject(\n        message.globalAdjustMetric,\n        options,\n      )\n    if (message.ui != null && message.hasOwnProperty('ui'))\n      object.ui = $root.Ui.toObject(message.ui, options)\n    return object\n  }\n\n  /**\n   * Converts this Project to JSON.\n   * @function toJSON\n   * @memberof Project\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Project.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Project\n})())\n\nexport { $root as default }\n","import { IProject } from './project'\nimport { IProject as IProjectNext, IGradientColor } from '../1.0.2'\n\nexport default function updateToNext(project: IProject): IProjectNext {\n  function fixOffset(list: IGradientColor[]) {\n    const len = list.length - 1\n    list.forEach((item, idx) => {\n      item.offset = (1 / len) * idx\n    })\n  }\n  if (\n    project?.style?.fill?.gradient?.palette &&\n    project.style.fill.gradient.palette.length > 0\n  ) {\n    fixOffset(project.style.fill.gradient.palette)\n  }\n\n  if (\n    project?.style?.stroke?.gradient?.palette &&\n    project.style.stroke.gradient.palette.length > 0\n  ) {\n    fixOffset(project.style.stroke.gradient.palette)\n  }\n\n  return project\n}\n","/* eslint-disable */\nimport * as $protobuf from 'protobufjs/minimal'\n\n// Common aliases\nconst $Reader = $protobuf.Reader,\n  $Writer = $protobuf.Writer,\n  $util = $protobuf.util\n\n// Exported root namespace\nconst $root = {}\n\nexport const Metric = ($root.Metric = (() => {\n  /**\n   * Properties of a Metric.\n   * @exports IMetric\n   * @interface IMetric\n   * @property {number|null} [xAdvance] Metric xAdvance\n   * @property {number|null} [xOffset] Metric xOffset\n   * @property {number|null} [yOffset] Metric yOffset\n   */\n\n  /**\n   * Constructs a new Metric.\n   * @exports Metric\n   * @classdesc Represents a Metric.\n   * @implements IMetric\n   * @constructor\n   * @param {IMetric=} [properties] Properties to set\n   */\n  function Metric(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Metric xAdvance.\n   * @member {number} xAdvance\n   * @memberof Metric\n   * @instance\n   */\n  Metric.prototype.xAdvance = 0\n\n  /**\n   * Metric xOffset.\n   * @member {number} xOffset\n   * @memberof Metric\n   * @instance\n   */\n  Metric.prototype.xOffset = 0\n\n  /**\n   * Metric yOffset.\n   * @member {number} yOffset\n   * @memberof Metric\n   * @instance\n   */\n  Metric.prototype.yOffset = 0\n\n  /**\n   * Creates a new Metric instance using the specified properties.\n   * @function create\n   * @memberof Metric\n   * @static\n   * @param {IMetric=} [properties] Properties to set\n   * @returns {Metric} Metric instance\n   */\n  Metric.create = function create(properties) {\n    return new Metric(properties)\n  }\n\n  /**\n   * Encodes the specified Metric message. Does not implicitly {@link Metric.verify|verify} messages.\n   * @function encode\n   * @memberof Metric\n   * @static\n   * @param {IMetric} message Metric message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Metric.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (\n      message.xAdvance != null &&\n      Object.hasOwnProperty.call(message, 'xAdvance')\n    )\n      writer.uint32(/* id 1, wireType 0 =*/ 8).sint32(message.xAdvance)\n    if (\n      message.xOffset != null &&\n      Object.hasOwnProperty.call(message, 'xOffset')\n    )\n      writer.uint32(/* id 2, wireType 0 =*/ 16).sint32(message.xOffset)\n    if (\n      message.yOffset != null &&\n      Object.hasOwnProperty.call(message, 'yOffset')\n    )\n      writer.uint32(/* id 3, wireType 0 =*/ 24).sint32(message.yOffset)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Metric message, length delimited. Does not implicitly {@link Metric.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Metric\n   * @static\n   * @param {IMetric} message Metric message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Metric.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Metric message from the specified reader or buffer.\n   * @function decode\n   * @memberof Metric\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Metric} Metric\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Metric.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Metric()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.xAdvance = reader.sint32()\n          break\n        case 2:\n          message.xOffset = reader.sint32()\n          break\n        case 3:\n          message.yOffset = reader.sint32()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Metric message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Metric\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Metric} Metric\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Metric.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Metric message.\n   * @function verify\n   * @memberof Metric\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Metric.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.xAdvance != null && message.hasOwnProperty('xAdvance'))\n      if (!$util.isInteger(message.xAdvance))\n        return 'xAdvance: integer expected'\n    if (message.xOffset != null && message.hasOwnProperty('xOffset'))\n      if (!$util.isInteger(message.xOffset)) return 'xOffset: integer expected'\n    if (message.yOffset != null && message.hasOwnProperty('yOffset'))\n      if (!$util.isInteger(message.yOffset)) return 'yOffset: integer expected'\n    return null\n  }\n\n  /**\n   * Creates a Metric message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Metric\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Metric} Metric\n   */\n  Metric.fromObject = function fromObject(object) {\n    if (object instanceof $root.Metric) return object\n    let message = new $root.Metric()\n    if (object.xAdvance != null) message.xAdvance = object.xAdvance | 0\n    if (object.xOffset != null) message.xOffset = object.xOffset | 0\n    if (object.yOffset != null) message.yOffset = object.yOffset | 0\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Metric message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Metric\n   * @static\n   * @param {Metric} message Metric\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Metric.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.xAdvance = 0\n      object.xOffset = 0\n      object.yOffset = 0\n    }\n    if (message.xAdvance != null && message.hasOwnProperty('xAdvance'))\n      object.xAdvance = message.xAdvance\n    if (message.xOffset != null && message.hasOwnProperty('xOffset'))\n      object.xOffset = message.xOffset\n    if (message.yOffset != null && message.hasOwnProperty('yOffset'))\n      object.yOffset = message.yOffset\n    return object\n  }\n\n  /**\n   * Converts this Metric to JSON.\n   * @function toJSON\n   * @memberof Metric\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Metric.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Metric\n})())\n\nexport const GradientColor = ($root.GradientColor = (() => {\n  /**\n   * Properties of a GradientColor.\n   * @exports IGradientColor\n   * @interface IGradientColor\n   * @property {number|null} [id] GradientColor id\n   * @property {number|null} [offset] GradientColor offset\n   * @property {string|null} [color] GradientColor color\n   */\n\n  /**\n   * Constructs a new GradientColor.\n   * @exports GradientColor\n   * @classdesc Represents a GradientColor.\n   * @implements IGradientColor\n   * @constructor\n   * @param {IGradientColor=} [properties] Properties to set\n   */\n  function GradientColor(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * GradientColor id.\n   * @member {number} id\n   * @memberof GradientColor\n   * @instance\n   */\n  GradientColor.prototype.id = 0\n\n  /**\n   * GradientColor offset.\n   * @member {number} offset\n   * @memberof GradientColor\n   * @instance\n   */\n  GradientColor.prototype.offset = 0\n\n  /**\n   * GradientColor color.\n   * @member {string} color\n   * @memberof GradientColor\n   * @instance\n   */\n  GradientColor.prototype.color = ''\n\n  /**\n   * Creates a new GradientColor instance using the specified properties.\n   * @function create\n   * @memberof GradientColor\n   * @static\n   * @param {IGradientColor=} [properties] Properties to set\n   * @returns {GradientColor} GradientColor instance\n   */\n  GradientColor.create = function create(properties) {\n    return new GradientColor(properties)\n  }\n\n  /**\n   * Encodes the specified GradientColor message. Does not implicitly {@link GradientColor.verify|verify} messages.\n   * @function encode\n   * @memberof GradientColor\n   * @static\n   * @param {IGradientColor} message GradientColor message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GradientColor.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.id != null && Object.hasOwnProperty.call(message, 'id'))\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.id)\n    if (message.offset != null && Object.hasOwnProperty.call(message, 'offset'))\n      writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.offset)\n    if (message.color != null && Object.hasOwnProperty.call(message, 'color'))\n      writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.color)\n    return writer\n  }\n\n  /**\n   * Encodes the specified GradientColor message, length delimited. Does not implicitly {@link GradientColor.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof GradientColor\n   * @static\n   * @param {IGradientColor} message GradientColor message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GradientColor.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a GradientColor message from the specified reader or buffer.\n   * @function decode\n   * @memberof GradientColor\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {GradientColor} GradientColor\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GradientColor.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.GradientColor()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.int32()\n          break\n        case 2:\n          message.offset = reader.float()\n          break\n        case 3:\n          message.color = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a GradientColor message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof GradientColor\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {GradientColor} GradientColor\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GradientColor.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a GradientColor message.\n   * @function verify\n   * @memberof GradientColor\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  GradientColor.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.id != null && message.hasOwnProperty('id'))\n      if (!$util.isInteger(message.id)) return 'id: integer expected'\n    if (message.offset != null && message.hasOwnProperty('offset'))\n      if (typeof message.offset !== 'number') return 'offset: number expected'\n    if (message.color != null && message.hasOwnProperty('color'))\n      if (!$util.isString(message.color)) return 'color: string expected'\n    return null\n  }\n\n  /**\n   * Creates a GradientColor message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof GradientColor\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {GradientColor} GradientColor\n   */\n  GradientColor.fromObject = function fromObject(object) {\n    if (object instanceof $root.GradientColor) return object\n    let message = new $root.GradientColor()\n    if (object.id != null) message.id = object.id | 0\n    if (object.offset != null) message.offset = Number(object.offset)\n    if (object.color != null) message.color = String(object.color)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a GradientColor message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof GradientColor\n   * @static\n   * @param {GradientColor} message GradientColor\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  GradientColor.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.id = 0\n      object.offset = 0\n      object.color = ''\n    }\n    if (message.id != null && message.hasOwnProperty('id'))\n      object.id = message.id\n    if (message.offset != null && message.hasOwnProperty('offset'))\n      object.offset =\n        options.json && !isFinite(message.offset)\n          ? String(message.offset)\n          : message.offset\n    if (message.color != null && message.hasOwnProperty('color'))\n      object.color = message.color\n    return object\n  }\n\n  /**\n   * Converts this GradientColor to JSON.\n   * @function toJSON\n   * @memberof GradientColor\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  GradientColor.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return GradientColor\n})())\n\nexport const Gradient = ($root.Gradient = (() => {\n  /**\n   * Properties of a Gradient.\n   * @exports IGradient\n   * @interface IGradient\n   * @property {number|null} [type] Gradient type\n   * @property {number|null} [angle] Gradient angle\n   * @property {Array.<IGradientColor>|null} [palette] Gradient palette\n   */\n\n  /**\n   * Constructs a new Gradient.\n   * @exports Gradient\n   * @classdesc Represents a Gradient.\n   * @implements IGradient\n   * @constructor\n   * @param {IGradient=} [properties] Properties to set\n   */\n  function Gradient(properties) {\n    this.palette = []\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Gradient type.\n   * @member {number} type\n   * @memberof Gradient\n   * @instance\n   */\n  Gradient.prototype.type = 0\n\n  /**\n   * Gradient angle.\n   * @member {number} angle\n   * @memberof Gradient\n   * @instance\n   */\n  Gradient.prototype.angle = 0\n\n  /**\n   * Gradient palette.\n   * @member {Array.<IGradientColor>} palette\n   * @memberof Gradient\n   * @instance\n   */\n  Gradient.prototype.palette = $util.emptyArray\n\n  /**\n   * Creates a new Gradient instance using the specified properties.\n   * @function create\n   * @memberof Gradient\n   * @static\n   * @param {IGradient=} [properties] Properties to set\n   * @returns {Gradient} Gradient instance\n   */\n  Gradient.create = function create(properties) {\n    return new Gradient(properties)\n  }\n\n  /**\n   * Encodes the specified Gradient message. Does not implicitly {@link Gradient.verify|verify} messages.\n   * @function encode\n   * @memberof Gradient\n   * @static\n   * @param {IGradient} message Gradient message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Gradient.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.type != null && Object.hasOwnProperty.call(message, 'type'))\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.type)\n    if (message.angle != null && Object.hasOwnProperty.call(message, 'angle'))\n      writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.angle)\n    if (message.palette != null && message.palette.length)\n      for (let i = 0; i < message.palette.length; ++i)\n        $root.GradientColor.encode(\n          message.palette[i],\n          writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),\n        ).ldelim()\n    return writer\n  }\n\n  /**\n   * Encodes the specified Gradient message, length delimited. Does not implicitly {@link Gradient.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Gradient\n   * @static\n   * @param {IGradient} message Gradient message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Gradient.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Gradient message from the specified reader or buffer.\n   * @function decode\n   * @memberof Gradient\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Gradient} Gradient\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Gradient.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Gradient()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32()\n          break\n        case 2:\n          message.angle = reader.float()\n          break\n        case 3:\n          if (!(message.palette && message.palette.length)) message.palette = []\n          message.palette.push(\n            $root.GradientColor.decode(reader, reader.uint32()),\n          )\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Gradient message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Gradient\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Gradient} Gradient\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Gradient.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Gradient message.\n   * @function verify\n   * @memberof Gradient\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Gradient.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.type != null && message.hasOwnProperty('type'))\n      if (!$util.isInteger(message.type)) return 'type: integer expected'\n    if (message.angle != null && message.hasOwnProperty('angle'))\n      if (typeof message.angle !== 'number') return 'angle: number expected'\n    if (message.palette != null && message.hasOwnProperty('palette')) {\n      if (!Array.isArray(message.palette)) return 'palette: array expected'\n      for (let i = 0; i < message.palette.length; ++i) {\n        let error = $root.GradientColor.verify(message.palette[i])\n        if (error) return 'palette.' + error\n      }\n    }\n    return null\n  }\n\n  /**\n   * Creates a Gradient message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Gradient\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Gradient} Gradient\n   */\n  Gradient.fromObject = function fromObject(object) {\n    if (object instanceof $root.Gradient) return object\n    let message = new $root.Gradient()\n    if (object.type != null) message.type = object.type | 0\n    if (object.angle != null) message.angle = Number(object.angle)\n    if (object.palette) {\n      if (!Array.isArray(object.palette))\n        throw TypeError('.Gradient.palette: array expected')\n      message.palette = []\n      for (let i = 0; i < object.palette.length; ++i) {\n        if (typeof object.palette[i] !== 'object')\n          throw TypeError('.Gradient.palette: object expected')\n        message.palette[i] = $root.GradientColor.fromObject(object.palette[i])\n      }\n    }\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Gradient message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Gradient\n   * @static\n   * @param {Gradient} message Gradient\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Gradient.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.arrays || options.defaults) object.palette = []\n    if (options.defaults) {\n      object.type = 0\n      object.angle = 0\n    }\n    if (message.type != null && message.hasOwnProperty('type'))\n      object.type = message.type\n    if (message.angle != null && message.hasOwnProperty('angle'))\n      object.angle =\n        options.json && !isFinite(message.angle)\n          ? String(message.angle)\n          : message.angle\n    if (message.palette && message.palette.length) {\n      object.palette = []\n      for (let j = 0; j < message.palette.length; ++j)\n        object.palette[j] = $root.GradientColor.toObject(\n          message.palette[j],\n          options,\n        )\n    }\n    return object\n  }\n\n  /**\n   * Converts this Gradient to JSON.\n   * @function toJSON\n   * @memberof Gradient\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Gradient.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Gradient\n})())\n\nexport const PatternTexture = ($root.PatternTexture = (() => {\n  /**\n   * Properties of a PatternTexture.\n   * @exports IPatternTexture\n   * @interface IPatternTexture\n   * @property {Uint8Array|null} [buffer] PatternTexture buffer\n   * @property {number|null} [scale] PatternTexture scale\n   * @property {string|null} [repetition] PatternTexture repetition\n   */\n\n  /**\n   * Constructs a new PatternTexture.\n   * @exports PatternTexture\n   * @classdesc Represents a PatternTexture.\n   * @implements IPatternTexture\n   * @constructor\n   * @param {IPatternTexture=} [properties] Properties to set\n   */\n  function PatternTexture(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * PatternTexture buffer.\n   * @member {Uint8Array} buffer\n   * @memberof PatternTexture\n   * @instance\n   */\n  PatternTexture.prototype.buffer = $util.newBuffer([])\n\n  /**\n   * PatternTexture scale.\n   * @member {number} scale\n   * @memberof PatternTexture\n   * @instance\n   */\n  PatternTexture.prototype.scale = 0\n\n  /**\n   * PatternTexture repetition.\n   * @member {string} repetition\n   * @memberof PatternTexture\n   * @instance\n   */\n  PatternTexture.prototype.repetition = ''\n\n  /**\n   * Creates a new PatternTexture instance using the specified properties.\n   * @function create\n   * @memberof PatternTexture\n   * @static\n   * @param {IPatternTexture=} [properties] Properties to set\n   * @returns {PatternTexture} PatternTexture instance\n   */\n  PatternTexture.create = function create(properties) {\n    return new PatternTexture(properties)\n  }\n\n  /**\n   * Encodes the specified PatternTexture message. Does not implicitly {@link PatternTexture.verify|verify} messages.\n   * @function encode\n   * @memberof PatternTexture\n   * @static\n   * @param {IPatternTexture} message PatternTexture message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  PatternTexture.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.buffer != null && Object.hasOwnProperty.call(message, 'buffer'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.buffer)\n    if (message.scale != null && Object.hasOwnProperty.call(message, 'scale'))\n      writer.uint32(/* id 2, wireType 1 =*/ 17).double(message.scale)\n    if (\n      message.repetition != null &&\n      Object.hasOwnProperty.call(message, 'repetition')\n    )\n      writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.repetition)\n    return writer\n  }\n\n  /**\n   * Encodes the specified PatternTexture message, length delimited. Does not implicitly {@link PatternTexture.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof PatternTexture\n   * @static\n   * @param {IPatternTexture} message PatternTexture message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  PatternTexture.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a PatternTexture message from the specified reader or buffer.\n   * @function decode\n   * @memberof PatternTexture\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {PatternTexture} PatternTexture\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  PatternTexture.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.PatternTexture()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.buffer = reader.bytes()\n          break\n        case 2:\n          message.scale = reader.double()\n          break\n        case 3:\n          message.repetition = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a PatternTexture message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof PatternTexture\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {PatternTexture} PatternTexture\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  PatternTexture.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a PatternTexture message.\n   * @function verify\n   * @memberof PatternTexture\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  PatternTexture.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.buffer != null && message.hasOwnProperty('buffer'))\n      if (\n        !(\n          (message.buffer && typeof message.buffer.length === 'number') ||\n          $util.isString(message.buffer)\n        )\n      )\n        return 'buffer: buffer expected'\n    if (message.scale != null && message.hasOwnProperty('scale'))\n      if (typeof message.scale !== 'number') return 'scale: number expected'\n    if (message.repetition != null && message.hasOwnProperty('repetition'))\n      if (!$util.isString(message.repetition))\n        return 'repetition: string expected'\n    return null\n  }\n\n  /**\n   * Creates a PatternTexture message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof PatternTexture\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {PatternTexture} PatternTexture\n   */\n  PatternTexture.fromObject = function fromObject(object) {\n    if (object instanceof $root.PatternTexture) return object\n    let message = new $root.PatternTexture()\n    if (object.buffer != null)\n      if (typeof object.buffer === 'string')\n        $util.base64.decode(\n          object.buffer,\n          (message.buffer = $util.newBuffer(\n            $util.base64.length(object.buffer),\n          )),\n          0,\n        )\n      else if (object.buffer.length) message.buffer = object.buffer\n    if (object.scale != null) message.scale = Number(object.scale)\n    if (object.repetition != null)\n      message.repetition = String(object.repetition)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a PatternTexture message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof PatternTexture\n   * @static\n   * @param {PatternTexture} message PatternTexture\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  PatternTexture.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      if (options.bytes === String) object.buffer = ''\n      else {\n        object.buffer = []\n        if (options.bytes !== Array)\n          object.buffer = $util.newBuffer(object.buffer)\n      }\n      object.scale = 0\n      object.repetition = ''\n    }\n    if (message.buffer != null && message.hasOwnProperty('buffer'))\n      object.buffer =\n        options.bytes === String\n          ? $util.base64.encode(message.buffer, 0, message.buffer.length)\n          : options.bytes === Array\n          ? Array.prototype.slice.call(message.buffer)\n          : message.buffer\n    if (message.scale != null && message.hasOwnProperty('scale'))\n      object.scale =\n        options.json && !isFinite(message.scale)\n          ? String(message.scale)\n          : message.scale\n    if (message.repetition != null && message.hasOwnProperty('repetition'))\n      object.repetition = message.repetition\n    return object\n  }\n\n  /**\n   * Converts this PatternTexture to JSON.\n   * @function toJSON\n   * @memberof PatternTexture\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  PatternTexture.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return PatternTexture\n})())\n\nexport const Fill = ($root.Fill = (() => {\n  /**\n   * Properties of a Fill.\n   * @exports IFill\n   * @interface IFill\n   * @property {number|null} [type] Fill type\n   * @property {string|null} [color] Fill color\n   * @property {IGradient|null} [gradient] Fill gradient\n   * @property {IPatternTexture|null} [patternTexture] Fill patternTexture\n   * @property {number|null} [width] Fill width\n   * @property {string|null} [lineCap] Fill lineCap\n   * @property {string|null} [lineJoin] Fill lineJoin\n   */\n\n  /**\n   * Constructs a new Fill.\n   * @exports Fill\n   * @classdesc Represents a Fill.\n   * @implements IFill\n   * @constructor\n   * @param {IFill=} [properties] Properties to set\n   */\n  function Fill(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Fill type.\n   * @member {number} type\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.type = 0\n\n  /**\n   * Fill color.\n   * @member {string} color\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.color = ''\n\n  /**\n   * Fill gradient.\n   * @member {IGradient|null|undefined} gradient\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.gradient = null\n\n  /**\n   * Fill patternTexture.\n   * @member {IPatternTexture|null|undefined} patternTexture\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.patternTexture = null\n\n  /**\n   * Fill width.\n   * @member {number} width\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.width = 0\n\n  /**\n   * Fill lineCap.\n   * @member {string} lineCap\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.lineCap = ''\n\n  /**\n   * Fill lineJoin.\n   * @member {string} lineJoin\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.lineJoin = ''\n\n  /**\n   * Creates a new Fill instance using the specified properties.\n   * @function create\n   * @memberof Fill\n   * @static\n   * @param {IFill=} [properties] Properties to set\n   * @returns {Fill} Fill instance\n   */\n  Fill.create = function create(properties) {\n    return new Fill(properties)\n  }\n\n  /**\n   * Encodes the specified Fill message. Does not implicitly {@link Fill.verify|verify} messages.\n   * @function encode\n   * @memberof Fill\n   * @static\n   * @param {IFill} message Fill message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Fill.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.type != null && Object.hasOwnProperty.call(message, 'type'))\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.type)\n    if (message.color != null && Object.hasOwnProperty.call(message, 'color'))\n      writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.color)\n    if (\n      message.gradient != null &&\n      Object.hasOwnProperty.call(message, 'gradient')\n    )\n      $root.Gradient.encode(\n        message.gradient,\n        writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),\n      ).ldelim()\n    if (\n      message.patternTexture != null &&\n      Object.hasOwnProperty.call(message, 'patternTexture')\n    )\n      $root.PatternTexture.encode(\n        message.patternTexture,\n        writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),\n      ).ldelim()\n    if (message.width != null && Object.hasOwnProperty.call(message, 'width'))\n      writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.width)\n    if (\n      message.lineCap != null &&\n      Object.hasOwnProperty.call(message, 'lineCap')\n    )\n      writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.lineCap)\n    if (\n      message.lineJoin != null &&\n      Object.hasOwnProperty.call(message, 'lineJoin')\n    )\n      writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.lineJoin)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Fill message, length delimited. Does not implicitly {@link Fill.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Fill\n   * @static\n   * @param {IFill} message Fill message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Fill.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Fill message from the specified reader or buffer.\n   * @function decode\n   * @memberof Fill\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Fill} Fill\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Fill.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Fill()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32()\n          break\n        case 2:\n          message.color = reader.string()\n          break\n        case 3:\n          message.gradient = $root.Gradient.decode(reader, reader.uint32())\n          break\n        case 4:\n          message.patternTexture = $root.PatternTexture.decode(\n            reader,\n            reader.uint32(),\n          )\n          break\n        case 5:\n          message.width = reader.int32()\n          break\n        case 6:\n          message.lineCap = reader.string()\n          break\n        case 7:\n          message.lineJoin = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Fill message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Fill\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Fill} Fill\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Fill.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Fill message.\n   * @function verify\n   * @memberof Fill\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Fill.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.type != null && message.hasOwnProperty('type'))\n      if (!$util.isInteger(message.type)) return 'type: integer expected'\n    if (message.color != null && message.hasOwnProperty('color'))\n      if (!$util.isString(message.color)) return 'color: string expected'\n    if (message.gradient != null && message.hasOwnProperty('gradient')) {\n      let error = $root.Gradient.verify(message.gradient)\n      if (error) return 'gradient.' + error\n    }\n    if (\n      message.patternTexture != null &&\n      message.hasOwnProperty('patternTexture')\n    ) {\n      let error = $root.PatternTexture.verify(message.patternTexture)\n      if (error) return 'patternTexture.' + error\n    }\n    if (message.width != null && message.hasOwnProperty('width'))\n      if (!$util.isInteger(message.width)) return 'width: integer expected'\n    if (message.lineCap != null && message.hasOwnProperty('lineCap'))\n      if (!$util.isString(message.lineCap)) return 'lineCap: string expected'\n    if (message.lineJoin != null && message.hasOwnProperty('lineJoin'))\n      if (!$util.isString(message.lineJoin)) return 'lineJoin: string expected'\n    return null\n  }\n\n  /**\n   * Creates a Fill message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Fill\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Fill} Fill\n   */\n  Fill.fromObject = function fromObject(object) {\n    if (object instanceof $root.Fill) return object\n    let message = new $root.Fill()\n    if (object.type != null) message.type = object.type | 0\n    if (object.color != null) message.color = String(object.color)\n    if (object.gradient != null) {\n      if (typeof object.gradient !== 'object')\n        throw TypeError('.Fill.gradient: object expected')\n      message.gradient = $root.Gradient.fromObject(object.gradient)\n    }\n    if (object.patternTexture != null) {\n      if (typeof object.patternTexture !== 'object')\n        throw TypeError('.Fill.patternTexture: object expected')\n      message.patternTexture = $root.PatternTexture.fromObject(\n        object.patternTexture,\n      )\n    }\n    if (object.width != null) message.width = object.width | 0\n    if (object.lineCap != null) message.lineCap = String(object.lineCap)\n    if (object.lineJoin != null) message.lineJoin = String(object.lineJoin)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Fill message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Fill\n   * @static\n   * @param {Fill} message Fill\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Fill.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.type = 0\n      object.color = ''\n      object.gradient = null\n      object.patternTexture = null\n      object.width = 0\n      object.lineCap = ''\n      object.lineJoin = ''\n    }\n    if (message.type != null && message.hasOwnProperty('type'))\n      object.type = message.type\n    if (message.color != null && message.hasOwnProperty('color'))\n      object.color = message.color\n    if (message.gradient != null && message.hasOwnProperty('gradient'))\n      object.gradient = $root.Gradient.toObject(message.gradient, options)\n    if (\n      message.patternTexture != null &&\n      message.hasOwnProperty('patternTexture')\n    )\n      object.patternTexture = $root.PatternTexture.toObject(\n        message.patternTexture,\n        options,\n      )\n    if (message.width != null && message.hasOwnProperty('width'))\n      object.width = message.width\n    if (message.lineCap != null && message.hasOwnProperty('lineCap'))\n      object.lineCap = message.lineCap\n    if (message.lineJoin != null && message.hasOwnProperty('lineJoin'))\n      object.lineJoin = message.lineJoin\n    return object\n  }\n\n  /**\n   * Converts this Fill to JSON.\n   * @function toJSON\n   * @memberof Fill\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Fill.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Fill\n})())\n\nexport const Font = ($root.Font = (() => {\n  /**\n   * Properties of a Font.\n   * @exports IFont\n   * @interface IFont\n   * @property {Uint8Array|null} [font] Font font\n   * @property {string|null} [family] Font family\n   * @property {number|null} [size] Font size\n   * @property {number|null} [lineHeight] Font lineHeight\n   */\n\n  /**\n   * Constructs a new Font.\n   * @exports Font\n   * @classdesc Represents a Font.\n   * @implements IFont\n   * @constructor\n   * @param {IFont=} [properties] Properties to set\n   */\n  function Font(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Font font.\n   * @member {Uint8Array} font\n   * @memberof Font\n   * @instance\n   */\n  Font.prototype.font = $util.newBuffer([])\n\n  /**\n   * Font family.\n   * @member {string} family\n   * @memberof Font\n   * @instance\n   */\n  Font.prototype.family = ''\n\n  /**\n   * Font size.\n   * @member {number} size\n   * @memberof Font\n   * @instance\n   */\n  Font.prototype.size = 0\n\n  /**\n   * Font lineHeight.\n   * @member {number} lineHeight\n   * @memberof Font\n   * @instance\n   */\n  Font.prototype.lineHeight = 0\n\n  /**\n   * Creates a new Font instance using the specified properties.\n   * @function create\n   * @memberof Font\n   * @static\n   * @param {IFont=} [properties] Properties to set\n   * @returns {Font} Font instance\n   */\n  Font.create = function create(properties) {\n    return new Font(properties)\n  }\n\n  /**\n   * Encodes the specified Font message. Does not implicitly {@link Font.verify|verify} messages.\n   * @function encode\n   * @memberof Font\n   * @static\n   * @param {IFont} message Font message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Font.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.font != null && Object.hasOwnProperty.call(message, 'font'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.font)\n    if (message.family != null && Object.hasOwnProperty.call(message, 'family'))\n      writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.family)\n    if (message.size != null && Object.hasOwnProperty.call(message, 'size'))\n      writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.size)\n    if (\n      message.lineHeight != null &&\n      Object.hasOwnProperty.call(message, 'lineHeight')\n    )\n      writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.lineHeight)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Font message, length delimited. Does not implicitly {@link Font.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Font\n   * @static\n   * @param {IFont} message Font message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Font.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Font message from the specified reader or buffer.\n   * @function decode\n   * @memberof Font\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Font} Font\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Font.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Font()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.font = reader.bytes()\n          break\n        case 2:\n          message.family = reader.string()\n          break\n        case 3:\n          message.size = reader.int32()\n          break\n        case 4:\n          message.lineHeight = reader.int32()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Font message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Font\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Font} Font\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Font.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Font message.\n   * @function verify\n   * @memberof Font\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Font.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.font != null && message.hasOwnProperty('font'))\n      if (\n        !(\n          (message.font && typeof message.font.length === 'number') ||\n          $util.isString(message.font)\n        )\n      )\n        return 'font: buffer expected'\n    if (message.family != null && message.hasOwnProperty('family'))\n      if (!$util.isString(message.family)) return 'family: string expected'\n    if (message.size != null && message.hasOwnProperty('size'))\n      if (!$util.isInteger(message.size)) return 'size: integer expected'\n    if (message.lineHeight != null && message.hasOwnProperty('lineHeight'))\n      if (!$util.isInteger(message.lineHeight))\n        return 'lineHeight: integer expected'\n    return null\n  }\n\n  /**\n   * Creates a Font message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Font\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Font} Font\n   */\n  Font.fromObject = function fromObject(object) {\n    if (object instanceof $root.Font) return object\n    let message = new $root.Font()\n    if (object.font != null)\n      if (typeof object.font === 'string')\n        $util.base64.decode(\n          object.font,\n          (message.font = $util.newBuffer($util.base64.length(object.font))),\n          0,\n        )\n      else if (object.font.length) message.font = object.font\n    if (object.family != null) message.family = String(object.family)\n    if (object.size != null) message.size = object.size | 0\n    if (object.lineHeight != null) message.lineHeight = object.lineHeight | 0\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Font message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Font\n   * @static\n   * @param {Font} message Font\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Font.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      if (options.bytes === String) object.font = ''\n      else {\n        object.font = []\n        if (options.bytes !== Array) object.font = $util.newBuffer(object.font)\n      }\n      object.family = ''\n      object.size = 0\n      object.lineHeight = 0\n    }\n    if (message.font != null && message.hasOwnProperty('font'))\n      object.font =\n        options.bytes === String\n          ? $util.base64.encode(message.font, 0, message.font.length)\n          : options.bytes === Array\n          ? Array.prototype.slice.call(message.font)\n          : message.font\n    if (message.family != null && message.hasOwnProperty('family'))\n      object.family = message.family\n    if (message.size != null && message.hasOwnProperty('size'))\n      object.size = message.size\n    if (message.lineHeight != null && message.hasOwnProperty('lineHeight'))\n      object.lineHeight = message.lineHeight\n    return object\n  }\n\n  /**\n   * Converts this Font to JSON.\n   * @function toJSON\n   * @memberof Font\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Font.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Font\n})())\n\nexport const GlyphFont = ($root.GlyphFont = (() => {\n  /**\n   * Properties of a GlyphFont.\n   * @exports IGlyphFont\n   * @interface IGlyphFont\n   * @property {string|null} [letter] GlyphFont letter\n   * @property {IMetric|null} [adjustMetric] GlyphFont adjustMetric\n   * @property {Object.<string,number>|null} [kerning] GlyphFont kerning\n   */\n\n  /**\n   * Constructs a new GlyphFont.\n   * @exports GlyphFont\n   * @classdesc Represents a GlyphFont.\n   * @implements IGlyphFont\n   * @constructor\n   * @param {IGlyphFont=} [properties] Properties to set\n   */\n  function GlyphFont(properties) {\n    this.kerning = {}\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * GlyphFont letter.\n   * @member {string} letter\n   * @memberof GlyphFont\n   * @instance\n   */\n  GlyphFont.prototype.letter = ''\n\n  /**\n   * GlyphFont adjustMetric.\n   * @member {IMetric|null|undefined} adjustMetric\n   * @memberof GlyphFont\n   * @instance\n   */\n  GlyphFont.prototype.adjustMetric = null\n\n  /**\n   * GlyphFont kerning.\n   * @member {Object.<string,number>} kerning\n   * @memberof GlyphFont\n   * @instance\n   */\n  GlyphFont.prototype.kerning = $util.emptyObject\n\n  /**\n   * Creates a new GlyphFont instance using the specified properties.\n   * @function create\n   * @memberof GlyphFont\n   * @static\n   * @param {IGlyphFont=} [properties] Properties to set\n   * @returns {GlyphFont} GlyphFont instance\n   */\n  GlyphFont.create = function create(properties) {\n    return new GlyphFont(properties)\n  }\n\n  /**\n   * Encodes the specified GlyphFont message. Does not implicitly {@link GlyphFont.verify|verify} messages.\n   * @function encode\n   * @memberof GlyphFont\n   * @static\n   * @param {IGlyphFont} message GlyphFont message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GlyphFont.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.letter != null && Object.hasOwnProperty.call(message, 'letter'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.letter)\n    if (\n      message.adjustMetric != null &&\n      Object.hasOwnProperty.call(message, 'adjustMetric')\n    )\n      $root.Metric.encode(\n        message.adjustMetric,\n        writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n      ).ldelim()\n    if (\n      message.kerning != null &&\n      Object.hasOwnProperty.call(message, 'kerning')\n    )\n      for (let keys = Object.keys(message.kerning), i = 0; i < keys.length; ++i)\n        writer\n          .uint32(/* id 3, wireType 2 =*/ 26)\n          .fork()\n          .uint32(/* id 1, wireType 2 =*/ 10)\n          .string(keys[i])\n          .uint32(/* id 2, wireType 0 =*/ 16)\n          .int32(message.kerning[keys[i]])\n          .ldelim()\n    return writer\n  }\n\n  /**\n   * Encodes the specified GlyphFont message, length delimited. Does not implicitly {@link GlyphFont.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof GlyphFont\n   * @static\n   * @param {IGlyphFont} message GlyphFont message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GlyphFont.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a GlyphFont message from the specified reader or buffer.\n   * @function decode\n   * @memberof GlyphFont\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {GlyphFont} GlyphFont\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GlyphFont.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.GlyphFont(),\n      key,\n      value\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.letter = reader.string()\n          break\n        case 2:\n          message.adjustMetric = $root.Metric.decode(reader, reader.uint32())\n          break\n        case 3:\n          if (message.kerning === $util.emptyObject) message.kerning = {}\n          let end2 = reader.uint32() + reader.pos\n          key = ''\n          value = 0\n          while (reader.pos < end2) {\n            let tag2 = reader.uint32()\n            switch (tag2 >>> 3) {\n              case 1:\n                key = reader.string()\n                break\n              case 2:\n                value = reader.int32()\n                break\n              default:\n                reader.skipType(tag2 & 7)\n                break\n            }\n          }\n          message.kerning[key] = value\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a GlyphFont message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof GlyphFont\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {GlyphFont} GlyphFont\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GlyphFont.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a GlyphFont message.\n   * @function verify\n   * @memberof GlyphFont\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  GlyphFont.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.letter != null && message.hasOwnProperty('letter'))\n      if (!$util.isString(message.letter)) return 'letter: string expected'\n    if (\n      message.adjustMetric != null &&\n      message.hasOwnProperty('adjustMetric')\n    ) {\n      let error = $root.Metric.verify(message.adjustMetric)\n      if (error) return 'adjustMetric.' + error\n    }\n    if (message.kerning != null && message.hasOwnProperty('kerning')) {\n      if (!$util.isObject(message.kerning)) return 'kerning: object expected'\n      let key = Object.keys(message.kerning)\n      for (let i = 0; i < key.length; ++i)\n        if (!$util.isInteger(message.kerning[key[i]]))\n          return 'kerning: integer{k:string} expected'\n    }\n    return null\n  }\n\n  /**\n   * Creates a GlyphFont message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof GlyphFont\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {GlyphFont} GlyphFont\n   */\n  GlyphFont.fromObject = function fromObject(object) {\n    if (object instanceof $root.GlyphFont) return object\n    let message = new $root.GlyphFont()\n    if (object.letter != null) message.letter = String(object.letter)\n    if (object.adjustMetric != null) {\n      if (typeof object.adjustMetric !== 'object')\n        throw TypeError('.GlyphFont.adjustMetric: object expected')\n      message.adjustMetric = $root.Metric.fromObject(object.adjustMetric)\n    }\n    if (object.kerning) {\n      if (typeof object.kerning !== 'object')\n        throw TypeError('.GlyphFont.kerning: object expected')\n      message.kerning = {}\n      for (let keys = Object.keys(object.kerning), i = 0; i < keys.length; ++i)\n        message.kerning[keys[i]] = object.kerning[keys[i]] | 0\n    }\n    return message\n  }\n\n  /**\n   * Creates a plain object from a GlyphFont message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof GlyphFont\n   * @static\n   * @param {GlyphFont} message GlyphFont\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  GlyphFont.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.objects || options.defaults) object.kerning = {}\n    if (options.defaults) {\n      object.letter = ''\n      object.adjustMetric = null\n    }\n    if (message.letter != null && message.hasOwnProperty('letter'))\n      object.letter = message.letter\n    if (message.adjustMetric != null && message.hasOwnProperty('adjustMetric'))\n      object.adjustMetric = $root.Metric.toObject(message.adjustMetric, options)\n    let keys2\n    if (message.kerning && (keys2 = Object.keys(message.kerning)).length) {\n      object.kerning = {}\n      for (let j = 0; j < keys2.length; ++j)\n        object.kerning[keys2[j]] = message.kerning[keys2[j]]\n    }\n    return object\n  }\n\n  /**\n   * Converts this GlyphFont to JSON.\n   * @function toJSON\n   * @memberof GlyphFont\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  GlyphFont.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return GlyphFont\n})())\n\nexport const GlyphImage = ($root.GlyphImage = (() => {\n  /**\n   * Properties of a GlyphImage.\n   * @exports IGlyphImage\n   * @interface IGlyphImage\n   * @property {string|null} [letter] GlyphImage letter\n   * @property {IMetric|null} [adjustMetric] GlyphImage adjustMetric\n   * @property {Uint8Array|null} [buffer] GlyphImage buffer\n   * @property {string|null} [fileName] GlyphImage fileName\n   * @property {string|null} [fileType] GlyphImage fileType\n   * @property {boolean|null} [selected] GlyphImage selected\n   * @property {Object.<string,number>|null} [kerning] GlyphImage kerning\n   */\n\n  /**\n   * Constructs a new GlyphImage.\n   * @exports GlyphImage\n   * @classdesc Represents a GlyphImage.\n   * @implements IGlyphImage\n   * @constructor\n   * @param {IGlyphImage=} [properties] Properties to set\n   */\n  function GlyphImage(properties) {\n    this.kerning = {}\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * GlyphImage letter.\n   * @member {string} letter\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.letter = ''\n\n  /**\n   * GlyphImage adjustMetric.\n   * @member {IMetric|null|undefined} adjustMetric\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.adjustMetric = null\n\n  /**\n   * GlyphImage buffer.\n   * @member {Uint8Array} buffer\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.buffer = $util.newBuffer([])\n\n  /**\n   * GlyphImage fileName.\n   * @member {string} fileName\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.fileName = ''\n\n  /**\n   * GlyphImage fileType.\n   * @member {string} fileType\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.fileType = ''\n\n  /**\n   * GlyphImage selected.\n   * @member {boolean} selected\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.selected = false\n\n  /**\n   * GlyphImage kerning.\n   * @member {Object.<string,number>} kerning\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.kerning = $util.emptyObject\n\n  /**\n   * Creates a new GlyphImage instance using the specified properties.\n   * @function create\n   * @memberof GlyphImage\n   * @static\n   * @param {IGlyphImage=} [properties] Properties to set\n   * @returns {GlyphImage} GlyphImage instance\n   */\n  GlyphImage.create = function create(properties) {\n    return new GlyphImage(properties)\n  }\n\n  /**\n   * Encodes the specified GlyphImage message. Does not implicitly {@link GlyphImage.verify|verify} messages.\n   * @function encode\n   * @memberof GlyphImage\n   * @static\n   * @param {IGlyphImage} message GlyphImage message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GlyphImage.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.letter != null && Object.hasOwnProperty.call(message, 'letter'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.letter)\n    if (\n      message.adjustMetric != null &&\n      Object.hasOwnProperty.call(message, 'adjustMetric')\n    )\n      $root.Metric.encode(\n        message.adjustMetric,\n        writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n      ).ldelim()\n    if (message.buffer != null && Object.hasOwnProperty.call(message, 'buffer'))\n      writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.buffer)\n    if (\n      message.fileName != null &&\n      Object.hasOwnProperty.call(message, 'fileName')\n    )\n      writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.fileName)\n    if (\n      message.fileType != null &&\n      Object.hasOwnProperty.call(message, 'fileType')\n    )\n      writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.fileType)\n    if (\n      message.selected != null &&\n      Object.hasOwnProperty.call(message, 'selected')\n    )\n      writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.selected)\n    if (\n      message.kerning != null &&\n      Object.hasOwnProperty.call(message, 'kerning')\n    )\n      for (let keys = Object.keys(message.kerning), i = 0; i < keys.length; ++i)\n        writer\n          .uint32(/* id 7, wireType 2 =*/ 58)\n          .fork()\n          .uint32(/* id 1, wireType 2 =*/ 10)\n          .string(keys[i])\n          .uint32(/* id 2, wireType 0 =*/ 16)\n          .int32(message.kerning[keys[i]])\n          .ldelim()\n    return writer\n  }\n\n  /**\n   * Encodes the specified GlyphImage message, length delimited. Does not implicitly {@link GlyphImage.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof GlyphImage\n   * @static\n   * @param {IGlyphImage} message GlyphImage message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GlyphImage.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a GlyphImage message from the specified reader or buffer.\n   * @function decode\n   * @memberof GlyphImage\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {GlyphImage} GlyphImage\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GlyphImage.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.GlyphImage(),\n      key,\n      value\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.letter = reader.string()\n          break\n        case 2:\n          message.adjustMetric = $root.Metric.decode(reader, reader.uint32())\n          break\n        case 3:\n          message.buffer = reader.bytes()\n          break\n        case 4:\n          message.fileName = reader.string()\n          break\n        case 5:\n          message.fileType = reader.string()\n          break\n        case 6:\n          message.selected = reader.bool()\n          break\n        case 7:\n          if (message.kerning === $util.emptyObject) message.kerning = {}\n          let end2 = reader.uint32() + reader.pos\n          key = ''\n          value = 0\n          while (reader.pos < end2) {\n            let tag2 = reader.uint32()\n            switch (tag2 >>> 3) {\n              case 1:\n                key = reader.string()\n                break\n              case 2:\n                value = reader.int32()\n                break\n              default:\n                reader.skipType(tag2 & 7)\n                break\n            }\n          }\n          message.kerning[key] = value\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a GlyphImage message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof GlyphImage\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {GlyphImage} GlyphImage\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GlyphImage.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a GlyphImage message.\n   * @function verify\n   * @memberof GlyphImage\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  GlyphImage.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.letter != null && message.hasOwnProperty('letter'))\n      if (!$util.isString(message.letter)) return 'letter: string expected'\n    if (\n      message.adjustMetric != null &&\n      message.hasOwnProperty('adjustMetric')\n    ) {\n      let error = $root.Metric.verify(message.adjustMetric)\n      if (error) return 'adjustMetric.' + error\n    }\n    if (message.buffer != null && message.hasOwnProperty('buffer'))\n      if (\n        !(\n          (message.buffer && typeof message.buffer.length === 'number') ||\n          $util.isString(message.buffer)\n        )\n      )\n        return 'buffer: buffer expected'\n    if (message.fileName != null && message.hasOwnProperty('fileName'))\n      if (!$util.isString(message.fileName)) return 'fileName: string expected'\n    if (message.fileType != null && message.hasOwnProperty('fileType'))\n      if (!$util.isString(message.fileType)) return 'fileType: string expected'\n    if (message.selected != null && message.hasOwnProperty('selected'))\n      if (typeof message.selected !== 'boolean')\n        return 'selected: boolean expected'\n    if (message.kerning != null && message.hasOwnProperty('kerning')) {\n      if (!$util.isObject(message.kerning)) return 'kerning: object expected'\n      let key = Object.keys(message.kerning)\n      for (let i = 0; i < key.length; ++i)\n        if (!$util.isInteger(message.kerning[key[i]]))\n          return 'kerning: integer{k:string} expected'\n    }\n    return null\n  }\n\n  /**\n   * Creates a GlyphImage message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof GlyphImage\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {GlyphImage} GlyphImage\n   */\n  GlyphImage.fromObject = function fromObject(object) {\n    if (object instanceof $root.GlyphImage) return object\n    let message = new $root.GlyphImage()\n    if (object.letter != null) message.letter = String(object.letter)\n    if (object.adjustMetric != null) {\n      if (typeof object.adjustMetric !== 'object')\n        throw TypeError('.GlyphImage.adjustMetric: object expected')\n      message.adjustMetric = $root.Metric.fromObject(object.adjustMetric)\n    }\n    if (object.buffer != null)\n      if (typeof object.buffer === 'string')\n        $util.base64.decode(\n          object.buffer,\n          (message.buffer = $util.newBuffer(\n            $util.base64.length(object.buffer),\n          )),\n          0,\n        )\n      else if (object.buffer.length) message.buffer = object.buffer\n    if (object.fileName != null) message.fileName = String(object.fileName)\n    if (object.fileType != null) message.fileType = String(object.fileType)\n    if (object.selected != null) message.selected = Boolean(object.selected)\n    if (object.kerning) {\n      if (typeof object.kerning !== 'object')\n        throw TypeError('.GlyphImage.kerning: object expected')\n      message.kerning = {}\n      for (let keys = Object.keys(object.kerning), i = 0; i < keys.length; ++i)\n        message.kerning[keys[i]] = object.kerning[keys[i]] | 0\n    }\n    return message\n  }\n\n  /**\n   * Creates a plain object from a GlyphImage message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof GlyphImage\n   * @static\n   * @param {GlyphImage} message GlyphImage\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  GlyphImage.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.objects || options.defaults) object.kerning = {}\n    if (options.defaults) {\n      object.letter = ''\n      object.adjustMetric = null\n      if (options.bytes === String) object.buffer = ''\n      else {\n        object.buffer = []\n        if (options.bytes !== Array)\n          object.buffer = $util.newBuffer(object.buffer)\n      }\n      object.fileName = ''\n      object.fileType = ''\n      object.selected = false\n    }\n    if (message.letter != null && message.hasOwnProperty('letter'))\n      object.letter = message.letter\n    if (message.adjustMetric != null && message.hasOwnProperty('adjustMetric'))\n      object.adjustMetric = $root.Metric.toObject(message.adjustMetric, options)\n    if (message.buffer != null && message.hasOwnProperty('buffer'))\n      object.buffer =\n        options.bytes === String\n          ? $util.base64.encode(message.buffer, 0, message.buffer.length)\n          : options.bytes === Array\n          ? Array.prototype.slice.call(message.buffer)\n          : message.buffer\n    if (message.fileName != null && message.hasOwnProperty('fileName'))\n      object.fileName = message.fileName\n    if (message.fileType != null && message.hasOwnProperty('fileType'))\n      object.fileType = message.fileType\n    if (message.selected != null && message.hasOwnProperty('selected'))\n      object.selected = message.selected\n    let keys2\n    if (message.kerning && (keys2 = Object.keys(message.kerning)).length) {\n      object.kerning = {}\n      for (let j = 0; j < keys2.length; ++j)\n        object.kerning[keys2[j]] = message.kerning[keys2[j]]\n    }\n    return object\n  }\n\n  /**\n   * Converts this GlyphImage to JSON.\n   * @function toJSON\n   * @memberof GlyphImage\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  GlyphImage.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return GlyphImage\n})())\n\nexport const Layout = ($root.Layout = (() => {\n  /**\n   * Properties of a Layout.\n   * @exports ILayout\n   * @interface ILayout\n   * @property {number|null} [padding] Layout padding\n   * @property {number|null} [spacing] Layout spacing\n   * @property {number|null} [width] Layout width\n   * @property {number|null} [height] Layout height\n   * @property {boolean|null} [auto] Layout auto\n   * @property {boolean|null} [fixedSize] Layout fixedSize\n   */\n\n  /**\n   * Constructs a new Layout.\n   * @exports Layout\n   * @classdesc Represents a Layout.\n   * @implements ILayout\n   * @constructor\n   * @param {ILayout=} [properties] Properties to set\n   */\n  function Layout(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Layout padding.\n   * @member {number} padding\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.padding = 0\n\n  /**\n   * Layout spacing.\n   * @member {number} spacing\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.spacing = 0\n\n  /**\n   * Layout width.\n   * @member {number} width\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.width = 0\n\n  /**\n   * Layout height.\n   * @member {number} height\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.height = 0\n\n  /**\n   * Layout auto.\n   * @member {boolean} auto\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.auto = false\n\n  /**\n   * Layout fixedSize.\n   * @member {boolean} fixedSize\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.fixedSize = false\n\n  /**\n   * Creates a new Layout instance using the specified properties.\n   * @function create\n   * @memberof Layout\n   * @static\n   * @param {ILayout=} [properties] Properties to set\n   * @returns {Layout} Layout instance\n   */\n  Layout.create = function create(properties) {\n    return new Layout(properties)\n  }\n\n  /**\n   * Encodes the specified Layout message. Does not implicitly {@link Layout.verify|verify} messages.\n   * @function encode\n   * @memberof Layout\n   * @static\n   * @param {ILayout} message Layout message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Layout.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (\n      message.padding != null &&\n      Object.hasOwnProperty.call(message, 'padding')\n    )\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.padding)\n    if (\n      message.spacing != null &&\n      Object.hasOwnProperty.call(message, 'spacing')\n    )\n      writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.spacing)\n    if (message.width != null && Object.hasOwnProperty.call(message, 'width'))\n      writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.width)\n    if (message.height != null && Object.hasOwnProperty.call(message, 'height'))\n      writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.height)\n    if (message.auto != null && Object.hasOwnProperty.call(message, 'auto'))\n      writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.auto)\n    if (\n      message.fixedSize != null &&\n      Object.hasOwnProperty.call(message, 'fixedSize')\n    )\n      writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.fixedSize)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Layout message, length delimited. Does not implicitly {@link Layout.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Layout\n   * @static\n   * @param {ILayout} message Layout message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Layout.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Layout message from the specified reader or buffer.\n   * @function decode\n   * @memberof Layout\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Layout} Layout\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Layout.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Layout()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.padding = reader.int32()\n          break\n        case 2:\n          message.spacing = reader.int32()\n          break\n        case 3:\n          message.width = reader.int32()\n          break\n        case 4:\n          message.height = reader.int32()\n          break\n        case 5:\n          message.auto = reader.bool()\n          break\n        case 6:\n          message.fixedSize = reader.bool()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Layout message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Layout\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Layout} Layout\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Layout.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Layout message.\n   * @function verify\n   * @memberof Layout\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Layout.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.padding != null && message.hasOwnProperty('padding'))\n      if (!$util.isInteger(message.padding)) return 'padding: integer expected'\n    if (message.spacing != null && message.hasOwnProperty('spacing'))\n      if (!$util.isInteger(message.spacing)) return 'spacing: integer expected'\n    if (message.width != null && message.hasOwnProperty('width'))\n      if (!$util.isInteger(message.width)) return 'width: integer expected'\n    if (message.height != null && message.hasOwnProperty('height'))\n      if (!$util.isInteger(message.height)) return 'height: integer expected'\n    if (message.auto != null && message.hasOwnProperty('auto'))\n      if (typeof message.auto !== 'boolean') return 'auto: boolean expected'\n    if (message.fixedSize != null && message.hasOwnProperty('fixedSize'))\n      if (typeof message.fixedSize !== 'boolean')\n        return 'fixedSize: boolean expected'\n    return null\n  }\n\n  /**\n   * Creates a Layout message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Layout\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Layout} Layout\n   */\n  Layout.fromObject = function fromObject(object) {\n    if (object instanceof $root.Layout) return object\n    let message = new $root.Layout()\n    if (object.padding != null) message.padding = object.padding | 0\n    if (object.spacing != null) message.spacing = object.spacing | 0\n    if (object.width != null) message.width = object.width | 0\n    if (object.height != null) message.height = object.height | 0\n    if (object.auto != null) message.auto = Boolean(object.auto)\n    if (object.fixedSize != null) message.fixedSize = Boolean(object.fixedSize)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Layout message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Layout\n   * @static\n   * @param {Layout} message Layout\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Layout.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.padding = 0\n      object.spacing = 0\n      object.width = 0\n      object.height = 0\n      object.auto = false\n      object.fixedSize = false\n    }\n    if (message.padding != null && message.hasOwnProperty('padding'))\n      object.padding = message.padding\n    if (message.spacing != null && message.hasOwnProperty('spacing'))\n      object.spacing = message.spacing\n    if (message.width != null && message.hasOwnProperty('width'))\n      object.width = message.width\n    if (message.height != null && message.hasOwnProperty('height'))\n      object.height = message.height\n    if (message.auto != null && message.hasOwnProperty('auto'))\n      object.auto = message.auto\n    if (message.fixedSize != null && message.hasOwnProperty('fixedSize'))\n      object.fixedSize = message.fixedSize\n    return object\n  }\n\n  /**\n   * Converts this Layout to JSON.\n   * @function toJSON\n   * @memberof Layout\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Layout.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Layout\n})())\n\nexport const Shadow = ($root.Shadow = (() => {\n  /**\n   * Properties of a Shadow.\n   * @exports IShadow\n   * @interface IShadow\n   * @property {string|null} [color] Shadow color\n   * @property {number|null} [blur] Shadow blur\n   * @property {number|null} [offsetX] Shadow offsetX\n   * @property {number|null} [offsetY] Shadow offsetY\n   */\n\n  /**\n   * Constructs a new Shadow.\n   * @exports Shadow\n   * @classdesc Represents a Shadow.\n   * @implements IShadow\n   * @constructor\n   * @param {IShadow=} [properties] Properties to set\n   */\n  function Shadow(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Shadow color.\n   * @member {string} color\n   * @memberof Shadow\n   * @instance\n   */\n  Shadow.prototype.color = ''\n\n  /**\n   * Shadow blur.\n   * @member {number} blur\n   * @memberof Shadow\n   * @instance\n   */\n  Shadow.prototype.blur = 0\n\n  /**\n   * Shadow offsetX.\n   * @member {number} offsetX\n   * @memberof Shadow\n   * @instance\n   */\n  Shadow.prototype.offsetX = 0\n\n  /**\n   * Shadow offsetY.\n   * @member {number} offsetY\n   * @memberof Shadow\n   * @instance\n   */\n  Shadow.prototype.offsetY = 0\n\n  /**\n   * Creates a new Shadow instance using the specified properties.\n   * @function create\n   * @memberof Shadow\n   * @static\n   * @param {IShadow=} [properties] Properties to set\n   * @returns {Shadow} Shadow instance\n   */\n  Shadow.create = function create(properties) {\n    return new Shadow(properties)\n  }\n\n  /**\n   * Encodes the specified Shadow message. Does not implicitly {@link Shadow.verify|verify} messages.\n   * @function encode\n   * @memberof Shadow\n   * @static\n   * @param {IShadow} message Shadow message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Shadow.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.color != null && Object.hasOwnProperty.call(message, 'color'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.color)\n    if (message.blur != null && Object.hasOwnProperty.call(message, 'blur'))\n      writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.blur)\n    if (\n      message.offsetX != null &&\n      Object.hasOwnProperty.call(message, 'offsetX')\n    )\n      writer.uint32(/* id 3, wireType 0 =*/ 24).sint32(message.offsetX)\n    if (\n      message.offsetY != null &&\n      Object.hasOwnProperty.call(message, 'offsetY')\n    )\n      writer.uint32(/* id 4, wireType 0 =*/ 32).sint32(message.offsetY)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Shadow message, length delimited. Does not implicitly {@link Shadow.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Shadow\n   * @static\n   * @param {IShadow} message Shadow message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Shadow.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Shadow message from the specified reader or buffer.\n   * @function decode\n   * @memberof Shadow\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Shadow} Shadow\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Shadow.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Shadow()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.color = reader.string()\n          break\n        case 2:\n          message.blur = reader.int32()\n          break\n        case 3:\n          message.offsetX = reader.sint32()\n          break\n        case 4:\n          message.offsetY = reader.sint32()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Shadow message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Shadow\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Shadow} Shadow\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Shadow.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Shadow message.\n   * @function verify\n   * @memberof Shadow\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Shadow.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.color != null && message.hasOwnProperty('color'))\n      if (!$util.isString(message.color)) return 'color: string expected'\n    if (message.blur != null && message.hasOwnProperty('blur'))\n      if (!$util.isInteger(message.blur)) return 'blur: integer expected'\n    if (message.offsetX != null && message.hasOwnProperty('offsetX'))\n      if (!$util.isInteger(message.offsetX)) return 'offsetX: integer expected'\n    if (message.offsetY != null && message.hasOwnProperty('offsetY'))\n      if (!$util.isInteger(message.offsetY)) return 'offsetY: integer expected'\n    return null\n  }\n\n  /**\n   * Creates a Shadow message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Shadow\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Shadow} Shadow\n   */\n  Shadow.fromObject = function fromObject(object) {\n    if (object instanceof $root.Shadow) return object\n    let message = new $root.Shadow()\n    if (object.color != null) message.color = String(object.color)\n    if (object.blur != null) message.blur = object.blur | 0\n    if (object.offsetX != null) message.offsetX = object.offsetX | 0\n    if (object.offsetY != null) message.offsetY = object.offsetY | 0\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Shadow message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Shadow\n   * @static\n   * @param {Shadow} message Shadow\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Shadow.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.color = ''\n      object.blur = 0\n      object.offsetX = 0\n      object.offsetY = 0\n    }\n    if (message.color != null && message.hasOwnProperty('color'))\n      object.color = message.color\n    if (message.blur != null && message.hasOwnProperty('blur'))\n      object.blur = message.blur\n    if (message.offsetX != null && message.hasOwnProperty('offsetX'))\n      object.offsetX = message.offsetX\n    if (message.offsetY != null && message.hasOwnProperty('offsetY'))\n      object.offsetY = message.offsetY\n    return object\n  }\n\n  /**\n   * Converts this Shadow to JSON.\n   * @function toJSON\n   * @memberof Shadow\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Shadow.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Shadow\n})())\n\nexport const Style = ($root.Style = (() => {\n  /**\n   * Properties of a Style.\n   * @exports IStyle\n   * @interface IStyle\n   * @property {IFont|null} [font] Style font\n   * @property {IFill|null} [fill] Style fill\n   * @property {boolean|null} [useStroke] Style useStroke\n   * @property {IFill|null} [stroke] Style stroke\n   * @property {boolean|null} [useShadow] Style useShadow\n   * @property {IShadow|null} [shadow] Style shadow\n   * @property {string|null} [bgColor] Style bgColor\n   */\n\n  /**\n   * Constructs a new Style.\n   * @exports Style\n   * @classdesc Represents a Style.\n   * @implements IStyle\n   * @constructor\n   * @param {IStyle=} [properties] Properties to set\n   */\n  function Style(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Style font.\n   * @member {IFont|null|undefined} font\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.font = null\n\n  /**\n   * Style fill.\n   * @member {IFill|null|undefined} fill\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.fill = null\n\n  /**\n   * Style useStroke.\n   * @member {boolean} useStroke\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.useStroke = false\n\n  /**\n   * Style stroke.\n   * @member {IFill|null|undefined} stroke\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.stroke = null\n\n  /**\n   * Style useShadow.\n   * @member {boolean} useShadow\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.useShadow = false\n\n  /**\n   * Style shadow.\n   * @member {IShadow|null|undefined} shadow\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.shadow = null\n\n  /**\n   * Style bgColor.\n   * @member {string} bgColor\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.bgColor = ''\n\n  /**\n   * Creates a new Style instance using the specified properties.\n   * @function create\n   * @memberof Style\n   * @static\n   * @param {IStyle=} [properties] Properties to set\n   * @returns {Style} Style instance\n   */\n  Style.create = function create(properties) {\n    return new Style(properties)\n  }\n\n  /**\n   * Encodes the specified Style message. Does not implicitly {@link Style.verify|verify} messages.\n   * @function encode\n   * @memberof Style\n   * @static\n   * @param {IStyle} message Style message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Style.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.font != null && Object.hasOwnProperty.call(message, 'font'))\n      $root.Font.encode(\n        message.font,\n        writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),\n      ).ldelim()\n    if (message.fill != null && Object.hasOwnProperty.call(message, 'fill'))\n      $root.Fill.encode(\n        message.fill,\n        writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n      ).ldelim()\n    if (\n      message.useStroke != null &&\n      Object.hasOwnProperty.call(message, 'useStroke')\n    )\n      writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.useStroke)\n    if (message.stroke != null && Object.hasOwnProperty.call(message, 'stroke'))\n      $root.Fill.encode(\n        message.stroke,\n        writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),\n      ).ldelim()\n    if (\n      message.useShadow != null &&\n      Object.hasOwnProperty.call(message, 'useShadow')\n    )\n      writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.useShadow)\n    if (message.shadow != null && Object.hasOwnProperty.call(message, 'shadow'))\n      $root.Shadow.encode(\n        message.shadow,\n        writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),\n      ).ldelim()\n    if (\n      message.bgColor != null &&\n      Object.hasOwnProperty.call(message, 'bgColor')\n    )\n      writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.bgColor)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Style message, length delimited. Does not implicitly {@link Style.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Style\n   * @static\n   * @param {IStyle} message Style message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Style.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Style message from the specified reader or buffer.\n   * @function decode\n   * @memberof Style\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Style} Style\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Style.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Style()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.font = $root.Font.decode(reader, reader.uint32())\n          break\n        case 2:\n          message.fill = $root.Fill.decode(reader, reader.uint32())\n          break\n        case 3:\n          message.useStroke = reader.bool()\n          break\n        case 4:\n          message.stroke = $root.Fill.decode(reader, reader.uint32())\n          break\n        case 5:\n          message.useShadow = reader.bool()\n          break\n        case 6:\n          message.shadow = $root.Shadow.decode(reader, reader.uint32())\n          break\n        case 7:\n          message.bgColor = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Style message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Style\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Style} Style\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Style.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Style message.\n   * @function verify\n   * @memberof Style\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Style.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.font != null && message.hasOwnProperty('font')) {\n      let error = $root.Font.verify(message.font)\n      if (error) return 'font.' + error\n    }\n    if (message.fill != null && message.hasOwnProperty('fill')) {\n      let error = $root.Fill.verify(message.fill)\n      if (error) return 'fill.' + error\n    }\n    if (message.useStroke != null && message.hasOwnProperty('useStroke'))\n      if (typeof message.useStroke !== 'boolean')\n        return 'useStroke: boolean expected'\n    if (message.stroke != null && message.hasOwnProperty('stroke')) {\n      let error = $root.Fill.verify(message.stroke)\n      if (error) return 'stroke.' + error\n    }\n    if (message.useShadow != null && message.hasOwnProperty('useShadow'))\n      if (typeof message.useShadow !== 'boolean')\n        return 'useShadow: boolean expected'\n    if (message.shadow != null && message.hasOwnProperty('shadow')) {\n      let error = $root.Shadow.verify(message.shadow)\n      if (error) return 'shadow.' + error\n    }\n    if (message.bgColor != null && message.hasOwnProperty('bgColor'))\n      if (!$util.isString(message.bgColor)) return 'bgColor: string expected'\n    return null\n  }\n\n  /**\n   * Creates a Style message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Style\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Style} Style\n   */\n  Style.fromObject = function fromObject(object) {\n    if (object instanceof $root.Style) return object\n    let message = new $root.Style()\n    if (object.font != null) {\n      if (typeof object.font !== 'object')\n        throw TypeError('.Style.font: object expected')\n      message.font = $root.Font.fromObject(object.font)\n    }\n    if (object.fill != null) {\n      if (typeof object.fill !== 'object')\n        throw TypeError('.Style.fill: object expected')\n      message.fill = $root.Fill.fromObject(object.fill)\n    }\n    if (object.useStroke != null) message.useStroke = Boolean(object.useStroke)\n    if (object.stroke != null) {\n      if (typeof object.stroke !== 'object')\n        throw TypeError('.Style.stroke: object expected')\n      message.stroke = $root.Fill.fromObject(object.stroke)\n    }\n    if (object.useShadow != null) message.useShadow = Boolean(object.useShadow)\n    if (object.shadow != null) {\n      if (typeof object.shadow !== 'object')\n        throw TypeError('.Style.shadow: object expected')\n      message.shadow = $root.Shadow.fromObject(object.shadow)\n    }\n    if (object.bgColor != null) message.bgColor = String(object.bgColor)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Style message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Style\n   * @static\n   * @param {Style} message Style\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Style.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.font = null\n      object.fill = null\n      object.useStroke = false\n      object.stroke = null\n      object.useShadow = false\n      object.shadow = null\n      object.bgColor = ''\n    }\n    if (message.font != null && message.hasOwnProperty('font'))\n      object.font = $root.Font.toObject(message.font, options)\n    if (message.fill != null && message.hasOwnProperty('fill'))\n      object.fill = $root.Fill.toObject(message.fill, options)\n    if (message.useStroke != null && message.hasOwnProperty('useStroke'))\n      object.useStroke = message.useStroke\n    if (message.stroke != null && message.hasOwnProperty('stroke'))\n      object.stroke = $root.Fill.toObject(message.stroke, options)\n    if (message.useShadow != null && message.hasOwnProperty('useShadow'))\n      object.useShadow = message.useShadow\n    if (message.shadow != null && message.hasOwnProperty('shadow'))\n      object.shadow = $root.Shadow.toObject(message.shadow, options)\n    if (message.bgColor != null && message.hasOwnProperty('bgColor'))\n      object.bgColor = message.bgColor\n    return object\n  }\n\n  /**\n   * Converts this Style to JSON.\n   * @function toJSON\n   * @memberof Style\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Style.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Style\n})())\n\nexport const Ui = ($root.Ui = (() => {\n  /**\n   * Properties of an Ui.\n   * @exports IUi\n   * @interface IUi\n   * @property {string|null} [previewText] Ui previewText\n   */\n\n  /**\n   * Constructs a new Ui.\n   * @exports Ui\n   * @classdesc Represents an Ui.\n   * @implements IUi\n   * @constructor\n   * @param {IUi=} [properties] Properties to set\n   */\n  function Ui(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Ui previewText.\n   * @member {string} previewText\n   * @memberof Ui\n   * @instance\n   */\n  Ui.prototype.previewText = ''\n\n  /**\n   * Creates a new Ui instance using the specified properties.\n   * @function create\n   * @memberof Ui\n   * @static\n   * @param {IUi=} [properties] Properties to set\n   * @returns {Ui} Ui instance\n   */\n  Ui.create = function create(properties) {\n    return new Ui(properties)\n  }\n\n  /**\n   * Encodes the specified Ui message. Does not implicitly {@link Ui.verify|verify} messages.\n   * @function encode\n   * @memberof Ui\n   * @static\n   * @param {IUi} message Ui message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Ui.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (\n      message.previewText != null &&\n      Object.hasOwnProperty.call(message, 'previewText')\n    )\n      writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.previewText)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Ui message, length delimited. Does not implicitly {@link Ui.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Ui\n   * @static\n   * @param {IUi} message Ui message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Ui.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes an Ui message from the specified reader or buffer.\n   * @function decode\n   * @memberof Ui\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Ui} Ui\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Ui.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Ui()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.previewText = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes an Ui message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Ui\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Ui} Ui\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Ui.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies an Ui message.\n   * @function verify\n   * @memberof Ui\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Ui.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.previewText != null && message.hasOwnProperty('previewText'))\n      if (!$util.isString(message.previewText))\n        return 'previewText: string expected'\n    return null\n  }\n\n  /**\n   * Creates an Ui message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Ui\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Ui} Ui\n   */\n  Ui.fromObject = function fromObject(object) {\n    if (object instanceof $root.Ui) return object\n    let message = new $root.Ui()\n    if (object.previewText != null)\n      message.previewText = String(object.previewText)\n    return message\n  }\n\n  /**\n   * Creates a plain object from an Ui message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Ui\n   * @static\n   * @param {Ui} message Ui\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Ui.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) object.previewText = ''\n    if (message.previewText != null && message.hasOwnProperty('previewText'))\n      object.previewText = message.previewText\n    return object\n  }\n\n  /**\n   * Converts this Ui to JSON.\n   * @function toJSON\n   * @memberof Ui\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Ui.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Ui\n})())\n\nexport const Project = ($root.Project = (() => {\n  /**\n   * Properties of a Project.\n   * @exports IProject\n   * @interface IProject\n   * @property {number|Long|null} [id] Project id\n   * @property {string|null} [name] Project name\n   * @property {string|null} [text] Project text\n   * @property {Object.<string,IGlyphFont>|null} [glyphs] Project glyphs\n   * @property {Array.<IGlyphImage>|null} [glyphImages] Project glyphImages\n   * @property {IStyle|null} [style] Project style\n   * @property {ILayout|null} [layout] Project layout\n   * @property {IMetric|null} [globalAdjustMetric] Project globalAdjustMetric\n   * @property {IUi|null} [ui] Project ui\n   */\n\n  /**\n   * Constructs a new Project.\n   * @exports Project\n   * @classdesc Represents a Project.\n   * @implements IProject\n   * @constructor\n   * @param {IProject=} [properties] Properties to set\n   */\n  function Project(properties) {\n    this.glyphs = {}\n    this.glyphImages = []\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Project id.\n   * @member {number|Long} id\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, false) : 0\n\n  /**\n   * Project name.\n   * @member {string} name\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.name = ''\n\n  /**\n   * Project text.\n   * @member {string} text\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.text = ''\n\n  /**\n   * Project glyphs.\n   * @member {Object.<string,IGlyphFont>} glyphs\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.glyphs = $util.emptyObject\n\n  /**\n   * Project glyphImages.\n   * @member {Array.<IGlyphImage>} glyphImages\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.glyphImages = $util.emptyArray\n\n  /**\n   * Project style.\n   * @member {IStyle|null|undefined} style\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.style = null\n\n  /**\n   * Project layout.\n   * @member {ILayout|null|undefined} layout\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.layout = null\n\n  /**\n   * Project globalAdjustMetric.\n   * @member {IMetric|null|undefined} globalAdjustMetric\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.globalAdjustMetric = null\n\n  /**\n   * Project ui.\n   * @member {IUi|null|undefined} ui\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.ui = null\n\n  /**\n   * Creates a new Project instance using the specified properties.\n   * @function create\n   * @memberof Project\n   * @static\n   * @param {IProject=} [properties] Properties to set\n   * @returns {Project} Project instance\n   */\n  Project.create = function create(properties) {\n    return new Project(properties)\n  }\n\n  /**\n   * Encodes the specified Project message. Does not implicitly {@link Project.verify|verify} messages.\n   * @function encode\n   * @memberof Project\n   * @static\n   * @param {IProject} message Project message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Project.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.id != null && Object.hasOwnProperty.call(message, 'id'))\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.id)\n    if (message.name != null && Object.hasOwnProperty.call(message, 'name'))\n      writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name)\n    if (message.text != null && Object.hasOwnProperty.call(message, 'text'))\n      writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.text)\n    if (message.glyphs != null && Object.hasOwnProperty.call(message, 'glyphs'))\n      for (\n        let keys = Object.keys(message.glyphs), i = 0;\n        i < keys.length;\n        ++i\n      ) {\n        writer\n          .uint32(/* id 4, wireType 2 =*/ 34)\n          .fork()\n          .uint32(/* id 1, wireType 2 =*/ 10)\n          .string(keys[i])\n        $root.GlyphFont.encode(\n          message.glyphs[keys[i]],\n          writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n        )\n          .ldelim()\n          .ldelim()\n      }\n    if (message.glyphImages != null && message.glyphImages.length)\n      for (let i = 0; i < message.glyphImages.length; ++i)\n        $root.GlyphImage.encode(\n          message.glyphImages[i],\n          writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),\n        ).ldelim()\n    if (message.style != null && Object.hasOwnProperty.call(message, 'style'))\n      $root.Style.encode(\n        message.style,\n        writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),\n      ).ldelim()\n    if (message.layout != null && Object.hasOwnProperty.call(message, 'layout'))\n      $root.Layout.encode(\n        message.layout,\n        writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),\n      ).ldelim()\n    if (\n      message.globalAdjustMetric != null &&\n      Object.hasOwnProperty.call(message, 'globalAdjustMetric')\n    )\n      $root.Metric.encode(\n        message.globalAdjustMetric,\n        writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),\n      ).ldelim()\n    if (message.ui != null && Object.hasOwnProperty.call(message, 'ui'))\n      $root.Ui.encode(\n        message.ui,\n        writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),\n      ).ldelim()\n    return writer\n  }\n\n  /**\n   * Encodes the specified Project message, length delimited. Does not implicitly {@link Project.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Project\n   * @static\n   * @param {IProject} message Project message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Project.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Project message from the specified reader or buffer.\n   * @function decode\n   * @memberof Project\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Project} Project\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Project.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Project(),\n      key,\n      value\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.int64()\n          break\n        case 2:\n          message.name = reader.string()\n          break\n        case 3:\n          message.text = reader.string()\n          break\n        case 4:\n          if (message.glyphs === $util.emptyObject) message.glyphs = {}\n          let end2 = reader.uint32() + reader.pos\n          key = ''\n          value = null\n          while (reader.pos < end2) {\n            let tag2 = reader.uint32()\n            switch (tag2 >>> 3) {\n              case 1:\n                key = reader.string()\n                break\n              case 2:\n                value = $root.GlyphFont.decode(reader, reader.uint32())\n                break\n              default:\n                reader.skipType(tag2 & 7)\n                break\n            }\n          }\n          message.glyphs[key] = value\n          break\n        case 5:\n          if (!(message.glyphImages && message.glyphImages.length))\n            message.glyphImages = []\n          message.glyphImages.push(\n            $root.GlyphImage.decode(reader, reader.uint32()),\n          )\n          break\n        case 6:\n          message.style = $root.Style.decode(reader, reader.uint32())\n          break\n        case 7:\n          message.layout = $root.Layout.decode(reader, reader.uint32())\n          break\n        case 8:\n          message.globalAdjustMetric = $root.Metric.decode(\n            reader,\n            reader.uint32(),\n          )\n          break\n        case 9:\n          message.ui = $root.Ui.decode(reader, reader.uint32())\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Project message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Project\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Project} Project\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Project.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Project message.\n   * @function verify\n   * @memberof Project\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Project.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.id != null && message.hasOwnProperty('id'))\n      if (\n        !$util.isInteger(message.id) &&\n        !(\n          message.id &&\n          $util.isInteger(message.id.low) &&\n          $util.isInteger(message.id.high)\n        )\n      )\n        return 'id: integer|Long expected'\n    if (message.name != null && message.hasOwnProperty('name'))\n      if (!$util.isString(message.name)) return 'name: string expected'\n    if (message.text != null && message.hasOwnProperty('text'))\n      if (!$util.isString(message.text)) return 'text: string expected'\n    if (message.glyphs != null && message.hasOwnProperty('glyphs')) {\n      if (!$util.isObject(message.glyphs)) return 'glyphs: object expected'\n      let key = Object.keys(message.glyphs)\n      for (let i = 0; i < key.length; ++i) {\n        let error = $root.GlyphFont.verify(message.glyphs[key[i]])\n        if (error) return 'glyphs.' + error\n      }\n    }\n    if (message.glyphImages != null && message.hasOwnProperty('glyphImages')) {\n      if (!Array.isArray(message.glyphImages))\n        return 'glyphImages: array expected'\n      for (let i = 0; i < message.glyphImages.length; ++i) {\n        let error = $root.GlyphImage.verify(message.glyphImages[i])\n        if (error) return 'glyphImages.' + error\n      }\n    }\n    if (message.style != null && message.hasOwnProperty('style')) {\n      let error = $root.Style.verify(message.style)\n      if (error) return 'style.' + error\n    }\n    if (message.layout != null && message.hasOwnProperty('layout')) {\n      let error = $root.Layout.verify(message.layout)\n      if (error) return 'layout.' + error\n    }\n    if (\n      message.globalAdjustMetric != null &&\n      message.hasOwnProperty('globalAdjustMetric')\n    ) {\n      let error = $root.Metric.verify(message.globalAdjustMetric)\n      if (error) return 'globalAdjustMetric.' + error\n    }\n    if (message.ui != null && message.hasOwnProperty('ui')) {\n      let error = $root.Ui.verify(message.ui)\n      if (error) return 'ui.' + error\n    }\n    return null\n  }\n\n  /**\n   * Creates a Project message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Project\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Project} Project\n   */\n  Project.fromObject = function fromObject(object) {\n    if (object instanceof $root.Project) return object\n    let message = new $root.Project()\n    if (object.id != null)\n      if ($util.Long)\n        (message.id = $util.Long.fromValue(object.id)).unsigned = false\n      else if (typeof object.id === 'string')\n        message.id = parseInt(object.id, 10)\n      else if (typeof object.id === 'number') message.id = object.id\n      else if (typeof object.id === 'object')\n        message.id = new $util.LongBits(\n          object.id.low >>> 0,\n          object.id.high >>> 0,\n        ).toNumber()\n    if (object.name != null) message.name = String(object.name)\n    if (object.text != null) message.text = String(object.text)\n    if (object.glyphs) {\n      if (typeof object.glyphs !== 'object')\n        throw TypeError('.Project.glyphs: object expected')\n      message.glyphs = {}\n      for (let keys = Object.keys(object.glyphs), i = 0; i < keys.length; ++i) {\n        if (typeof object.glyphs[keys[i]] !== 'object')\n          throw TypeError('.Project.glyphs: object expected')\n        message.glyphs[keys[i]] = $root.GlyphFont.fromObject(\n          object.glyphs[keys[i]],\n        )\n      }\n    }\n    if (object.glyphImages) {\n      if (!Array.isArray(object.glyphImages))\n        throw TypeError('.Project.glyphImages: array expected')\n      message.glyphImages = []\n      for (let i = 0; i < object.glyphImages.length; ++i) {\n        if (typeof object.glyphImages[i] !== 'object')\n          throw TypeError('.Project.glyphImages: object expected')\n        message.glyphImages[i] = $root.GlyphImage.fromObject(\n          object.glyphImages[i],\n        )\n      }\n    }\n    if (object.style != null) {\n      if (typeof object.style !== 'object')\n        throw TypeError('.Project.style: object expected')\n      message.style = $root.Style.fromObject(object.style)\n    }\n    if (object.layout != null) {\n      if (typeof object.layout !== 'object')\n        throw TypeError('.Project.layout: object expected')\n      message.layout = $root.Layout.fromObject(object.layout)\n    }\n    if (object.globalAdjustMetric != null) {\n      if (typeof object.globalAdjustMetric !== 'object')\n        throw TypeError('.Project.globalAdjustMetric: object expected')\n      message.globalAdjustMetric = $root.Metric.fromObject(\n        object.globalAdjustMetric,\n      )\n    }\n    if (object.ui != null) {\n      if (typeof object.ui !== 'object')\n        throw TypeError('.Project.ui: object expected')\n      message.ui = $root.Ui.fromObject(object.ui)\n    }\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Project message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Project\n   * @static\n   * @param {Project} message Project\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Project.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.arrays || options.defaults) object.glyphImages = []\n    if (options.objects || options.defaults) object.glyphs = {}\n    if (options.defaults) {\n      if ($util.Long) {\n        let long = new $util.Long(0, 0, false)\n        object.id =\n          options.longs === String\n            ? long.toString()\n            : options.longs === Number\n            ? long.toNumber()\n            : long\n      } else object.id = options.longs === String ? '0' : 0\n      object.name = ''\n      object.text = ''\n      object.style = null\n      object.layout = null\n      object.globalAdjustMetric = null\n      object.ui = null\n    }\n    if (message.id != null && message.hasOwnProperty('id'))\n      if (typeof message.id === 'number')\n        object.id = options.longs === String ? String(message.id) : message.id\n      else\n        object.id =\n          options.longs === String\n            ? $util.Long.prototype.toString.call(message.id)\n            : options.longs === Number\n            ? new $util.LongBits(\n                message.id.low >>> 0,\n                message.id.high >>> 0,\n              ).toNumber()\n            : message.id\n    if (message.name != null && message.hasOwnProperty('name'))\n      object.name = message.name\n    if (message.text != null && message.hasOwnProperty('text'))\n      object.text = message.text\n    let keys2\n    if (message.glyphs && (keys2 = Object.keys(message.glyphs)).length) {\n      object.glyphs = {}\n      for (let j = 0; j < keys2.length; ++j)\n        object.glyphs[keys2[j]] = $root.GlyphFont.toObject(\n          message.glyphs[keys2[j]],\n          options,\n        )\n    }\n    if (message.glyphImages && message.glyphImages.length) {\n      object.glyphImages = []\n      for (let j = 0; j < message.glyphImages.length; ++j)\n        object.glyphImages[j] = $root.GlyphImage.toObject(\n          message.glyphImages[j],\n          options,\n        )\n    }\n    if (message.style != null && message.hasOwnProperty('style'))\n      object.style = $root.Style.toObject(message.style, options)\n    if (message.layout != null && message.hasOwnProperty('layout'))\n      object.layout = $root.Layout.toObject(message.layout, options)\n    if (\n      message.globalAdjustMetric != null &&\n      message.hasOwnProperty('globalAdjustMetric')\n    )\n      object.globalAdjustMetric = $root.Metric.toObject(\n        message.globalAdjustMetric,\n        options,\n      )\n    if (message.ui != null && message.hasOwnProperty('ui'))\n      object.ui = $root.Ui.toObject(message.ui, options)\n    return object\n  }\n\n  /**\n   * Converts this Project to JSON.\n   * @function toJSON\n   * @memberof Project\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Project.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Project\n})())\n\nexport { $root as default }\n","import { IProject } from './project'\nimport { IProject as IProjectNext, IFont } from '../1.0.3'\n\nexport default function updateToNext(project: IProject): IProjectNext {\n  if (project.style?.font?.font) {\n    ;(project.style.font as IFont).fonts = [{ font: project.style.font.font }]\n  }\n  return project\n}\n","/* eslint-disable */\nimport * as $protobuf from 'protobufjs/minimal'\n\n// Common aliases\nconst $Reader = $protobuf.Reader,\n  $Writer = $protobuf.Writer,\n  $util = $protobuf.util\n\n// Exported root namespace\nconst $root = $protobuf.roots['default'] || ($protobuf.roots['default'] = {})\n\nexport const Metric = ($root.Metric = (() => {\n  /**\n   * Properties of a Metric.\n   * @exports IMetric\n   * @interface IMetric\n   * @property {number|null} [xAdvance] Metric xAdvance\n   * @property {number|null} [xOffset] Metric xOffset\n   * @property {number|null} [yOffset] Metric yOffset\n   */\n\n  /**\n   * Constructs a new Metric.\n   * @exports Metric\n   * @classdesc Represents a Metric.\n   * @implements IMetric\n   * @constructor\n   * @param {IMetric=} [properties] Properties to set\n   */\n  function Metric(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Metric xAdvance.\n   * @member {number} xAdvance\n   * @memberof Metric\n   * @instance\n   */\n  Metric.prototype.xAdvance = 0\n\n  /**\n   * Metric xOffset.\n   * @member {number} xOffset\n   * @memberof Metric\n   * @instance\n   */\n  Metric.prototype.xOffset = 0\n\n  /**\n   * Metric yOffset.\n   * @member {number} yOffset\n   * @memberof Metric\n   * @instance\n   */\n  Metric.prototype.yOffset = 0\n\n  /**\n   * Creates a new Metric instance using the specified properties.\n   * @function create\n   * @memberof Metric\n   * @static\n   * @param {IMetric=} [properties] Properties to set\n   * @returns {Metric} Metric instance\n   */\n  Metric.create = function create(properties) {\n    return new Metric(properties)\n  }\n\n  /**\n   * Encodes the specified Metric message. Does not implicitly {@link Metric.verify|verify} messages.\n   * @function encode\n   * @memberof Metric\n   * @static\n   * @param {IMetric} message Metric message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Metric.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (\n      message.xAdvance != null &&\n      Object.hasOwnProperty.call(message, 'xAdvance')\n    )\n      writer.uint32(/* id 1, wireType 0 =*/ 8).sint32(message.xAdvance)\n    if (\n      message.xOffset != null &&\n      Object.hasOwnProperty.call(message, 'xOffset')\n    )\n      writer.uint32(/* id 2, wireType 0 =*/ 16).sint32(message.xOffset)\n    if (\n      message.yOffset != null &&\n      Object.hasOwnProperty.call(message, 'yOffset')\n    )\n      writer.uint32(/* id 3, wireType 0 =*/ 24).sint32(message.yOffset)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Metric message, length delimited. Does not implicitly {@link Metric.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Metric\n   * @static\n   * @param {IMetric} message Metric message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Metric.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Metric message from the specified reader or buffer.\n   * @function decode\n   * @memberof Metric\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Metric} Metric\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Metric.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Metric()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.xAdvance = reader.sint32()\n          break\n        case 2:\n          message.xOffset = reader.sint32()\n          break\n        case 3:\n          message.yOffset = reader.sint32()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Metric message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Metric\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Metric} Metric\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Metric.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Metric message.\n   * @function verify\n   * @memberof Metric\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Metric.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.xAdvance != null && message.hasOwnProperty('xAdvance'))\n      if (!$util.isInteger(message.xAdvance))\n        return 'xAdvance: integer expected'\n    if (message.xOffset != null && message.hasOwnProperty('xOffset'))\n      if (!$util.isInteger(message.xOffset)) return 'xOffset: integer expected'\n    if (message.yOffset != null && message.hasOwnProperty('yOffset'))\n      if (!$util.isInteger(message.yOffset)) return 'yOffset: integer expected'\n    return null\n  }\n\n  /**\n   * Creates a Metric message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Metric\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Metric} Metric\n   */\n  Metric.fromObject = function fromObject(object) {\n    if (object instanceof $root.Metric) return object\n    let message = new $root.Metric()\n    if (object.xAdvance != null) message.xAdvance = object.xAdvance | 0\n    if (object.xOffset != null) message.xOffset = object.xOffset | 0\n    if (object.yOffset != null) message.yOffset = object.yOffset | 0\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Metric message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Metric\n   * @static\n   * @param {Metric} message Metric\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Metric.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.xAdvance = 0\n      object.xOffset = 0\n      object.yOffset = 0\n    }\n    if (message.xAdvance != null && message.hasOwnProperty('xAdvance'))\n      object.xAdvance = message.xAdvance\n    if (message.xOffset != null && message.hasOwnProperty('xOffset'))\n      object.xOffset = message.xOffset\n    if (message.yOffset != null && message.hasOwnProperty('yOffset'))\n      object.yOffset = message.yOffset\n    return object\n  }\n\n  /**\n   * Converts this Metric to JSON.\n   * @function toJSON\n   * @memberof Metric\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Metric.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Metric\n})())\n\nexport const GradientColor = ($root.GradientColor = (() => {\n  /**\n   * Properties of a GradientColor.\n   * @exports IGradientColor\n   * @interface IGradientColor\n   * @property {number|null} [id] GradientColor id\n   * @property {number|null} [offset] GradientColor offset\n   * @property {string|null} [color] GradientColor color\n   */\n\n  /**\n   * Constructs a new GradientColor.\n   * @exports GradientColor\n   * @classdesc Represents a GradientColor.\n   * @implements IGradientColor\n   * @constructor\n   * @param {IGradientColor=} [properties] Properties to set\n   */\n  function GradientColor(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * GradientColor id.\n   * @member {number} id\n   * @memberof GradientColor\n   * @instance\n   */\n  GradientColor.prototype.id = 0\n\n  /**\n   * GradientColor offset.\n   * @member {number} offset\n   * @memberof GradientColor\n   * @instance\n   */\n  GradientColor.prototype.offset = 0\n\n  /**\n   * GradientColor color.\n   * @member {string} color\n   * @memberof GradientColor\n   * @instance\n   */\n  GradientColor.prototype.color = ''\n\n  /**\n   * Creates a new GradientColor instance using the specified properties.\n   * @function create\n   * @memberof GradientColor\n   * @static\n   * @param {IGradientColor=} [properties] Properties to set\n   * @returns {GradientColor} GradientColor instance\n   */\n  GradientColor.create = function create(properties) {\n    return new GradientColor(properties)\n  }\n\n  /**\n   * Encodes the specified GradientColor message. Does not implicitly {@link GradientColor.verify|verify} messages.\n   * @function encode\n   * @memberof GradientColor\n   * @static\n   * @param {IGradientColor} message GradientColor message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GradientColor.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.id != null && Object.hasOwnProperty.call(message, 'id'))\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.id)\n    if (message.offset != null && Object.hasOwnProperty.call(message, 'offset'))\n      writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.offset)\n    if (message.color != null && Object.hasOwnProperty.call(message, 'color'))\n      writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.color)\n    return writer\n  }\n\n  /**\n   * Encodes the specified GradientColor message, length delimited. Does not implicitly {@link GradientColor.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof GradientColor\n   * @static\n   * @param {IGradientColor} message GradientColor message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GradientColor.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a GradientColor message from the specified reader or buffer.\n   * @function decode\n   * @memberof GradientColor\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {GradientColor} GradientColor\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GradientColor.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.GradientColor()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.int32()\n          break\n        case 2:\n          message.offset = reader.float()\n          break\n        case 3:\n          message.color = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a GradientColor message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof GradientColor\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {GradientColor} GradientColor\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GradientColor.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a GradientColor message.\n   * @function verify\n   * @memberof GradientColor\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  GradientColor.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.id != null && message.hasOwnProperty('id'))\n      if (!$util.isInteger(message.id)) return 'id: integer expected'\n    if (message.offset != null && message.hasOwnProperty('offset'))\n      if (typeof message.offset !== 'number') return 'offset: number expected'\n    if (message.color != null && message.hasOwnProperty('color'))\n      if (!$util.isString(message.color)) return 'color: string expected'\n    return null\n  }\n\n  /**\n   * Creates a GradientColor message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof GradientColor\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {GradientColor} GradientColor\n   */\n  GradientColor.fromObject = function fromObject(object) {\n    if (object instanceof $root.GradientColor) return object\n    let message = new $root.GradientColor()\n    if (object.id != null) message.id = object.id | 0\n    if (object.offset != null) message.offset = Number(object.offset)\n    if (object.color != null) message.color = String(object.color)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a GradientColor message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof GradientColor\n   * @static\n   * @param {GradientColor} message GradientColor\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  GradientColor.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.id = 0\n      object.offset = 0\n      object.color = ''\n    }\n    if (message.id != null && message.hasOwnProperty('id'))\n      object.id = message.id\n    if (message.offset != null && message.hasOwnProperty('offset'))\n      object.offset =\n        options.json && !isFinite(message.offset)\n          ? String(message.offset)\n          : message.offset\n    if (message.color != null && message.hasOwnProperty('color'))\n      object.color = message.color\n    return object\n  }\n\n  /**\n   * Converts this GradientColor to JSON.\n   * @function toJSON\n   * @memberof GradientColor\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  GradientColor.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return GradientColor\n})())\n\nexport const Gradient = ($root.Gradient = (() => {\n  /**\n   * Properties of a Gradient.\n   * @exports IGradient\n   * @interface IGradient\n   * @property {number|null} [type] Gradient type\n   * @property {number|null} [angle] Gradient angle\n   * @property {Array.<IGradientColor>|null} [palette] Gradient palette\n   */\n\n  /**\n   * Constructs a new Gradient.\n   * @exports Gradient\n   * @classdesc Represents a Gradient.\n   * @implements IGradient\n   * @constructor\n   * @param {IGradient=} [properties] Properties to set\n   */\n  function Gradient(properties) {\n    this.palette = []\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Gradient type.\n   * @member {number} type\n   * @memberof Gradient\n   * @instance\n   */\n  Gradient.prototype.type = 0\n\n  /**\n   * Gradient angle.\n   * @member {number} angle\n   * @memberof Gradient\n   * @instance\n   */\n  Gradient.prototype.angle = 0\n\n  /**\n   * Gradient palette.\n   * @member {Array.<IGradientColor>} palette\n   * @memberof Gradient\n   * @instance\n   */\n  Gradient.prototype.palette = $util.emptyArray\n\n  /**\n   * Creates a new Gradient instance using the specified properties.\n   * @function create\n   * @memberof Gradient\n   * @static\n   * @param {IGradient=} [properties] Properties to set\n   * @returns {Gradient} Gradient instance\n   */\n  Gradient.create = function create(properties) {\n    return new Gradient(properties)\n  }\n\n  /**\n   * Encodes the specified Gradient message. Does not implicitly {@link Gradient.verify|verify} messages.\n   * @function encode\n   * @memberof Gradient\n   * @static\n   * @param {IGradient} message Gradient message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Gradient.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.type != null && Object.hasOwnProperty.call(message, 'type'))\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.type)\n    if (message.angle != null && Object.hasOwnProperty.call(message, 'angle'))\n      writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.angle)\n    if (message.palette != null && message.palette.length)\n      for (let i = 0; i < message.palette.length; ++i)\n        $root.GradientColor.encode(\n          message.palette[i],\n          writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),\n        ).ldelim()\n    return writer\n  }\n\n  /**\n   * Encodes the specified Gradient message, length delimited. Does not implicitly {@link Gradient.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Gradient\n   * @static\n   * @param {IGradient} message Gradient message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Gradient.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Gradient message from the specified reader or buffer.\n   * @function decode\n   * @memberof Gradient\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Gradient} Gradient\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Gradient.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Gradient()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32()\n          break\n        case 2:\n          message.angle = reader.float()\n          break\n        case 3:\n          if (!(message.palette && message.palette.length)) message.palette = []\n          message.palette.push(\n            $root.GradientColor.decode(reader, reader.uint32()),\n          )\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Gradient message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Gradient\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Gradient} Gradient\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Gradient.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Gradient message.\n   * @function verify\n   * @memberof Gradient\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Gradient.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.type != null && message.hasOwnProperty('type'))\n      if (!$util.isInteger(message.type)) return 'type: integer expected'\n    if (message.angle != null && message.hasOwnProperty('angle'))\n      if (typeof message.angle !== 'number') return 'angle: number expected'\n    if (message.palette != null && message.hasOwnProperty('palette')) {\n      if (!Array.isArray(message.palette)) return 'palette: array expected'\n      for (let i = 0; i < message.palette.length; ++i) {\n        let error = $root.GradientColor.verify(message.palette[i])\n        if (error) return 'palette.' + error\n      }\n    }\n    return null\n  }\n\n  /**\n   * Creates a Gradient message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Gradient\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Gradient} Gradient\n   */\n  Gradient.fromObject = function fromObject(object) {\n    if (object instanceof $root.Gradient) return object\n    let message = new $root.Gradient()\n    if (object.type != null) message.type = object.type | 0\n    if (object.angle != null) message.angle = Number(object.angle)\n    if (object.palette) {\n      if (!Array.isArray(object.palette))\n        throw TypeError('.Gradient.palette: array expected')\n      message.palette = []\n      for (let i = 0; i < object.palette.length; ++i) {\n        if (typeof object.palette[i] !== 'object')\n          throw TypeError('.Gradient.palette: object expected')\n        message.palette[i] = $root.GradientColor.fromObject(object.palette[i])\n      }\n    }\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Gradient message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Gradient\n   * @static\n   * @param {Gradient} message Gradient\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Gradient.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.arrays || options.defaults) object.palette = []\n    if (options.defaults) {\n      object.type = 0\n      object.angle = 0\n    }\n    if (message.type != null && message.hasOwnProperty('type'))\n      object.type = message.type\n    if (message.angle != null && message.hasOwnProperty('angle'))\n      object.angle =\n        options.json && !isFinite(message.angle)\n          ? String(message.angle)\n          : message.angle\n    if (message.palette && message.palette.length) {\n      object.palette = []\n      for (let j = 0; j < message.palette.length; ++j)\n        object.palette[j] = $root.GradientColor.toObject(\n          message.palette[j],\n          options,\n        )\n    }\n    return object\n  }\n\n  /**\n   * Converts this Gradient to JSON.\n   * @function toJSON\n   * @memberof Gradient\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Gradient.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Gradient\n})())\n\nexport const PatternTexture = ($root.PatternTexture = (() => {\n  /**\n   * Properties of a PatternTexture.\n   * @exports IPatternTexture\n   * @interface IPatternTexture\n   * @property {Uint8Array|null} [buffer] PatternTexture buffer\n   * @property {number|null} [scale] PatternTexture scale\n   * @property {string|null} [repetition] PatternTexture repetition\n   */\n\n  /**\n   * Constructs a new PatternTexture.\n   * @exports PatternTexture\n   * @classdesc Represents a PatternTexture.\n   * @implements IPatternTexture\n   * @constructor\n   * @param {IPatternTexture=} [properties] Properties to set\n   */\n  function PatternTexture(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * PatternTexture buffer.\n   * @member {Uint8Array} buffer\n   * @memberof PatternTexture\n   * @instance\n   */\n  PatternTexture.prototype.buffer = $util.newBuffer([])\n\n  /**\n   * PatternTexture scale.\n   * @member {number} scale\n   * @memberof PatternTexture\n   * @instance\n   */\n  PatternTexture.prototype.scale = 0\n\n  /**\n   * PatternTexture repetition.\n   * @member {string} repetition\n   * @memberof PatternTexture\n   * @instance\n   */\n  PatternTexture.prototype.repetition = ''\n\n  /**\n   * Creates a new PatternTexture instance using the specified properties.\n   * @function create\n   * @memberof PatternTexture\n   * @static\n   * @param {IPatternTexture=} [properties] Properties to set\n   * @returns {PatternTexture} PatternTexture instance\n   */\n  PatternTexture.create = function create(properties) {\n    return new PatternTexture(properties)\n  }\n\n  /**\n   * Encodes the specified PatternTexture message. Does not implicitly {@link PatternTexture.verify|verify} messages.\n   * @function encode\n   * @memberof PatternTexture\n   * @static\n   * @param {IPatternTexture} message PatternTexture message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  PatternTexture.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.buffer != null && Object.hasOwnProperty.call(message, 'buffer'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.buffer)\n    if (message.scale != null && Object.hasOwnProperty.call(message, 'scale'))\n      writer.uint32(/* id 2, wireType 1 =*/ 17).double(message.scale)\n    if (\n      message.repetition != null &&\n      Object.hasOwnProperty.call(message, 'repetition')\n    )\n      writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.repetition)\n    return writer\n  }\n\n  /**\n   * Encodes the specified PatternTexture message, length delimited. Does not implicitly {@link PatternTexture.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof PatternTexture\n   * @static\n   * @param {IPatternTexture} message PatternTexture message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  PatternTexture.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a PatternTexture message from the specified reader or buffer.\n   * @function decode\n   * @memberof PatternTexture\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {PatternTexture} PatternTexture\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  PatternTexture.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.PatternTexture()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.buffer = reader.bytes()\n          break\n        case 2:\n          message.scale = reader.double()\n          break\n        case 3:\n          message.repetition = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a PatternTexture message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof PatternTexture\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {PatternTexture} PatternTexture\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  PatternTexture.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a PatternTexture message.\n   * @function verify\n   * @memberof PatternTexture\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  PatternTexture.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.buffer != null && message.hasOwnProperty('buffer'))\n      if (\n        !(\n          (message.buffer && typeof message.buffer.length === 'number') ||\n          $util.isString(message.buffer)\n        )\n      )\n        return 'buffer: buffer expected'\n    if (message.scale != null && message.hasOwnProperty('scale'))\n      if (typeof message.scale !== 'number') return 'scale: number expected'\n    if (message.repetition != null && message.hasOwnProperty('repetition'))\n      if (!$util.isString(message.repetition))\n        return 'repetition: string expected'\n    return null\n  }\n\n  /**\n   * Creates a PatternTexture message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof PatternTexture\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {PatternTexture} PatternTexture\n   */\n  PatternTexture.fromObject = function fromObject(object) {\n    if (object instanceof $root.PatternTexture) return object\n    let message = new $root.PatternTexture()\n    if (object.buffer != null)\n      if (typeof object.buffer === 'string')\n        $util.base64.decode(\n          object.buffer,\n          (message.buffer = $util.newBuffer(\n            $util.base64.length(object.buffer),\n          )),\n          0,\n        )\n      else if (object.buffer.length) message.buffer = object.buffer\n    if (object.scale != null) message.scale = Number(object.scale)\n    if (object.repetition != null)\n      message.repetition = String(object.repetition)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a PatternTexture message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof PatternTexture\n   * @static\n   * @param {PatternTexture} message PatternTexture\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  PatternTexture.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      if (options.bytes === String) object.buffer = ''\n      else {\n        object.buffer = []\n        if (options.bytes !== Array)\n          object.buffer = $util.newBuffer(object.buffer)\n      }\n      object.scale = 0\n      object.repetition = ''\n    }\n    if (message.buffer != null && message.hasOwnProperty('buffer'))\n      object.buffer =\n        options.bytes === String\n          ? $util.base64.encode(message.buffer, 0, message.buffer.length)\n          : options.bytes === Array\n          ? Array.prototype.slice.call(message.buffer)\n          : message.buffer\n    if (message.scale != null && message.hasOwnProperty('scale'))\n      object.scale =\n        options.json && !isFinite(message.scale)\n          ? String(message.scale)\n          : message.scale\n    if (message.repetition != null && message.hasOwnProperty('repetition'))\n      object.repetition = message.repetition\n    return object\n  }\n\n  /**\n   * Converts this PatternTexture to JSON.\n   * @function toJSON\n   * @memberof PatternTexture\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  PatternTexture.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return PatternTexture\n})())\n\nexport const Fill = ($root.Fill = (() => {\n  /**\n   * Properties of a Fill.\n   * @exports IFill\n   * @interface IFill\n   * @property {number|null} [type] Fill type\n   * @property {string|null} [color] Fill color\n   * @property {IGradient|null} [gradient] Fill gradient\n   * @property {IPatternTexture|null} [patternTexture] Fill patternTexture\n   * @property {number|null} [width] Fill width\n   * @property {string|null} [lineCap] Fill lineCap\n   * @property {string|null} [lineJoin] Fill lineJoin\n   */\n\n  /**\n   * Constructs a new Fill.\n   * @exports Fill\n   * @classdesc Represents a Fill.\n   * @implements IFill\n   * @constructor\n   * @param {IFill=} [properties] Properties to set\n   */\n  function Fill(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Fill type.\n   * @member {number} type\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.type = 0\n\n  /**\n   * Fill color.\n   * @member {string} color\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.color = ''\n\n  /**\n   * Fill gradient.\n   * @member {IGradient|null|undefined} gradient\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.gradient = null\n\n  /**\n   * Fill patternTexture.\n   * @member {IPatternTexture|null|undefined} patternTexture\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.patternTexture = null\n\n  /**\n   * Fill width.\n   * @member {number} width\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.width = 0\n\n  /**\n   * Fill lineCap.\n   * @member {string} lineCap\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.lineCap = ''\n\n  /**\n   * Fill lineJoin.\n   * @member {string} lineJoin\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.lineJoin = ''\n\n  /**\n   * Creates a new Fill instance using the specified properties.\n   * @function create\n   * @memberof Fill\n   * @static\n   * @param {IFill=} [properties] Properties to set\n   * @returns {Fill} Fill instance\n   */\n  Fill.create = function create(properties) {\n    return new Fill(properties)\n  }\n\n  /**\n   * Encodes the specified Fill message. Does not implicitly {@link Fill.verify|verify} messages.\n   * @function encode\n   * @memberof Fill\n   * @static\n   * @param {IFill} message Fill message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Fill.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.type != null && Object.hasOwnProperty.call(message, 'type'))\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.type)\n    if (message.color != null && Object.hasOwnProperty.call(message, 'color'))\n      writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.color)\n    if (\n      message.gradient != null &&\n      Object.hasOwnProperty.call(message, 'gradient')\n    )\n      $root.Gradient.encode(\n        message.gradient,\n        writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),\n      ).ldelim()\n    if (\n      message.patternTexture != null &&\n      Object.hasOwnProperty.call(message, 'patternTexture')\n    )\n      $root.PatternTexture.encode(\n        message.patternTexture,\n        writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),\n      ).ldelim()\n    if (message.width != null && Object.hasOwnProperty.call(message, 'width'))\n      writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.width)\n    if (\n      message.lineCap != null &&\n      Object.hasOwnProperty.call(message, 'lineCap')\n    )\n      writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.lineCap)\n    if (\n      message.lineJoin != null &&\n      Object.hasOwnProperty.call(message, 'lineJoin')\n    )\n      writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.lineJoin)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Fill message, length delimited. Does not implicitly {@link Fill.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Fill\n   * @static\n   * @param {IFill} message Fill message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Fill.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Fill message from the specified reader or buffer.\n   * @function decode\n   * @memberof Fill\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Fill} Fill\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Fill.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Fill()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32()\n          break\n        case 2:\n          message.color = reader.string()\n          break\n        case 3:\n          message.gradient = $root.Gradient.decode(reader, reader.uint32())\n          break\n        case 4:\n          message.patternTexture = $root.PatternTexture.decode(\n            reader,\n            reader.uint32(),\n          )\n          break\n        case 5:\n          message.width = reader.int32()\n          break\n        case 6:\n          message.lineCap = reader.string()\n          break\n        case 7:\n          message.lineJoin = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Fill message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Fill\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Fill} Fill\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Fill.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Fill message.\n   * @function verify\n   * @memberof Fill\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Fill.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.type != null && message.hasOwnProperty('type'))\n      if (!$util.isInteger(message.type)) return 'type: integer expected'\n    if (message.color != null && message.hasOwnProperty('color'))\n      if (!$util.isString(message.color)) return 'color: string expected'\n    if (message.gradient != null && message.hasOwnProperty('gradient')) {\n      let error = $root.Gradient.verify(message.gradient)\n      if (error) return 'gradient.' + error\n    }\n    if (\n      message.patternTexture != null &&\n      message.hasOwnProperty('patternTexture')\n    ) {\n      let error = $root.PatternTexture.verify(message.patternTexture)\n      if (error) return 'patternTexture.' + error\n    }\n    if (message.width != null && message.hasOwnProperty('width'))\n      if (!$util.isInteger(message.width)) return 'width: integer expected'\n    if (message.lineCap != null && message.hasOwnProperty('lineCap'))\n      if (!$util.isString(message.lineCap)) return 'lineCap: string expected'\n    if (message.lineJoin != null && message.hasOwnProperty('lineJoin'))\n      if (!$util.isString(message.lineJoin)) return 'lineJoin: string expected'\n    return null\n  }\n\n  /**\n   * Creates a Fill message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Fill\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Fill} Fill\n   */\n  Fill.fromObject = function fromObject(object) {\n    if (object instanceof $root.Fill) return object\n    let message = new $root.Fill()\n    if (object.type != null) message.type = object.type | 0\n    if (object.color != null) message.color = String(object.color)\n    if (object.gradient != null) {\n      if (typeof object.gradient !== 'object')\n        throw TypeError('.Fill.gradient: object expected')\n      message.gradient = $root.Gradient.fromObject(object.gradient)\n    }\n    if (object.patternTexture != null) {\n      if (typeof object.patternTexture !== 'object')\n        throw TypeError('.Fill.patternTexture: object expected')\n      message.patternTexture = $root.PatternTexture.fromObject(\n        object.patternTexture,\n      )\n    }\n    if (object.width != null) message.width = object.width | 0\n    if (object.lineCap != null) message.lineCap = String(object.lineCap)\n    if (object.lineJoin != null) message.lineJoin = String(object.lineJoin)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Fill message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Fill\n   * @static\n   * @param {Fill} message Fill\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Fill.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.type = 0\n      object.color = ''\n      object.gradient = null\n      object.patternTexture = null\n      object.width = 0\n      object.lineCap = ''\n      object.lineJoin = ''\n    }\n    if (message.type != null && message.hasOwnProperty('type'))\n      object.type = message.type\n    if (message.color != null && message.hasOwnProperty('color'))\n      object.color = message.color\n    if (message.gradient != null && message.hasOwnProperty('gradient'))\n      object.gradient = $root.Gradient.toObject(message.gradient, options)\n    if (\n      message.patternTexture != null &&\n      message.hasOwnProperty('patternTexture')\n    )\n      object.patternTexture = $root.PatternTexture.toObject(\n        message.patternTexture,\n        options,\n      )\n    if (message.width != null && message.hasOwnProperty('width'))\n      object.width = message.width\n    if (message.lineCap != null && message.hasOwnProperty('lineCap'))\n      object.lineCap = message.lineCap\n    if (message.lineJoin != null && message.hasOwnProperty('lineJoin'))\n      object.lineJoin = message.lineJoin\n    return object\n  }\n\n  /**\n   * Converts this Fill to JSON.\n   * @function toJSON\n   * @memberof Fill\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Fill.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Fill\n})())\n\nexport const FontResource = ($root.FontResource = (() => {\n  /**\n   * Properties of a FontResource.\n   * @exports IFontResource\n   * @interface IFontResource\n   * @property {Uint8Array|null} [font] FontResource font\n   */\n\n  /**\n   * Constructs a new FontResource.\n   * @exports FontResource\n   * @classdesc Represents a FontResource.\n   * @implements IFontResource\n   * @constructor\n   * @param {IFontResource=} [properties] Properties to set\n   */\n  function FontResource(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * FontResource font.\n   * @member {Uint8Array} font\n   * @memberof FontResource\n   * @instance\n   */\n  FontResource.prototype.font = $util.newBuffer([])\n\n  /**\n   * Creates a new FontResource instance using the specified properties.\n   * @function create\n   * @memberof FontResource\n   * @static\n   * @param {IFontResource=} [properties] Properties to set\n   * @returns {FontResource} FontResource instance\n   */\n  FontResource.create = function create(properties) {\n    return new FontResource(properties)\n  }\n\n  /**\n   * Encodes the specified FontResource message. Does not implicitly {@link FontResource.verify|verify} messages.\n   * @function encode\n   * @memberof FontResource\n   * @static\n   * @param {IFontResource} message FontResource message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  FontResource.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.font != null && Object.hasOwnProperty.call(message, 'font'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.font)\n    return writer\n  }\n\n  /**\n   * Encodes the specified FontResource message, length delimited. Does not implicitly {@link FontResource.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof FontResource\n   * @static\n   * @param {IFontResource} message FontResource message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  FontResource.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a FontResource message from the specified reader or buffer.\n   * @function decode\n   * @memberof FontResource\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {FontResource} FontResource\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  FontResource.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.FontResource()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.font = reader.bytes()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a FontResource message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof FontResource\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {FontResource} FontResource\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  FontResource.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a FontResource message.\n   * @function verify\n   * @memberof FontResource\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  FontResource.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.font != null && message.hasOwnProperty('font'))\n      if (\n        !(\n          (message.font && typeof message.font.length === 'number') ||\n          $util.isString(message.font)\n        )\n      )\n        return 'font: buffer expected'\n    return null\n  }\n\n  /**\n   * Creates a FontResource message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof FontResource\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {FontResource} FontResource\n   */\n  FontResource.fromObject = function fromObject(object) {\n    if (object instanceof $root.FontResource) return object\n    let message = new $root.FontResource()\n    if (object.font != null)\n      if (typeof object.font === 'string')\n        $util.base64.decode(\n          object.font,\n          (message.font = $util.newBuffer($util.base64.length(object.font))),\n          0,\n        )\n      else if (object.font.length) message.font = object.font\n    return message\n  }\n\n  /**\n   * Creates a plain object from a FontResource message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof FontResource\n   * @static\n   * @param {FontResource} message FontResource\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  FontResource.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults)\n      if (options.bytes === String) object.font = ''\n      else {\n        object.font = []\n        if (options.bytes !== Array) object.font = $util.newBuffer(object.font)\n      }\n    if (message.font != null && message.hasOwnProperty('font'))\n      object.font =\n        options.bytes === String\n          ? $util.base64.encode(message.font, 0, message.font.length)\n          : options.bytes === Array\n          ? Array.prototype.slice.call(message.font)\n          : message.font\n    return object\n  }\n\n  /**\n   * Converts this FontResource to JSON.\n   * @function toJSON\n   * @memberof FontResource\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  FontResource.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return FontResource\n})())\n\nexport const Font = ($root.Font = (() => {\n  /**\n   * Properties of a Font.\n   * @exports IFont\n   * @interface IFont\n   * @property {Array.<IFontResource>|null} [fonts] Font fonts\n   * @property {number|null} [size] Font size\n   * @property {number|null} [lineHeight] Font lineHeight\n   */\n\n  /**\n   * Constructs a new Font.\n   * @exports Font\n   * @classdesc Represents a Font.\n   * @implements IFont\n   * @constructor\n   * @param {IFont=} [properties] Properties to set\n   */\n  function Font(properties) {\n    this.fonts = []\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Font fonts.\n   * @member {Array.<IFontResource>} fonts\n   * @memberof Font\n   * @instance\n   */\n  Font.prototype.fonts = $util.emptyArray\n\n  /**\n   * Font size.\n   * @member {number} size\n   * @memberof Font\n   * @instance\n   */\n  Font.prototype.size = 0\n\n  /**\n   * Font lineHeight.\n   * @member {number} lineHeight\n   * @memberof Font\n   * @instance\n   */\n  Font.prototype.lineHeight = 0\n\n  /**\n   * Creates a new Font instance using the specified properties.\n   * @function create\n   * @memberof Font\n   * @static\n   * @param {IFont=} [properties] Properties to set\n   * @returns {Font} Font instance\n   */\n  Font.create = function create(properties) {\n    return new Font(properties)\n  }\n\n  /**\n   * Encodes the specified Font message. Does not implicitly {@link Font.verify|verify} messages.\n   * @function encode\n   * @memberof Font\n   * @static\n   * @param {IFont} message Font message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Font.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.fonts != null && message.fonts.length)\n      for (let i = 0; i < message.fonts.length; ++i)\n        $root.FontResource.encode(\n          message.fonts[i],\n          writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),\n        ).ldelim()\n    if (message.size != null && Object.hasOwnProperty.call(message, 'size'))\n      writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.size)\n    if (\n      message.lineHeight != null &&\n      Object.hasOwnProperty.call(message, 'lineHeight')\n    )\n      writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.lineHeight)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Font message, length delimited. Does not implicitly {@link Font.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Font\n   * @static\n   * @param {IFont} message Font message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Font.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Font message from the specified reader or buffer.\n   * @function decode\n   * @memberof Font\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Font} Font\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Font.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Font()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.fonts && message.fonts.length)) message.fonts = []\n          message.fonts.push($root.FontResource.decode(reader, reader.uint32()))\n          break\n        case 2:\n          message.size = reader.int32()\n          break\n        case 3:\n          message.lineHeight = reader.int32()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Font message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Font\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Font} Font\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Font.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Font message.\n   * @function verify\n   * @memberof Font\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Font.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.fonts != null && message.hasOwnProperty('fonts')) {\n      if (!Array.isArray(message.fonts)) return 'fonts: array expected'\n      for (let i = 0; i < message.fonts.length; ++i) {\n        let error = $root.FontResource.verify(message.fonts[i])\n        if (error) return 'fonts.' + error\n      }\n    }\n    if (message.size != null && message.hasOwnProperty('size'))\n      if (!$util.isInteger(message.size)) return 'size: integer expected'\n    if (message.lineHeight != null && message.hasOwnProperty('lineHeight'))\n      if (!$util.isInteger(message.lineHeight))\n        return 'lineHeight: integer expected'\n    return null\n  }\n\n  /**\n   * Creates a Font message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Font\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Font} Font\n   */\n  Font.fromObject = function fromObject(object) {\n    if (object instanceof $root.Font) return object\n    let message = new $root.Font()\n    if (object.fonts) {\n      if (!Array.isArray(object.fonts))\n        throw TypeError('.Font.fonts: array expected')\n      message.fonts = []\n      for (let i = 0; i < object.fonts.length; ++i) {\n        if (typeof object.fonts[i] !== 'object')\n          throw TypeError('.Font.fonts: object expected')\n        message.fonts[i] = $root.FontResource.fromObject(object.fonts[i])\n      }\n    }\n    if (object.size != null) message.size = object.size | 0\n    if (object.lineHeight != null) message.lineHeight = object.lineHeight | 0\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Font message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Font\n   * @static\n   * @param {Font} message Font\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Font.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.arrays || options.defaults) object.fonts = []\n    if (options.defaults) {\n      object.size = 0\n      object.lineHeight = 0\n    }\n    if (message.fonts && message.fonts.length) {\n      object.fonts = []\n      for (let j = 0; j < message.fonts.length; ++j)\n        object.fonts[j] = $root.FontResource.toObject(message.fonts[j], options)\n    }\n    if (message.size != null && message.hasOwnProperty('size'))\n      object.size = message.size\n    if (message.lineHeight != null && message.hasOwnProperty('lineHeight'))\n      object.lineHeight = message.lineHeight\n    return object\n  }\n\n  /**\n   * Converts this Font to JSON.\n   * @function toJSON\n   * @memberof Font\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Font.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Font\n})())\n\nexport const GlyphFont = ($root.GlyphFont = (() => {\n  /**\n   * Properties of a GlyphFont.\n   * @exports IGlyphFont\n   * @interface IGlyphFont\n   * @property {string|null} [letter] GlyphFont letter\n   * @property {IMetric|null} [adjustMetric] GlyphFont adjustMetric\n   * @property {Object.<string,number>|null} [kerning] GlyphFont kerning\n   */\n\n  /**\n   * Constructs a new GlyphFont.\n   * @exports GlyphFont\n   * @classdesc Represents a GlyphFont.\n   * @implements IGlyphFont\n   * @constructor\n   * @param {IGlyphFont=} [properties] Properties to set\n   */\n  function GlyphFont(properties) {\n    this.kerning = {}\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * GlyphFont letter.\n   * @member {string} letter\n   * @memberof GlyphFont\n   * @instance\n   */\n  GlyphFont.prototype.letter = ''\n\n  /**\n   * GlyphFont adjustMetric.\n   * @member {IMetric|null|undefined} adjustMetric\n   * @memberof GlyphFont\n   * @instance\n   */\n  GlyphFont.prototype.adjustMetric = null\n\n  /**\n   * GlyphFont kerning.\n   * @member {Object.<string,number>} kerning\n   * @memberof GlyphFont\n   * @instance\n   */\n  GlyphFont.prototype.kerning = $util.emptyObject\n\n  /**\n   * Creates a new GlyphFont instance using the specified properties.\n   * @function create\n   * @memberof GlyphFont\n   * @static\n   * @param {IGlyphFont=} [properties] Properties to set\n   * @returns {GlyphFont} GlyphFont instance\n   */\n  GlyphFont.create = function create(properties) {\n    return new GlyphFont(properties)\n  }\n\n  /**\n   * Encodes the specified GlyphFont message. Does not implicitly {@link GlyphFont.verify|verify} messages.\n   * @function encode\n   * @memberof GlyphFont\n   * @static\n   * @param {IGlyphFont} message GlyphFont message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GlyphFont.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.letter != null && Object.hasOwnProperty.call(message, 'letter'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.letter)\n    if (\n      message.adjustMetric != null &&\n      Object.hasOwnProperty.call(message, 'adjustMetric')\n    )\n      $root.Metric.encode(\n        message.adjustMetric,\n        writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n      ).ldelim()\n    if (\n      message.kerning != null &&\n      Object.hasOwnProperty.call(message, 'kerning')\n    )\n      for (let keys = Object.keys(message.kerning), i = 0; i < keys.length; ++i)\n        writer\n          .uint32(/* id 3, wireType 2 =*/ 26)\n          .fork()\n          .uint32(/* id 1, wireType 2 =*/ 10)\n          .string(keys[i])\n          .uint32(/* id 2, wireType 0 =*/ 16)\n          .int32(message.kerning[keys[i]])\n          .ldelim()\n    return writer\n  }\n\n  /**\n   * Encodes the specified GlyphFont message, length delimited. Does not implicitly {@link GlyphFont.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof GlyphFont\n   * @static\n   * @param {IGlyphFont} message GlyphFont message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GlyphFont.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a GlyphFont message from the specified reader or buffer.\n   * @function decode\n   * @memberof GlyphFont\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {GlyphFont} GlyphFont\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GlyphFont.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.GlyphFont(),\n      key,\n      value\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.letter = reader.string()\n          break\n        case 2:\n          message.adjustMetric = $root.Metric.decode(reader, reader.uint32())\n          break\n        case 3:\n          if (message.kerning === $util.emptyObject) message.kerning = {}\n          let end2 = reader.uint32() + reader.pos\n          key = ''\n          value = 0\n          while (reader.pos < end2) {\n            let tag2 = reader.uint32()\n            switch (tag2 >>> 3) {\n              case 1:\n                key = reader.string()\n                break\n              case 2:\n                value = reader.int32()\n                break\n              default:\n                reader.skipType(tag2 & 7)\n                break\n            }\n          }\n          message.kerning[key] = value\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a GlyphFont message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof GlyphFont\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {GlyphFont} GlyphFont\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GlyphFont.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a GlyphFont message.\n   * @function verify\n   * @memberof GlyphFont\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  GlyphFont.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.letter != null && message.hasOwnProperty('letter'))\n      if (!$util.isString(message.letter)) return 'letter: string expected'\n    if (\n      message.adjustMetric != null &&\n      message.hasOwnProperty('adjustMetric')\n    ) {\n      let error = $root.Metric.verify(message.adjustMetric)\n      if (error) return 'adjustMetric.' + error\n    }\n    if (message.kerning != null && message.hasOwnProperty('kerning')) {\n      if (!$util.isObject(message.kerning)) return 'kerning: object expected'\n      let key = Object.keys(message.kerning)\n      for (let i = 0; i < key.length; ++i)\n        if (!$util.isInteger(message.kerning[key[i]]))\n          return 'kerning: integer{k:string} expected'\n    }\n    return null\n  }\n\n  /**\n   * Creates a GlyphFont message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof GlyphFont\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {GlyphFont} GlyphFont\n   */\n  GlyphFont.fromObject = function fromObject(object) {\n    if (object instanceof $root.GlyphFont) return object\n    let message = new $root.GlyphFont()\n    if (object.letter != null) message.letter = String(object.letter)\n    if (object.adjustMetric != null) {\n      if (typeof object.adjustMetric !== 'object')\n        throw TypeError('.GlyphFont.adjustMetric: object expected')\n      message.adjustMetric = $root.Metric.fromObject(object.adjustMetric)\n    }\n    if (object.kerning) {\n      if (typeof object.kerning !== 'object')\n        throw TypeError('.GlyphFont.kerning: object expected')\n      message.kerning = {}\n      for (let keys = Object.keys(object.kerning), i = 0; i < keys.length; ++i)\n        message.kerning[keys[i]] = object.kerning[keys[i]] | 0\n    }\n    return message\n  }\n\n  /**\n   * Creates a plain object from a GlyphFont message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof GlyphFont\n   * @static\n   * @param {GlyphFont} message GlyphFont\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  GlyphFont.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.objects || options.defaults) object.kerning = {}\n    if (options.defaults) {\n      object.letter = ''\n      object.adjustMetric = null\n    }\n    if (message.letter != null && message.hasOwnProperty('letter'))\n      object.letter = message.letter\n    if (message.adjustMetric != null && message.hasOwnProperty('adjustMetric'))\n      object.adjustMetric = $root.Metric.toObject(message.adjustMetric, options)\n    let keys2\n    if (message.kerning && (keys2 = Object.keys(message.kerning)).length) {\n      object.kerning = {}\n      for (let j = 0; j < keys2.length; ++j)\n        object.kerning[keys2[j]] = message.kerning[keys2[j]]\n    }\n    return object\n  }\n\n  /**\n   * Converts this GlyphFont to JSON.\n   * @function toJSON\n   * @memberof GlyphFont\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  GlyphFont.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return GlyphFont\n})())\n\nexport const GlyphImage = ($root.GlyphImage = (() => {\n  /**\n   * Properties of a GlyphImage.\n   * @exports IGlyphImage\n   * @interface IGlyphImage\n   * @property {string|null} [letter] GlyphImage letter\n   * @property {IMetric|null} [adjustMetric] GlyphImage adjustMetric\n   * @property {Uint8Array|null} [buffer] GlyphImage buffer\n   * @property {string|null} [fileName] GlyphImage fileName\n   * @property {string|null} [fileType] GlyphImage fileType\n   * @property {boolean|null} [selected] GlyphImage selected\n   * @property {Object.<string,number>|null} [kerning] GlyphImage kerning\n   */\n\n  /**\n   * Constructs a new GlyphImage.\n   * @exports GlyphImage\n   * @classdesc Represents a GlyphImage.\n   * @implements IGlyphImage\n   * @constructor\n   * @param {IGlyphImage=} [properties] Properties to set\n   */\n  function GlyphImage(properties) {\n    this.kerning = {}\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * GlyphImage letter.\n   * @member {string} letter\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.letter = ''\n\n  /**\n   * GlyphImage adjustMetric.\n   * @member {IMetric|null|undefined} adjustMetric\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.adjustMetric = null\n\n  /**\n   * GlyphImage buffer.\n   * @member {Uint8Array} buffer\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.buffer = $util.newBuffer([])\n\n  /**\n   * GlyphImage fileName.\n   * @member {string} fileName\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.fileName = ''\n\n  /**\n   * GlyphImage fileType.\n   * @member {string} fileType\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.fileType = ''\n\n  /**\n   * GlyphImage selected.\n   * @member {boolean} selected\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.selected = false\n\n  /**\n   * GlyphImage kerning.\n   * @member {Object.<string,number>} kerning\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.kerning = $util.emptyObject\n\n  /**\n   * Creates a new GlyphImage instance using the specified properties.\n   * @function create\n   * @memberof GlyphImage\n   * @static\n   * @param {IGlyphImage=} [properties] Properties to set\n   * @returns {GlyphImage} GlyphImage instance\n   */\n  GlyphImage.create = function create(properties) {\n    return new GlyphImage(properties)\n  }\n\n  /**\n   * Encodes the specified GlyphImage message. Does not implicitly {@link GlyphImage.verify|verify} messages.\n   * @function encode\n   * @memberof GlyphImage\n   * @static\n   * @param {IGlyphImage} message GlyphImage message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GlyphImage.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.letter != null && Object.hasOwnProperty.call(message, 'letter'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.letter)\n    if (\n      message.adjustMetric != null &&\n      Object.hasOwnProperty.call(message, 'adjustMetric')\n    )\n      $root.Metric.encode(\n        message.adjustMetric,\n        writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n      ).ldelim()\n    if (message.buffer != null && Object.hasOwnProperty.call(message, 'buffer'))\n      writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.buffer)\n    if (\n      message.fileName != null &&\n      Object.hasOwnProperty.call(message, 'fileName')\n    )\n      writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.fileName)\n    if (\n      message.fileType != null &&\n      Object.hasOwnProperty.call(message, 'fileType')\n    )\n      writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.fileType)\n    if (\n      message.selected != null &&\n      Object.hasOwnProperty.call(message, 'selected')\n    )\n      writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.selected)\n    if (\n      message.kerning != null &&\n      Object.hasOwnProperty.call(message, 'kerning')\n    )\n      for (let keys = Object.keys(message.kerning), i = 0; i < keys.length; ++i)\n        writer\n          .uint32(/* id 7, wireType 2 =*/ 58)\n          .fork()\n          .uint32(/* id 1, wireType 2 =*/ 10)\n          .string(keys[i])\n          .uint32(/* id 2, wireType 0 =*/ 16)\n          .int32(message.kerning[keys[i]])\n          .ldelim()\n    return writer\n  }\n\n  /**\n   * Encodes the specified GlyphImage message, length delimited. Does not implicitly {@link GlyphImage.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof GlyphImage\n   * @static\n   * @param {IGlyphImage} message GlyphImage message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GlyphImage.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a GlyphImage message from the specified reader or buffer.\n   * @function decode\n   * @memberof GlyphImage\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {GlyphImage} GlyphImage\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GlyphImage.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.GlyphImage(),\n      key,\n      value\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.letter = reader.string()\n          break\n        case 2:\n          message.adjustMetric = $root.Metric.decode(reader, reader.uint32())\n          break\n        case 3:\n          message.buffer = reader.bytes()\n          break\n        case 4:\n          message.fileName = reader.string()\n          break\n        case 5:\n          message.fileType = reader.string()\n          break\n        case 6:\n          message.selected = reader.bool()\n          break\n        case 7:\n          if (message.kerning === $util.emptyObject) message.kerning = {}\n          let end2 = reader.uint32() + reader.pos\n          key = ''\n          value = 0\n          while (reader.pos < end2) {\n            let tag2 = reader.uint32()\n            switch (tag2 >>> 3) {\n              case 1:\n                key = reader.string()\n                break\n              case 2:\n                value = reader.int32()\n                break\n              default:\n                reader.skipType(tag2 & 7)\n                break\n            }\n          }\n          message.kerning[key] = value\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a GlyphImage message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof GlyphImage\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {GlyphImage} GlyphImage\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GlyphImage.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a GlyphImage message.\n   * @function verify\n   * @memberof GlyphImage\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  GlyphImage.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.letter != null && message.hasOwnProperty('letter'))\n      if (!$util.isString(message.letter)) return 'letter: string expected'\n    if (\n      message.adjustMetric != null &&\n      message.hasOwnProperty('adjustMetric')\n    ) {\n      let error = $root.Metric.verify(message.adjustMetric)\n      if (error) return 'adjustMetric.' + error\n    }\n    if (message.buffer != null && message.hasOwnProperty('buffer'))\n      if (\n        !(\n          (message.buffer && typeof message.buffer.length === 'number') ||\n          $util.isString(message.buffer)\n        )\n      )\n        return 'buffer: buffer expected'\n    if (message.fileName != null && message.hasOwnProperty('fileName'))\n      if (!$util.isString(message.fileName)) return 'fileName: string expected'\n    if (message.fileType != null && message.hasOwnProperty('fileType'))\n      if (!$util.isString(message.fileType)) return 'fileType: string expected'\n    if (message.selected != null && message.hasOwnProperty('selected'))\n      if (typeof message.selected !== 'boolean')\n        return 'selected: boolean expected'\n    if (message.kerning != null && message.hasOwnProperty('kerning')) {\n      if (!$util.isObject(message.kerning)) return 'kerning: object expected'\n      let key = Object.keys(message.kerning)\n      for (let i = 0; i < key.length; ++i)\n        if (!$util.isInteger(message.kerning[key[i]]))\n          return 'kerning: integer{k:string} expected'\n    }\n    return null\n  }\n\n  /**\n   * Creates a GlyphImage message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof GlyphImage\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {GlyphImage} GlyphImage\n   */\n  GlyphImage.fromObject = function fromObject(object) {\n    if (object instanceof $root.GlyphImage) return object\n    let message = new $root.GlyphImage()\n    if (object.letter != null) message.letter = String(object.letter)\n    if (object.adjustMetric != null) {\n      if (typeof object.adjustMetric !== 'object')\n        throw TypeError('.GlyphImage.adjustMetric: object expected')\n      message.adjustMetric = $root.Metric.fromObject(object.adjustMetric)\n    }\n    if (object.buffer != null)\n      if (typeof object.buffer === 'string')\n        $util.base64.decode(\n          object.buffer,\n          (message.buffer = $util.newBuffer(\n            $util.base64.length(object.buffer),\n          )),\n          0,\n        )\n      else if (object.buffer.length) message.buffer = object.buffer\n    if (object.fileName != null) message.fileName = String(object.fileName)\n    if (object.fileType != null) message.fileType = String(object.fileType)\n    if (object.selected != null) message.selected = Boolean(object.selected)\n    if (object.kerning) {\n      if (typeof object.kerning !== 'object')\n        throw TypeError('.GlyphImage.kerning: object expected')\n      message.kerning = {}\n      for (let keys = Object.keys(object.kerning), i = 0; i < keys.length; ++i)\n        message.kerning[keys[i]] = object.kerning[keys[i]] | 0\n    }\n    return message\n  }\n\n  /**\n   * Creates a plain object from a GlyphImage message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof GlyphImage\n   * @static\n   * @param {GlyphImage} message GlyphImage\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  GlyphImage.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.objects || options.defaults) object.kerning = {}\n    if (options.defaults) {\n      object.letter = ''\n      object.adjustMetric = null\n      if (options.bytes === String) object.buffer = ''\n      else {\n        object.buffer = []\n        if (options.bytes !== Array)\n          object.buffer = $util.newBuffer(object.buffer)\n      }\n      object.fileName = ''\n      object.fileType = ''\n      object.selected = false\n    }\n    if (message.letter != null && message.hasOwnProperty('letter'))\n      object.letter = message.letter\n    if (message.adjustMetric != null && message.hasOwnProperty('adjustMetric'))\n      object.adjustMetric = $root.Metric.toObject(message.adjustMetric, options)\n    if (message.buffer != null && message.hasOwnProperty('buffer'))\n      object.buffer =\n        options.bytes === String\n          ? $util.base64.encode(message.buffer, 0, message.buffer.length)\n          : options.bytes === Array\n          ? Array.prototype.slice.call(message.buffer)\n          : message.buffer\n    if (message.fileName != null && message.hasOwnProperty('fileName'))\n      object.fileName = message.fileName\n    if (message.fileType != null && message.hasOwnProperty('fileType'))\n      object.fileType = message.fileType\n    if (message.selected != null && message.hasOwnProperty('selected'))\n      object.selected = message.selected\n    let keys2\n    if (message.kerning && (keys2 = Object.keys(message.kerning)).length) {\n      object.kerning = {}\n      for (let j = 0; j < keys2.length; ++j)\n        object.kerning[keys2[j]] = message.kerning[keys2[j]]\n    }\n    return object\n  }\n\n  /**\n   * Converts this GlyphImage to JSON.\n   * @function toJSON\n   * @memberof GlyphImage\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  GlyphImage.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return GlyphImage\n})())\n\nexport const Layout = ($root.Layout = (() => {\n  /**\n   * Properties of a Layout.\n   * @exports ILayout\n   * @interface ILayout\n   * @property {number|null} [padding] Layout padding\n   * @property {number|null} [spacing] Layout spacing\n   * @property {number|null} [width] Layout width\n   * @property {number|null} [height] Layout height\n   * @property {boolean|null} [auto] Layout auto\n   * @property {boolean|null} [fixedSize] Layout fixedSize\n   */\n\n  /**\n   * Constructs a new Layout.\n   * @exports Layout\n   * @classdesc Represents a Layout.\n   * @implements ILayout\n   * @constructor\n   * @param {ILayout=} [properties] Properties to set\n   */\n  function Layout(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Layout padding.\n   * @member {number} padding\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.padding = 0\n\n  /**\n   * Layout spacing.\n   * @member {number} spacing\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.spacing = 0\n\n  /**\n   * Layout width.\n   * @member {number} width\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.width = 0\n\n  /**\n   * Layout height.\n   * @member {number} height\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.height = 0\n\n  /**\n   * Layout auto.\n   * @member {boolean} auto\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.auto = false\n\n  /**\n   * Layout fixedSize.\n   * @member {boolean} fixedSize\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.fixedSize = false\n\n  /**\n   * Creates a new Layout instance using the specified properties.\n   * @function create\n   * @memberof Layout\n   * @static\n   * @param {ILayout=} [properties] Properties to set\n   * @returns {Layout} Layout instance\n   */\n  Layout.create = function create(properties) {\n    return new Layout(properties)\n  }\n\n  /**\n   * Encodes the specified Layout message. Does not implicitly {@link Layout.verify|verify} messages.\n   * @function encode\n   * @memberof Layout\n   * @static\n   * @param {ILayout} message Layout message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Layout.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (\n      message.padding != null &&\n      Object.hasOwnProperty.call(message, 'padding')\n    )\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.padding)\n    if (\n      message.spacing != null &&\n      Object.hasOwnProperty.call(message, 'spacing')\n    )\n      writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.spacing)\n    if (message.width != null && Object.hasOwnProperty.call(message, 'width'))\n      writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.width)\n    if (message.height != null && Object.hasOwnProperty.call(message, 'height'))\n      writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.height)\n    if (message.auto != null && Object.hasOwnProperty.call(message, 'auto'))\n      writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.auto)\n    if (\n      message.fixedSize != null &&\n      Object.hasOwnProperty.call(message, 'fixedSize')\n    )\n      writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.fixedSize)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Layout message, length delimited. Does not implicitly {@link Layout.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Layout\n   * @static\n   * @param {ILayout} message Layout message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Layout.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Layout message from the specified reader or buffer.\n   * @function decode\n   * @memberof Layout\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Layout} Layout\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Layout.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Layout()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.padding = reader.int32()\n          break\n        case 2:\n          message.spacing = reader.int32()\n          break\n        case 3:\n          message.width = reader.int32()\n          break\n        case 4:\n          message.height = reader.int32()\n          break\n        case 5:\n          message.auto = reader.bool()\n          break\n        case 6:\n          message.fixedSize = reader.bool()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Layout message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Layout\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Layout} Layout\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Layout.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Layout message.\n   * @function verify\n   * @memberof Layout\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Layout.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.padding != null && message.hasOwnProperty('padding'))\n      if (!$util.isInteger(message.padding)) return 'padding: integer expected'\n    if (message.spacing != null && message.hasOwnProperty('spacing'))\n      if (!$util.isInteger(message.spacing)) return 'spacing: integer expected'\n    if (message.width != null && message.hasOwnProperty('width'))\n      if (!$util.isInteger(message.width)) return 'width: integer expected'\n    if (message.height != null && message.hasOwnProperty('height'))\n      if (!$util.isInteger(message.height)) return 'height: integer expected'\n    if (message.auto != null && message.hasOwnProperty('auto'))\n      if (typeof message.auto !== 'boolean') return 'auto: boolean expected'\n    if (message.fixedSize != null && message.hasOwnProperty('fixedSize'))\n      if (typeof message.fixedSize !== 'boolean')\n        return 'fixedSize: boolean expected'\n    return null\n  }\n\n  /**\n   * Creates a Layout message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Layout\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Layout} Layout\n   */\n  Layout.fromObject = function fromObject(object) {\n    if (object instanceof $root.Layout) return object\n    let message = new $root.Layout()\n    if (object.padding != null) message.padding = object.padding | 0\n    if (object.spacing != null) message.spacing = object.spacing | 0\n    if (object.width != null) message.width = object.width | 0\n    if (object.height != null) message.height = object.height | 0\n    if (object.auto != null) message.auto = Boolean(object.auto)\n    if (object.fixedSize != null) message.fixedSize = Boolean(object.fixedSize)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Layout message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Layout\n   * @static\n   * @param {Layout} message Layout\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Layout.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.padding = 0\n      object.spacing = 0\n      object.width = 0\n      object.height = 0\n      object.auto = false\n      object.fixedSize = false\n    }\n    if (message.padding != null && message.hasOwnProperty('padding'))\n      object.padding = message.padding\n    if (message.spacing != null && message.hasOwnProperty('spacing'))\n      object.spacing = message.spacing\n    if (message.width != null && message.hasOwnProperty('width'))\n      object.width = message.width\n    if (message.height != null && message.hasOwnProperty('height'))\n      object.height = message.height\n    if (message.auto != null && message.hasOwnProperty('auto'))\n      object.auto = message.auto\n    if (message.fixedSize != null && message.hasOwnProperty('fixedSize'))\n      object.fixedSize = message.fixedSize\n    return object\n  }\n\n  /**\n   * Converts this Layout to JSON.\n   * @function toJSON\n   * @memberof Layout\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Layout.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Layout\n})())\n\nexport const Shadow = ($root.Shadow = (() => {\n  /**\n   * Properties of a Shadow.\n   * @exports IShadow\n   * @interface IShadow\n   * @property {string|null} [color] Shadow color\n   * @property {number|null} [blur] Shadow blur\n   * @property {number|null} [offsetX] Shadow offsetX\n   * @property {number|null} [offsetY] Shadow offsetY\n   */\n\n  /**\n   * Constructs a new Shadow.\n   * @exports Shadow\n   * @classdesc Represents a Shadow.\n   * @implements IShadow\n   * @constructor\n   * @param {IShadow=} [properties] Properties to set\n   */\n  function Shadow(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Shadow color.\n   * @member {string} color\n   * @memberof Shadow\n   * @instance\n   */\n  Shadow.prototype.color = ''\n\n  /**\n   * Shadow blur.\n   * @member {number} blur\n   * @memberof Shadow\n   * @instance\n   */\n  Shadow.prototype.blur = 0\n\n  /**\n   * Shadow offsetX.\n   * @member {number} offsetX\n   * @memberof Shadow\n   * @instance\n   */\n  Shadow.prototype.offsetX = 0\n\n  /**\n   * Shadow offsetY.\n   * @member {number} offsetY\n   * @memberof Shadow\n   * @instance\n   */\n  Shadow.prototype.offsetY = 0\n\n  /**\n   * Creates a new Shadow instance using the specified properties.\n   * @function create\n   * @memberof Shadow\n   * @static\n   * @param {IShadow=} [properties] Properties to set\n   * @returns {Shadow} Shadow instance\n   */\n  Shadow.create = function create(properties) {\n    return new Shadow(properties)\n  }\n\n  /**\n   * Encodes the specified Shadow message. Does not implicitly {@link Shadow.verify|verify} messages.\n   * @function encode\n   * @memberof Shadow\n   * @static\n   * @param {IShadow} message Shadow message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Shadow.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.color != null && Object.hasOwnProperty.call(message, 'color'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.color)\n    if (message.blur != null && Object.hasOwnProperty.call(message, 'blur'))\n      writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.blur)\n    if (\n      message.offsetX != null &&\n      Object.hasOwnProperty.call(message, 'offsetX')\n    )\n      writer.uint32(/* id 3, wireType 0 =*/ 24).sint32(message.offsetX)\n    if (\n      message.offsetY != null &&\n      Object.hasOwnProperty.call(message, 'offsetY')\n    )\n      writer.uint32(/* id 4, wireType 0 =*/ 32).sint32(message.offsetY)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Shadow message, length delimited. Does not implicitly {@link Shadow.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Shadow\n   * @static\n   * @param {IShadow} message Shadow message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Shadow.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Shadow message from the specified reader or buffer.\n   * @function decode\n   * @memberof Shadow\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Shadow} Shadow\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Shadow.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Shadow()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.color = reader.string()\n          break\n        case 2:\n          message.blur = reader.int32()\n          break\n        case 3:\n          message.offsetX = reader.sint32()\n          break\n        case 4:\n          message.offsetY = reader.sint32()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Shadow message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Shadow\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Shadow} Shadow\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Shadow.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Shadow message.\n   * @function verify\n   * @memberof Shadow\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Shadow.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.color != null && message.hasOwnProperty('color'))\n      if (!$util.isString(message.color)) return 'color: string expected'\n    if (message.blur != null && message.hasOwnProperty('blur'))\n      if (!$util.isInteger(message.blur)) return 'blur: integer expected'\n    if (message.offsetX != null && message.hasOwnProperty('offsetX'))\n      if (!$util.isInteger(message.offsetX)) return 'offsetX: integer expected'\n    if (message.offsetY != null && message.hasOwnProperty('offsetY'))\n      if (!$util.isInteger(message.offsetY)) return 'offsetY: integer expected'\n    return null\n  }\n\n  /**\n   * Creates a Shadow message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Shadow\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Shadow} Shadow\n   */\n  Shadow.fromObject = function fromObject(object) {\n    if (object instanceof $root.Shadow) return object\n    let message = new $root.Shadow()\n    if (object.color != null) message.color = String(object.color)\n    if (object.blur != null) message.blur = object.blur | 0\n    if (object.offsetX != null) message.offsetX = object.offsetX | 0\n    if (object.offsetY != null) message.offsetY = object.offsetY | 0\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Shadow message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Shadow\n   * @static\n   * @param {Shadow} message Shadow\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Shadow.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.color = ''\n      object.blur = 0\n      object.offsetX = 0\n      object.offsetY = 0\n    }\n    if (message.color != null && message.hasOwnProperty('color'))\n      object.color = message.color\n    if (message.blur != null && message.hasOwnProperty('blur'))\n      object.blur = message.blur\n    if (message.offsetX != null && message.hasOwnProperty('offsetX'))\n      object.offsetX = message.offsetX\n    if (message.offsetY != null && message.hasOwnProperty('offsetY'))\n      object.offsetY = message.offsetY\n    return object\n  }\n\n  /**\n   * Converts this Shadow to JSON.\n   * @function toJSON\n   * @memberof Shadow\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Shadow.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Shadow\n})())\n\nexport const Style = ($root.Style = (() => {\n  /**\n   * Properties of a Style.\n   * @exports IStyle\n   * @interface IStyle\n   * @property {IFont|null} [font] Style font\n   * @property {IFill|null} [fill] Style fill\n   * @property {boolean|null} [useStroke] Style useStroke\n   * @property {IFill|null} [stroke] Style stroke\n   * @property {boolean|null} [useShadow] Style useShadow\n   * @property {IShadow|null} [shadow] Style shadow\n   * @property {string|null} [bgColor] Style bgColor\n   */\n\n  /**\n   * Constructs a new Style.\n   * @exports Style\n   * @classdesc Represents a Style.\n   * @implements IStyle\n   * @constructor\n   * @param {IStyle=} [properties] Properties to set\n   */\n  function Style(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Style font.\n   * @member {IFont|null|undefined} font\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.font = null\n\n  /**\n   * Style fill.\n   * @member {IFill|null|undefined} fill\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.fill = null\n\n  /**\n   * Style useStroke.\n   * @member {boolean} useStroke\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.useStroke = false\n\n  /**\n   * Style stroke.\n   * @member {IFill|null|undefined} stroke\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.stroke = null\n\n  /**\n   * Style useShadow.\n   * @member {boolean} useShadow\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.useShadow = false\n\n  /**\n   * Style shadow.\n   * @member {IShadow|null|undefined} shadow\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.shadow = null\n\n  /**\n   * Style bgColor.\n   * @member {string} bgColor\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.bgColor = ''\n\n  /**\n   * Creates a new Style instance using the specified properties.\n   * @function create\n   * @memberof Style\n   * @static\n   * @param {IStyle=} [properties] Properties to set\n   * @returns {Style} Style instance\n   */\n  Style.create = function create(properties) {\n    return new Style(properties)\n  }\n\n  /**\n   * Encodes the specified Style message. Does not implicitly {@link Style.verify|verify} messages.\n   * @function encode\n   * @memberof Style\n   * @static\n   * @param {IStyle} message Style message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Style.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.font != null && Object.hasOwnProperty.call(message, 'font'))\n      $root.Font.encode(\n        message.font,\n        writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),\n      ).ldelim()\n    if (message.fill != null && Object.hasOwnProperty.call(message, 'fill'))\n      $root.Fill.encode(\n        message.fill,\n        writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n      ).ldelim()\n    if (\n      message.useStroke != null &&\n      Object.hasOwnProperty.call(message, 'useStroke')\n    )\n      writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.useStroke)\n    if (message.stroke != null && Object.hasOwnProperty.call(message, 'stroke'))\n      $root.Fill.encode(\n        message.stroke,\n        writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),\n      ).ldelim()\n    if (\n      message.useShadow != null &&\n      Object.hasOwnProperty.call(message, 'useShadow')\n    )\n      writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.useShadow)\n    if (message.shadow != null && Object.hasOwnProperty.call(message, 'shadow'))\n      $root.Shadow.encode(\n        message.shadow,\n        writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),\n      ).ldelim()\n    if (\n      message.bgColor != null &&\n      Object.hasOwnProperty.call(message, 'bgColor')\n    )\n      writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.bgColor)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Style message, length delimited. Does not implicitly {@link Style.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Style\n   * @static\n   * @param {IStyle} message Style message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Style.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Style message from the specified reader or buffer.\n   * @function decode\n   * @memberof Style\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Style} Style\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Style.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Style()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.font = $root.Font.decode(reader, reader.uint32())\n          break\n        case 2:\n          message.fill = $root.Fill.decode(reader, reader.uint32())\n          break\n        case 3:\n          message.useStroke = reader.bool()\n          break\n        case 4:\n          message.stroke = $root.Fill.decode(reader, reader.uint32())\n          break\n        case 5:\n          message.useShadow = reader.bool()\n          break\n        case 6:\n          message.shadow = $root.Shadow.decode(reader, reader.uint32())\n          break\n        case 7:\n          message.bgColor = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Style message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Style\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Style} Style\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Style.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Style message.\n   * @function verify\n   * @memberof Style\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Style.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.font != null && message.hasOwnProperty('font')) {\n      let error = $root.Font.verify(message.font)\n      if (error) return 'font.' + error\n    }\n    if (message.fill != null && message.hasOwnProperty('fill')) {\n      let error = $root.Fill.verify(message.fill)\n      if (error) return 'fill.' + error\n    }\n    if (message.useStroke != null && message.hasOwnProperty('useStroke'))\n      if (typeof message.useStroke !== 'boolean')\n        return 'useStroke: boolean expected'\n    if (message.stroke != null && message.hasOwnProperty('stroke')) {\n      let error = $root.Fill.verify(message.stroke)\n      if (error) return 'stroke.' + error\n    }\n    if (message.useShadow != null && message.hasOwnProperty('useShadow'))\n      if (typeof message.useShadow !== 'boolean')\n        return 'useShadow: boolean expected'\n    if (message.shadow != null && message.hasOwnProperty('shadow')) {\n      let error = $root.Shadow.verify(message.shadow)\n      if (error) return 'shadow.' + error\n    }\n    if (message.bgColor != null && message.hasOwnProperty('bgColor'))\n      if (!$util.isString(message.bgColor)) return 'bgColor: string expected'\n    return null\n  }\n\n  /**\n   * Creates a Style message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Style\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Style} Style\n   */\n  Style.fromObject = function fromObject(object) {\n    if (object instanceof $root.Style) return object\n    let message = new $root.Style()\n    if (object.font != null) {\n      if (typeof object.font !== 'object')\n        throw TypeError('.Style.font: object expected')\n      message.font = $root.Font.fromObject(object.font)\n    }\n    if (object.fill != null) {\n      if (typeof object.fill !== 'object')\n        throw TypeError('.Style.fill: object expected')\n      message.fill = $root.Fill.fromObject(object.fill)\n    }\n    if (object.useStroke != null) message.useStroke = Boolean(object.useStroke)\n    if (object.stroke != null) {\n      if (typeof object.stroke !== 'object')\n        throw TypeError('.Style.stroke: object expected')\n      message.stroke = $root.Fill.fromObject(object.stroke)\n    }\n    if (object.useShadow != null) message.useShadow = Boolean(object.useShadow)\n    if (object.shadow != null) {\n      if (typeof object.shadow !== 'object')\n        throw TypeError('.Style.shadow: object expected')\n      message.shadow = $root.Shadow.fromObject(object.shadow)\n    }\n    if (object.bgColor != null) message.bgColor = String(object.bgColor)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Style message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Style\n   * @static\n   * @param {Style} message Style\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Style.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.font = null\n      object.fill = null\n      object.useStroke = false\n      object.stroke = null\n      object.useShadow = false\n      object.shadow = null\n      object.bgColor = ''\n    }\n    if (message.font != null && message.hasOwnProperty('font'))\n      object.font = $root.Font.toObject(message.font, options)\n    if (message.fill != null && message.hasOwnProperty('fill'))\n      object.fill = $root.Fill.toObject(message.fill, options)\n    if (message.useStroke != null && message.hasOwnProperty('useStroke'))\n      object.useStroke = message.useStroke\n    if (message.stroke != null && message.hasOwnProperty('stroke'))\n      object.stroke = $root.Fill.toObject(message.stroke, options)\n    if (message.useShadow != null && message.hasOwnProperty('useShadow'))\n      object.useShadow = message.useShadow\n    if (message.shadow != null && message.hasOwnProperty('shadow'))\n      object.shadow = $root.Shadow.toObject(message.shadow, options)\n    if (message.bgColor != null && message.hasOwnProperty('bgColor'))\n      object.bgColor = message.bgColor\n    return object\n  }\n\n  /**\n   * Converts this Style to JSON.\n   * @function toJSON\n   * @memberof Style\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Style.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Style\n})())\n\nexport const Ui = ($root.Ui = (() => {\n  /**\n   * Properties of an Ui.\n   * @exports IUi\n   * @interface IUi\n   * @property {string|null} [previewText] Ui previewText\n   */\n\n  /**\n   * Constructs a new Ui.\n   * @exports Ui\n   * @classdesc Represents an Ui.\n   * @implements IUi\n   * @constructor\n   * @param {IUi=} [properties] Properties to set\n   */\n  function Ui(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Ui previewText.\n   * @member {string} previewText\n   * @memberof Ui\n   * @instance\n   */\n  Ui.prototype.previewText = ''\n\n  /**\n   * Creates a new Ui instance using the specified properties.\n   * @function create\n   * @memberof Ui\n   * @static\n   * @param {IUi=} [properties] Properties to set\n   * @returns {Ui} Ui instance\n   */\n  Ui.create = function create(properties) {\n    return new Ui(properties)\n  }\n\n  /**\n   * Encodes the specified Ui message. Does not implicitly {@link Ui.verify|verify} messages.\n   * @function encode\n   * @memberof Ui\n   * @static\n   * @param {IUi} message Ui message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Ui.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (\n      message.previewText != null &&\n      Object.hasOwnProperty.call(message, 'previewText')\n    )\n      writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.previewText)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Ui message, length delimited. Does not implicitly {@link Ui.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Ui\n   * @static\n   * @param {IUi} message Ui message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Ui.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes an Ui message from the specified reader or buffer.\n   * @function decode\n   * @memberof Ui\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Ui} Ui\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Ui.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Ui()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.previewText = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes an Ui message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Ui\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Ui} Ui\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Ui.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies an Ui message.\n   * @function verify\n   * @memberof Ui\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Ui.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.previewText != null && message.hasOwnProperty('previewText'))\n      if (!$util.isString(message.previewText))\n        return 'previewText: string expected'\n    return null\n  }\n\n  /**\n   * Creates an Ui message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Ui\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Ui} Ui\n   */\n  Ui.fromObject = function fromObject(object) {\n    if (object instanceof $root.Ui) return object\n    let message = new $root.Ui()\n    if (object.previewText != null)\n      message.previewText = String(object.previewText)\n    return message\n  }\n\n  /**\n   * Creates a plain object from an Ui message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Ui\n   * @static\n   * @param {Ui} message Ui\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Ui.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) object.previewText = ''\n    if (message.previewText != null && message.hasOwnProperty('previewText'))\n      object.previewText = message.previewText\n    return object\n  }\n\n  /**\n   * Converts this Ui to JSON.\n   * @function toJSON\n   * @memberof Ui\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Ui.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Ui\n})())\n\nexport const Project = ($root.Project = (() => {\n  /**\n   * Properties of a Project.\n   * @exports IProject\n   * @interface IProject\n   * @property {number|Long|null} [id] Project id\n   * @property {string|null} [name] Project name\n   * @property {string|null} [text] Project text\n   * @property {Object.<string,IGlyphFont>|null} [glyphs] Project glyphs\n   * @property {Array.<IGlyphImage>|null} [glyphImages] Project glyphImages\n   * @property {IStyle|null} [style] Project style\n   * @property {ILayout|null} [layout] Project layout\n   * @property {IMetric|null} [globalAdjustMetric] Project globalAdjustMetric\n   * @property {IUi|null} [ui] Project ui\n   */\n\n  /**\n   * Constructs a new Project.\n   * @exports Project\n   * @classdesc Represents a Project.\n   * @implements IProject\n   * @constructor\n   * @param {IProject=} [properties] Properties to set\n   */\n  function Project(properties) {\n    this.glyphs = {}\n    this.glyphImages = []\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Project id.\n   * @member {number|Long} id\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, false) : 0\n\n  /**\n   * Project name.\n   * @member {string} name\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.name = ''\n\n  /**\n   * Project text.\n   * @member {string} text\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.text = ''\n\n  /**\n   * Project glyphs.\n   * @member {Object.<string,IGlyphFont>} glyphs\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.glyphs = $util.emptyObject\n\n  /**\n   * Project glyphImages.\n   * @member {Array.<IGlyphImage>} glyphImages\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.glyphImages = $util.emptyArray\n\n  /**\n   * Project style.\n   * @member {IStyle|null|undefined} style\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.style = null\n\n  /**\n   * Project layout.\n   * @member {ILayout|null|undefined} layout\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.layout = null\n\n  /**\n   * Project globalAdjustMetric.\n   * @member {IMetric|null|undefined} globalAdjustMetric\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.globalAdjustMetric = null\n\n  /**\n   * Project ui.\n   * @member {IUi|null|undefined} ui\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.ui = null\n\n  /**\n   * Creates a new Project instance using the specified properties.\n   * @function create\n   * @memberof Project\n   * @static\n   * @param {IProject=} [properties] Properties to set\n   * @returns {Project} Project instance\n   */\n  Project.create = function create(properties) {\n    return new Project(properties)\n  }\n\n  /**\n   * Encodes the specified Project message. Does not implicitly {@link Project.verify|verify} messages.\n   * @function encode\n   * @memberof Project\n   * @static\n   * @param {IProject} message Project message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Project.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.id != null && Object.hasOwnProperty.call(message, 'id'))\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.id)\n    if (message.name != null && Object.hasOwnProperty.call(message, 'name'))\n      writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name)\n    if (message.text != null && Object.hasOwnProperty.call(message, 'text'))\n      writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.text)\n    if (message.glyphs != null && Object.hasOwnProperty.call(message, 'glyphs'))\n      for (\n        let keys = Object.keys(message.glyphs), i = 0;\n        i < keys.length;\n        ++i\n      ) {\n        writer\n          .uint32(/* id 4, wireType 2 =*/ 34)\n          .fork()\n          .uint32(/* id 1, wireType 2 =*/ 10)\n          .string(keys[i])\n        $root.GlyphFont.encode(\n          message.glyphs[keys[i]],\n          writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n        )\n          .ldelim()\n          .ldelim()\n      }\n    if (message.glyphImages != null && message.glyphImages.length)\n      for (let i = 0; i < message.glyphImages.length; ++i)\n        $root.GlyphImage.encode(\n          message.glyphImages[i],\n          writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),\n        ).ldelim()\n    if (message.style != null && Object.hasOwnProperty.call(message, 'style'))\n      $root.Style.encode(\n        message.style,\n        writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),\n      ).ldelim()\n    if (message.layout != null && Object.hasOwnProperty.call(message, 'layout'))\n      $root.Layout.encode(\n        message.layout,\n        writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),\n      ).ldelim()\n    if (\n      message.globalAdjustMetric != null &&\n      Object.hasOwnProperty.call(message, 'globalAdjustMetric')\n    )\n      $root.Metric.encode(\n        message.globalAdjustMetric,\n        writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),\n      ).ldelim()\n    if (message.ui != null && Object.hasOwnProperty.call(message, 'ui'))\n      $root.Ui.encode(\n        message.ui,\n        writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),\n      ).ldelim()\n    return writer\n  }\n\n  /**\n   * Encodes the specified Project message, length delimited. Does not implicitly {@link Project.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Project\n   * @static\n   * @param {IProject} message Project message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Project.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Project message from the specified reader or buffer.\n   * @function decode\n   * @memberof Project\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Project} Project\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Project.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Project(),\n      key,\n      value\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.int64()\n          break\n        case 2:\n          message.name = reader.string()\n          break\n        case 3:\n          message.text = reader.string()\n          break\n        case 4:\n          if (message.glyphs === $util.emptyObject) message.glyphs = {}\n          let end2 = reader.uint32() + reader.pos\n          key = ''\n          value = null\n          while (reader.pos < end2) {\n            let tag2 = reader.uint32()\n            switch (tag2 >>> 3) {\n              case 1:\n                key = reader.string()\n                break\n              case 2:\n                value = $root.GlyphFont.decode(reader, reader.uint32())\n                break\n              default:\n                reader.skipType(tag2 & 7)\n                break\n            }\n          }\n          message.glyphs[key] = value\n          break\n        case 5:\n          if (!(message.glyphImages && message.glyphImages.length))\n            message.glyphImages = []\n          message.glyphImages.push(\n            $root.GlyphImage.decode(reader, reader.uint32()),\n          )\n          break\n        case 6:\n          message.style = $root.Style.decode(reader, reader.uint32())\n          break\n        case 7:\n          message.layout = $root.Layout.decode(reader, reader.uint32())\n          break\n        case 8:\n          message.globalAdjustMetric = $root.Metric.decode(\n            reader,\n            reader.uint32(),\n          )\n          break\n        case 9:\n          message.ui = $root.Ui.decode(reader, reader.uint32())\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Project message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Project\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Project} Project\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Project.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Project message.\n   * @function verify\n   * @memberof Project\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Project.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.id != null && message.hasOwnProperty('id'))\n      if (\n        !$util.isInteger(message.id) &&\n        !(\n          message.id &&\n          $util.isInteger(message.id.low) &&\n          $util.isInteger(message.id.high)\n        )\n      )\n        return 'id: integer|Long expected'\n    if (message.name != null && message.hasOwnProperty('name'))\n      if (!$util.isString(message.name)) return 'name: string expected'\n    if (message.text != null && message.hasOwnProperty('text'))\n      if (!$util.isString(message.text)) return 'text: string expected'\n    if (message.glyphs != null && message.hasOwnProperty('glyphs')) {\n      if (!$util.isObject(message.glyphs)) return 'glyphs: object expected'\n      let key = Object.keys(message.glyphs)\n      for (let i = 0; i < key.length; ++i) {\n        let error = $root.GlyphFont.verify(message.glyphs[key[i]])\n        if (error) return 'glyphs.' + error\n      }\n    }\n    if (message.glyphImages != null && message.hasOwnProperty('glyphImages')) {\n      if (!Array.isArray(message.glyphImages))\n        return 'glyphImages: array expected'\n      for (let i = 0; i < message.glyphImages.length; ++i) {\n        let error = $root.GlyphImage.verify(message.glyphImages[i])\n        if (error) return 'glyphImages.' + error\n      }\n    }\n    if (message.style != null && message.hasOwnProperty('style')) {\n      let error = $root.Style.verify(message.style)\n      if (error) return 'style.' + error\n    }\n    if (message.layout != null && message.hasOwnProperty('layout')) {\n      let error = $root.Layout.verify(message.layout)\n      if (error) return 'layout.' + error\n    }\n    if (\n      message.globalAdjustMetric != null &&\n      message.hasOwnProperty('globalAdjustMetric')\n    ) {\n      let error = $root.Metric.verify(message.globalAdjustMetric)\n      if (error) return 'globalAdjustMetric.' + error\n    }\n    if (message.ui != null && message.hasOwnProperty('ui')) {\n      let error = $root.Ui.verify(message.ui)\n      if (error) return 'ui.' + error\n    }\n    return null\n  }\n\n  /**\n   * Creates a Project message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Project\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Project} Project\n   */\n  Project.fromObject = function fromObject(object) {\n    if (object instanceof $root.Project) return object\n    let message = new $root.Project()\n    if (object.id != null)\n      if ($util.Long)\n        (message.id = $util.Long.fromValue(object.id)).unsigned = false\n      else if (typeof object.id === 'string')\n        message.id = parseInt(object.id, 10)\n      else if (typeof object.id === 'number') message.id = object.id\n      else if (typeof object.id === 'object')\n        message.id = new $util.LongBits(\n          object.id.low >>> 0,\n          object.id.high >>> 0,\n        ).toNumber()\n    if (object.name != null) message.name = String(object.name)\n    if (object.text != null) message.text = String(object.text)\n    if (object.glyphs) {\n      if (typeof object.glyphs !== 'object')\n        throw TypeError('.Project.glyphs: object expected')\n      message.glyphs = {}\n      for (let keys = Object.keys(object.glyphs), i = 0; i < keys.length; ++i) {\n        if (typeof object.glyphs[keys[i]] !== 'object')\n          throw TypeError('.Project.glyphs: object expected')\n        message.glyphs[keys[i]] = $root.GlyphFont.fromObject(\n          object.glyphs[keys[i]],\n        )\n      }\n    }\n    if (object.glyphImages) {\n      if (!Array.isArray(object.glyphImages))\n        throw TypeError('.Project.glyphImages: array expected')\n      message.glyphImages = []\n      for (let i = 0; i < object.glyphImages.length; ++i) {\n        if (typeof object.glyphImages[i] !== 'object')\n          throw TypeError('.Project.glyphImages: object expected')\n        message.glyphImages[i] = $root.GlyphImage.fromObject(\n          object.glyphImages[i],\n        )\n      }\n    }\n    if (object.style != null) {\n      if (typeof object.style !== 'object')\n        throw TypeError('.Project.style: object expected')\n      message.style = $root.Style.fromObject(object.style)\n    }\n    if (object.layout != null) {\n      if (typeof object.layout !== 'object')\n        throw TypeError('.Project.layout: object expected')\n      message.layout = $root.Layout.fromObject(object.layout)\n    }\n    if (object.globalAdjustMetric != null) {\n      if (typeof object.globalAdjustMetric !== 'object')\n        throw TypeError('.Project.globalAdjustMetric: object expected')\n      message.globalAdjustMetric = $root.Metric.fromObject(\n        object.globalAdjustMetric,\n      )\n    }\n    if (object.ui != null) {\n      if (typeof object.ui !== 'object')\n        throw TypeError('.Project.ui: object expected')\n      message.ui = $root.Ui.fromObject(object.ui)\n    }\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Project message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Project\n   * @static\n   * @param {Project} message Project\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Project.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.arrays || options.defaults) object.glyphImages = []\n    if (options.objects || options.defaults) object.glyphs = {}\n    if (options.defaults) {\n      if ($util.Long) {\n        let long = new $util.Long(0, 0, false)\n        object.id =\n          options.longs === String\n            ? long.toString()\n            : options.longs === Number\n            ? long.toNumber()\n            : long\n      } else object.id = options.longs === String ? '0' : 0\n      object.name = ''\n      object.text = ''\n      object.style = null\n      object.layout = null\n      object.globalAdjustMetric = null\n      object.ui = null\n    }\n    if (message.id != null && message.hasOwnProperty('id'))\n      if (typeof message.id === 'number')\n        object.id = options.longs === String ? String(message.id) : message.id\n      else\n        object.id =\n          options.longs === String\n            ? $util.Long.prototype.toString.call(message.id)\n            : options.longs === Number\n            ? new $util.LongBits(\n                message.id.low >>> 0,\n                message.id.high >>> 0,\n              ).toNumber()\n            : message.id\n    if (message.name != null && message.hasOwnProperty('name'))\n      object.name = message.name\n    if (message.text != null && message.hasOwnProperty('text'))\n      object.text = message.text\n    let keys2\n    if (message.glyphs && (keys2 = Object.keys(message.glyphs)).length) {\n      object.glyphs = {}\n      for (let j = 0; j < keys2.length; ++j)\n        object.glyphs[keys2[j]] = $root.GlyphFont.toObject(\n          message.glyphs[keys2[j]],\n          options,\n        )\n    }\n    if (message.glyphImages && message.glyphImages.length) {\n      object.glyphImages = []\n      for (let j = 0; j < message.glyphImages.length; ++j)\n        object.glyphImages[j] = $root.GlyphImage.toObject(\n          message.glyphImages[j],\n          options,\n        )\n    }\n    if (message.style != null && message.hasOwnProperty('style'))\n      object.style = $root.Style.toObject(message.style, options)\n    if (message.layout != null && message.hasOwnProperty('layout'))\n      object.layout = $root.Layout.toObject(message.layout, options)\n    if (\n      message.globalAdjustMetric != null &&\n      message.hasOwnProperty('globalAdjustMetric')\n    )\n      object.globalAdjustMetric = $root.Metric.toObject(\n        message.globalAdjustMetric,\n        options,\n      )\n    if (message.ui != null && message.hasOwnProperty('ui'))\n      object.ui = $root.Ui.toObject(message.ui, options)\n    return object\n  }\n\n  /**\n   * Converts this Project to JSON.\n   * @function toJSON\n   * @memberof Project\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Project.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Project\n})())\n\nexport { $root as default }\n","import { IProject } from './project'\nimport { IProject as IProjectNext, IFill } from '../project'\n\nexport default function updateToNext(project: IProject): IProjectNext {\n  if (project.style?.stroke) {\n    ;(project.style?.stroke as IFill).strokeType = 0\n  }\n  return project\n}\n","/* eslint-disable */\nimport * as $protobuf from 'protobufjs/minimal'\n\n// Common aliases\nconst $Reader = $protobuf.Reader,\n  $Writer = $protobuf.Writer,\n  $util = $protobuf.util\n\n// Exported root namespace\nconst $root = $protobuf.roots['default'] || ($protobuf.roots['default'] = {})\n\nexport const Metric = ($root.Metric = (() => {\n  /**\n   * Properties of a Metric.\n   * @exports IMetric\n   * @interface IMetric\n   * @property {number|null} [xAdvance] Metric xAdvance\n   * @property {number|null} [xOffset] Metric xOffset\n   * @property {number|null} [yOffset] Metric yOffset\n   */\n\n  /**\n   * Constructs a new Metric.\n   * @exports Metric\n   * @classdesc Represents a Metric.\n   * @implements IMetric\n   * @constructor\n   * @param {IMetric=} [properties] Properties to set\n   */\n  function Metric(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Metric xAdvance.\n   * @member {number} xAdvance\n   * @memberof Metric\n   * @instance\n   */\n  Metric.prototype.xAdvance = 0\n\n  /**\n   * Metric xOffset.\n   * @member {number} xOffset\n   * @memberof Metric\n   * @instance\n   */\n  Metric.prototype.xOffset = 0\n\n  /**\n   * Metric yOffset.\n   * @member {number} yOffset\n   * @memberof Metric\n   * @instance\n   */\n  Metric.prototype.yOffset = 0\n\n  /**\n   * Creates a new Metric instance using the specified properties.\n   * @function create\n   * @memberof Metric\n   * @static\n   * @param {IMetric=} [properties] Properties to set\n   * @returns {Metric} Metric instance\n   */\n  Metric.create = function create(properties) {\n    return new Metric(properties)\n  }\n\n  /**\n   * Encodes the specified Metric message. Does not implicitly {@link Metric.verify|verify} messages.\n   * @function encode\n   * @memberof Metric\n   * @static\n   * @param {IMetric} message Metric message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Metric.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (\n      message.xAdvance != null &&\n      Object.hasOwnProperty.call(message, 'xAdvance')\n    )\n      writer.uint32(/* id 1, wireType 0 =*/ 8).sint32(message.xAdvance)\n    if (\n      message.xOffset != null &&\n      Object.hasOwnProperty.call(message, 'xOffset')\n    )\n      writer.uint32(/* id 2, wireType 0 =*/ 16).sint32(message.xOffset)\n    if (\n      message.yOffset != null &&\n      Object.hasOwnProperty.call(message, 'yOffset')\n    )\n      writer.uint32(/* id 3, wireType 0 =*/ 24).sint32(message.yOffset)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Metric message, length delimited. Does not implicitly {@link Metric.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Metric\n   * @static\n   * @param {IMetric} message Metric message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Metric.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Metric message from the specified reader or buffer.\n   * @function decode\n   * @memberof Metric\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Metric} Metric\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Metric.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Metric()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.xAdvance = reader.sint32()\n          break\n        case 2:\n          message.xOffset = reader.sint32()\n          break\n        case 3:\n          message.yOffset = reader.sint32()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Metric message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Metric\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Metric} Metric\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Metric.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Metric message.\n   * @function verify\n   * @memberof Metric\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Metric.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.xAdvance != null && message.hasOwnProperty('xAdvance'))\n      if (!$util.isInteger(message.xAdvance))\n        return 'xAdvance: integer expected'\n    if (message.xOffset != null && message.hasOwnProperty('xOffset'))\n      if (!$util.isInteger(message.xOffset)) return 'xOffset: integer expected'\n    if (message.yOffset != null && message.hasOwnProperty('yOffset'))\n      if (!$util.isInteger(message.yOffset)) return 'yOffset: integer expected'\n    return null\n  }\n\n  /**\n   * Creates a Metric message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Metric\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Metric} Metric\n   */\n  Metric.fromObject = function fromObject(object) {\n    if (object instanceof $root.Metric) return object\n    let message = new $root.Metric()\n    if (object.xAdvance != null) message.xAdvance = object.xAdvance | 0\n    if (object.xOffset != null) message.xOffset = object.xOffset | 0\n    if (object.yOffset != null) message.yOffset = object.yOffset | 0\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Metric message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Metric\n   * @static\n   * @param {Metric} message Metric\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Metric.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.xAdvance = 0\n      object.xOffset = 0\n      object.yOffset = 0\n    }\n    if (message.xAdvance != null && message.hasOwnProperty('xAdvance'))\n      object.xAdvance = message.xAdvance\n    if (message.xOffset != null && message.hasOwnProperty('xOffset'))\n      object.xOffset = message.xOffset\n    if (message.yOffset != null && message.hasOwnProperty('yOffset'))\n      object.yOffset = message.yOffset\n    return object\n  }\n\n  /**\n   * Converts this Metric to JSON.\n   * @function toJSON\n   * @memberof Metric\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Metric.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Metric\n})())\n\nexport const GradientColor = ($root.GradientColor = (() => {\n  /**\n   * Properties of a GradientColor.\n   * @exports IGradientColor\n   * @interface IGradientColor\n   * @property {number|null} [id] GradientColor id\n   * @property {number|null} [offset] GradientColor offset\n   * @property {string|null} [color] GradientColor color\n   */\n\n  /**\n   * Constructs a new GradientColor.\n   * @exports GradientColor\n   * @classdesc Represents a GradientColor.\n   * @implements IGradientColor\n   * @constructor\n   * @param {IGradientColor=} [properties] Properties to set\n   */\n  function GradientColor(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * GradientColor id.\n   * @member {number} id\n   * @memberof GradientColor\n   * @instance\n   */\n  GradientColor.prototype.id = 0\n\n  /**\n   * GradientColor offset.\n   * @member {number} offset\n   * @memberof GradientColor\n   * @instance\n   */\n  GradientColor.prototype.offset = 0\n\n  /**\n   * GradientColor color.\n   * @member {string} color\n   * @memberof GradientColor\n   * @instance\n   */\n  GradientColor.prototype.color = ''\n\n  /**\n   * Creates a new GradientColor instance using the specified properties.\n   * @function create\n   * @memberof GradientColor\n   * @static\n   * @param {IGradientColor=} [properties] Properties to set\n   * @returns {GradientColor} GradientColor instance\n   */\n  GradientColor.create = function create(properties) {\n    return new GradientColor(properties)\n  }\n\n  /**\n   * Encodes the specified GradientColor message. Does not implicitly {@link GradientColor.verify|verify} messages.\n   * @function encode\n   * @memberof GradientColor\n   * @static\n   * @param {IGradientColor} message GradientColor message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GradientColor.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.id != null && Object.hasOwnProperty.call(message, 'id'))\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.id)\n    if (message.offset != null && Object.hasOwnProperty.call(message, 'offset'))\n      writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.offset)\n    if (message.color != null && Object.hasOwnProperty.call(message, 'color'))\n      writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.color)\n    return writer\n  }\n\n  /**\n   * Encodes the specified GradientColor message, length delimited. Does not implicitly {@link GradientColor.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof GradientColor\n   * @static\n   * @param {IGradientColor} message GradientColor message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GradientColor.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a GradientColor message from the specified reader or buffer.\n   * @function decode\n   * @memberof GradientColor\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {GradientColor} GradientColor\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GradientColor.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.GradientColor()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.int32()\n          break\n        case 2:\n          message.offset = reader.float()\n          break\n        case 3:\n          message.color = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a GradientColor message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof GradientColor\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {GradientColor} GradientColor\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GradientColor.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a GradientColor message.\n   * @function verify\n   * @memberof GradientColor\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  GradientColor.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.id != null && message.hasOwnProperty('id'))\n      if (!$util.isInteger(message.id)) return 'id: integer expected'\n    if (message.offset != null && message.hasOwnProperty('offset'))\n      if (typeof message.offset !== 'number') return 'offset: number expected'\n    if (message.color != null && message.hasOwnProperty('color'))\n      if (!$util.isString(message.color)) return 'color: string expected'\n    return null\n  }\n\n  /**\n   * Creates a GradientColor message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof GradientColor\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {GradientColor} GradientColor\n   */\n  GradientColor.fromObject = function fromObject(object) {\n    if (object instanceof $root.GradientColor) return object\n    let message = new $root.GradientColor()\n    if (object.id != null) message.id = object.id | 0\n    if (object.offset != null) message.offset = Number(object.offset)\n    if (object.color != null) message.color = String(object.color)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a GradientColor message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof GradientColor\n   * @static\n   * @param {GradientColor} message GradientColor\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  GradientColor.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.id = 0\n      object.offset = 0\n      object.color = ''\n    }\n    if (message.id != null && message.hasOwnProperty('id'))\n      object.id = message.id\n    if (message.offset != null && message.hasOwnProperty('offset'))\n      object.offset =\n        options.json && !isFinite(message.offset)\n          ? String(message.offset)\n          : message.offset\n    if (message.color != null && message.hasOwnProperty('color'))\n      object.color = message.color\n    return object\n  }\n\n  /**\n   * Converts this GradientColor to JSON.\n   * @function toJSON\n   * @memberof GradientColor\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  GradientColor.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return GradientColor\n})())\n\nexport const Gradient = ($root.Gradient = (() => {\n  /**\n   * Properties of a Gradient.\n   * @exports IGradient\n   * @interface IGradient\n   * @property {number|null} [type] Gradient type\n   * @property {number|null} [angle] Gradient angle\n   * @property {Array.<IGradientColor>|null} [palette] Gradient palette\n   */\n\n  /**\n   * Constructs a new Gradient.\n   * @exports Gradient\n   * @classdesc Represents a Gradient.\n   * @implements IGradient\n   * @constructor\n   * @param {IGradient=} [properties] Properties to set\n   */\n  function Gradient(properties) {\n    this.palette = []\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Gradient type.\n   * @member {number} type\n   * @memberof Gradient\n   * @instance\n   */\n  Gradient.prototype.type = 0\n\n  /**\n   * Gradient angle.\n   * @member {number} angle\n   * @memberof Gradient\n   * @instance\n   */\n  Gradient.prototype.angle = 0\n\n  /**\n   * Gradient palette.\n   * @member {Array.<IGradientColor>} palette\n   * @memberof Gradient\n   * @instance\n   */\n  Gradient.prototype.palette = $util.emptyArray\n\n  /**\n   * Creates a new Gradient instance using the specified properties.\n   * @function create\n   * @memberof Gradient\n   * @static\n   * @param {IGradient=} [properties] Properties to set\n   * @returns {Gradient} Gradient instance\n   */\n  Gradient.create = function create(properties) {\n    return new Gradient(properties)\n  }\n\n  /**\n   * Encodes the specified Gradient message. Does not implicitly {@link Gradient.verify|verify} messages.\n   * @function encode\n   * @memberof Gradient\n   * @static\n   * @param {IGradient} message Gradient message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Gradient.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.type != null && Object.hasOwnProperty.call(message, 'type'))\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.type)\n    if (message.angle != null && Object.hasOwnProperty.call(message, 'angle'))\n      writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.angle)\n    if (message.palette != null && message.palette.length)\n      for (let i = 0; i < message.palette.length; ++i)\n        $root.GradientColor.encode(\n          message.palette[i],\n          writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),\n        ).ldelim()\n    return writer\n  }\n\n  /**\n   * Encodes the specified Gradient message, length delimited. Does not implicitly {@link Gradient.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Gradient\n   * @static\n   * @param {IGradient} message Gradient message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Gradient.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Gradient message from the specified reader or buffer.\n   * @function decode\n   * @memberof Gradient\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Gradient} Gradient\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Gradient.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Gradient()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32()\n          break\n        case 2:\n          message.angle = reader.float()\n          break\n        case 3:\n          if (!(message.palette && message.palette.length)) message.palette = []\n          message.palette.push(\n            $root.GradientColor.decode(reader, reader.uint32()),\n          )\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Gradient message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Gradient\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Gradient} Gradient\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Gradient.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Gradient message.\n   * @function verify\n   * @memberof Gradient\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Gradient.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.type != null && message.hasOwnProperty('type'))\n      if (!$util.isInteger(message.type)) return 'type: integer expected'\n    if (message.angle != null && message.hasOwnProperty('angle'))\n      if (typeof message.angle !== 'number') return 'angle: number expected'\n    if (message.palette != null && message.hasOwnProperty('palette')) {\n      if (!Array.isArray(message.palette)) return 'palette: array expected'\n      for (let i = 0; i < message.palette.length; ++i) {\n        let error = $root.GradientColor.verify(message.palette[i])\n        if (error) return 'palette.' + error\n      }\n    }\n    return null\n  }\n\n  /**\n   * Creates a Gradient message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Gradient\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Gradient} Gradient\n   */\n  Gradient.fromObject = function fromObject(object) {\n    if (object instanceof $root.Gradient) return object\n    let message = new $root.Gradient()\n    if (object.type != null) message.type = object.type | 0\n    if (object.angle != null) message.angle = Number(object.angle)\n    if (object.palette) {\n      if (!Array.isArray(object.palette))\n        throw TypeError('.Gradient.palette: array expected')\n      message.palette = []\n      for (let i = 0; i < object.palette.length; ++i) {\n        if (typeof object.palette[i] !== 'object')\n          throw TypeError('.Gradient.palette: object expected')\n        message.palette[i] = $root.GradientColor.fromObject(object.palette[i])\n      }\n    }\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Gradient message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Gradient\n   * @static\n   * @param {Gradient} message Gradient\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Gradient.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.arrays || options.defaults) object.palette = []\n    if (options.defaults) {\n      object.type = 0\n      object.angle = 0\n    }\n    if (message.type != null && message.hasOwnProperty('type'))\n      object.type = message.type\n    if (message.angle != null && message.hasOwnProperty('angle'))\n      object.angle =\n        options.json && !isFinite(message.angle)\n          ? String(message.angle)\n          : message.angle\n    if (message.palette && message.palette.length) {\n      object.palette = []\n      for (let j = 0; j < message.palette.length; ++j)\n        object.palette[j] = $root.GradientColor.toObject(\n          message.palette[j],\n          options,\n        )\n    }\n    return object\n  }\n\n  /**\n   * Converts this Gradient to JSON.\n   * @function toJSON\n   * @memberof Gradient\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Gradient.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Gradient\n})())\n\nexport const PatternTexture = ($root.PatternTexture = (() => {\n  /**\n   * Properties of a PatternTexture.\n   * @exports IPatternTexture\n   * @interface IPatternTexture\n   * @property {Uint8Array|null} [buffer] PatternTexture buffer\n   * @property {number|null} [scale] PatternTexture scale\n   * @property {string|null} [repetition] PatternTexture repetition\n   */\n\n  /**\n   * Constructs a new PatternTexture.\n   * @exports PatternTexture\n   * @classdesc Represents a PatternTexture.\n   * @implements IPatternTexture\n   * @constructor\n   * @param {IPatternTexture=} [properties] Properties to set\n   */\n  function PatternTexture(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * PatternTexture buffer.\n   * @member {Uint8Array} buffer\n   * @memberof PatternTexture\n   * @instance\n   */\n  PatternTexture.prototype.buffer = $util.newBuffer([])\n\n  /**\n   * PatternTexture scale.\n   * @member {number} scale\n   * @memberof PatternTexture\n   * @instance\n   */\n  PatternTexture.prototype.scale = 0\n\n  /**\n   * PatternTexture repetition.\n   * @member {string} repetition\n   * @memberof PatternTexture\n   * @instance\n   */\n  PatternTexture.prototype.repetition = ''\n\n  /**\n   * Creates a new PatternTexture instance using the specified properties.\n   * @function create\n   * @memberof PatternTexture\n   * @static\n   * @param {IPatternTexture=} [properties] Properties to set\n   * @returns {PatternTexture} PatternTexture instance\n   */\n  PatternTexture.create = function create(properties) {\n    return new PatternTexture(properties)\n  }\n\n  /**\n   * Encodes the specified PatternTexture message. Does not implicitly {@link PatternTexture.verify|verify} messages.\n   * @function encode\n   * @memberof PatternTexture\n   * @static\n   * @param {IPatternTexture} message PatternTexture message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  PatternTexture.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.buffer != null && Object.hasOwnProperty.call(message, 'buffer'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.buffer)\n    if (message.scale != null && Object.hasOwnProperty.call(message, 'scale'))\n      writer.uint32(/* id 2, wireType 1 =*/ 17).double(message.scale)\n    if (\n      message.repetition != null &&\n      Object.hasOwnProperty.call(message, 'repetition')\n    )\n      writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.repetition)\n    return writer\n  }\n\n  /**\n   * Encodes the specified PatternTexture message, length delimited. Does not implicitly {@link PatternTexture.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof PatternTexture\n   * @static\n   * @param {IPatternTexture} message PatternTexture message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  PatternTexture.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a PatternTexture message from the specified reader or buffer.\n   * @function decode\n   * @memberof PatternTexture\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {PatternTexture} PatternTexture\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  PatternTexture.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.PatternTexture()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.buffer = reader.bytes()\n          break\n        case 2:\n          message.scale = reader.double()\n          break\n        case 3:\n          message.repetition = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a PatternTexture message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof PatternTexture\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {PatternTexture} PatternTexture\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  PatternTexture.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a PatternTexture message.\n   * @function verify\n   * @memberof PatternTexture\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  PatternTexture.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.buffer != null && message.hasOwnProperty('buffer'))\n      if (\n        !(\n          (message.buffer && typeof message.buffer.length === 'number') ||\n          $util.isString(message.buffer)\n        )\n      )\n        return 'buffer: buffer expected'\n    if (message.scale != null && message.hasOwnProperty('scale'))\n      if (typeof message.scale !== 'number') return 'scale: number expected'\n    if (message.repetition != null && message.hasOwnProperty('repetition'))\n      if (!$util.isString(message.repetition))\n        return 'repetition: string expected'\n    return null\n  }\n\n  /**\n   * Creates a PatternTexture message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof PatternTexture\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {PatternTexture} PatternTexture\n   */\n  PatternTexture.fromObject = function fromObject(object) {\n    if (object instanceof $root.PatternTexture) return object\n    let message = new $root.PatternTexture()\n    if (object.buffer != null)\n      if (typeof object.buffer === 'string')\n        $util.base64.decode(\n          object.buffer,\n          (message.buffer = $util.newBuffer(\n            $util.base64.length(object.buffer),\n          )),\n          0,\n        )\n      else if (object.buffer.length) message.buffer = object.buffer\n    if (object.scale != null) message.scale = Number(object.scale)\n    if (object.repetition != null)\n      message.repetition = String(object.repetition)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a PatternTexture message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof PatternTexture\n   * @static\n   * @param {PatternTexture} message PatternTexture\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  PatternTexture.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      if (options.bytes === String) object.buffer = ''\n      else {\n        object.buffer = []\n        if (options.bytes !== Array)\n          object.buffer = $util.newBuffer(object.buffer)\n      }\n      object.scale = 0\n      object.repetition = ''\n    }\n    if (message.buffer != null && message.hasOwnProperty('buffer'))\n      object.buffer =\n        options.bytes === String\n          ? $util.base64.encode(message.buffer, 0, message.buffer.length)\n          : options.bytes === Array\n          ? Array.prototype.slice.call(message.buffer)\n          : message.buffer\n    if (message.scale != null && message.hasOwnProperty('scale'))\n      object.scale =\n        options.json && !isFinite(message.scale)\n          ? String(message.scale)\n          : message.scale\n    if (message.repetition != null && message.hasOwnProperty('repetition'))\n      object.repetition = message.repetition\n    return object\n  }\n\n  /**\n   * Converts this PatternTexture to JSON.\n   * @function toJSON\n   * @memberof PatternTexture\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  PatternTexture.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return PatternTexture\n})())\n\nexport const Fill = ($root.Fill = (() => {\n  /**\n   * Properties of a Fill.\n   * @exports IFill\n   * @interface IFill\n   * @property {number|null} [type] Fill type\n   * @property {string|null} [color] Fill color\n   * @property {IGradient|null} [gradient] Fill gradient\n   * @property {IPatternTexture|null} [patternTexture] Fill patternTexture\n   * @property {number|null} [width] Fill width\n   * @property {string|null} [lineCap] Fill lineCap\n   * @property {string|null} [lineJoin] Fill lineJoin\n   * @property {number|null} [strokeType] Fill strokeType\n   */\n\n  /**\n   * Constructs a new Fill.\n   * @exports Fill\n   * @classdesc Represents a Fill.\n   * @implements IFill\n   * @constructor\n   * @param {IFill=} [properties] Properties to set\n   */\n  function Fill(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Fill type.\n   * @member {number} type\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.type = 0\n\n  /**\n   * Fill color.\n   * @member {string} color\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.color = ''\n\n  /**\n   * Fill gradient.\n   * @member {IGradient|null|undefined} gradient\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.gradient = null\n\n  /**\n   * Fill patternTexture.\n   * @member {IPatternTexture|null|undefined} patternTexture\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.patternTexture = null\n\n  /**\n   * Fill width.\n   * @member {number} width\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.width = 0\n\n  /**\n   * Fill lineCap.\n   * @member {string} lineCap\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.lineCap = ''\n\n  /**\n   * Fill lineJoin.\n   * @member {string} lineJoin\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.lineJoin = ''\n\n  /**\n   * Fill strokeType.\n   * @member {number} strokeType\n   * @memberof Fill\n   * @instance\n   */\n  Fill.prototype.strokeType = 0\n\n  /**\n   * Creates a new Fill instance using the specified properties.\n   * @function create\n   * @memberof Fill\n   * @static\n   * @param {IFill=} [properties] Properties to set\n   * @returns {Fill} Fill instance\n   */\n  Fill.create = function create(properties) {\n    return new Fill(properties)\n  }\n\n  /**\n   * Encodes the specified Fill message. Does not implicitly {@link Fill.verify|verify} messages.\n   * @function encode\n   * @memberof Fill\n   * @static\n   * @param {IFill} message Fill message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Fill.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.type != null && Object.hasOwnProperty.call(message, 'type'))\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.type)\n    if (message.color != null && Object.hasOwnProperty.call(message, 'color'))\n      writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.color)\n    if (\n      message.gradient != null &&\n      Object.hasOwnProperty.call(message, 'gradient')\n    )\n      $root.Gradient.encode(\n        message.gradient,\n        writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),\n      ).ldelim()\n    if (\n      message.patternTexture != null &&\n      Object.hasOwnProperty.call(message, 'patternTexture')\n    )\n      $root.PatternTexture.encode(\n        message.patternTexture,\n        writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),\n      ).ldelim()\n    if (message.width != null && Object.hasOwnProperty.call(message, 'width'))\n      writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.width)\n    if (\n      message.lineCap != null &&\n      Object.hasOwnProperty.call(message, 'lineCap')\n    )\n      writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.lineCap)\n    if (\n      message.lineJoin != null &&\n      Object.hasOwnProperty.call(message, 'lineJoin')\n    )\n      writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.lineJoin)\n    if (\n      message.strokeType != null &&\n      Object.hasOwnProperty.call(message, 'strokeType')\n    )\n      writer.uint32(/* id 8, wireType 0 =*/ 64).int32(message.strokeType)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Fill message, length delimited. Does not implicitly {@link Fill.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Fill\n   * @static\n   * @param {IFill} message Fill message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Fill.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Fill message from the specified reader or buffer.\n   * @function decode\n   * @memberof Fill\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Fill} Fill\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Fill.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Fill()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32()\n          break\n        case 2:\n          message.color = reader.string()\n          break\n        case 3:\n          message.gradient = $root.Gradient.decode(reader, reader.uint32())\n          break\n        case 4:\n          message.patternTexture = $root.PatternTexture.decode(\n            reader,\n            reader.uint32(),\n          )\n          break\n        case 5:\n          message.width = reader.int32()\n          break\n        case 6:\n          message.lineCap = reader.string()\n          break\n        case 7:\n          message.lineJoin = reader.string()\n          break\n        case 8:\n          message.strokeType = reader.int32()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Fill message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Fill\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Fill} Fill\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Fill.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Fill message.\n   * @function verify\n   * @memberof Fill\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Fill.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.type != null && message.hasOwnProperty('type'))\n      if (!$util.isInteger(message.type)) return 'type: integer expected'\n    if (message.color != null && message.hasOwnProperty('color'))\n      if (!$util.isString(message.color)) return 'color: string expected'\n    if (message.gradient != null && message.hasOwnProperty('gradient')) {\n      let error = $root.Gradient.verify(message.gradient)\n      if (error) return 'gradient.' + error\n    }\n    if (\n      message.patternTexture != null &&\n      message.hasOwnProperty('patternTexture')\n    ) {\n      let error = $root.PatternTexture.verify(message.patternTexture)\n      if (error) return 'patternTexture.' + error\n    }\n    if (message.width != null && message.hasOwnProperty('width'))\n      if (!$util.isInteger(message.width)) return 'width: integer expected'\n    if (message.lineCap != null && message.hasOwnProperty('lineCap'))\n      if (!$util.isString(message.lineCap)) return 'lineCap: string expected'\n    if (message.lineJoin != null && message.hasOwnProperty('lineJoin'))\n      if (!$util.isString(message.lineJoin)) return 'lineJoin: string expected'\n    if (message.strokeType != null && message.hasOwnProperty('strokeType'))\n      if (!$util.isInteger(message.strokeType))\n        return 'strokeType: integer expected'\n    return null\n  }\n\n  /**\n   * Creates a Fill message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Fill\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Fill} Fill\n   */\n  Fill.fromObject = function fromObject(object) {\n    if (object instanceof $root.Fill) return object\n    let message = new $root.Fill()\n    if (object.type != null) message.type = object.type | 0\n    if (object.color != null) message.color = String(object.color)\n    if (object.gradient != null) {\n      if (typeof object.gradient !== 'object')\n        throw TypeError('.Fill.gradient: object expected')\n      message.gradient = $root.Gradient.fromObject(object.gradient)\n    }\n    if (object.patternTexture != null) {\n      if (typeof object.patternTexture !== 'object')\n        throw TypeError('.Fill.patternTexture: object expected')\n      message.patternTexture = $root.PatternTexture.fromObject(\n        object.patternTexture,\n      )\n    }\n    if (object.width != null) message.width = object.width | 0\n    if (object.lineCap != null) message.lineCap = String(object.lineCap)\n    if (object.lineJoin != null) message.lineJoin = String(object.lineJoin)\n    if (object.strokeType != null) message.strokeType = object.strokeType | 0\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Fill message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Fill\n   * @static\n   * @param {Fill} message Fill\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Fill.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.type = 0\n      object.color = ''\n      object.gradient = null\n      object.patternTexture = null\n      object.width = 0\n      object.lineCap = ''\n      object.lineJoin = ''\n      object.strokeType = 0\n    }\n    if (message.type != null && message.hasOwnProperty('type'))\n      object.type = message.type\n    if (message.color != null && message.hasOwnProperty('color'))\n      object.color = message.color\n    if (message.gradient != null && message.hasOwnProperty('gradient'))\n      object.gradient = $root.Gradient.toObject(message.gradient, options)\n    if (\n      message.patternTexture != null &&\n      message.hasOwnProperty('patternTexture')\n    )\n      object.patternTexture = $root.PatternTexture.toObject(\n        message.patternTexture,\n        options,\n      )\n    if (message.width != null && message.hasOwnProperty('width'))\n      object.width = message.width\n    if (message.lineCap != null && message.hasOwnProperty('lineCap'))\n      object.lineCap = message.lineCap\n    if (message.lineJoin != null && message.hasOwnProperty('lineJoin'))\n      object.lineJoin = message.lineJoin\n    if (message.strokeType != null && message.hasOwnProperty('strokeType'))\n      object.strokeType = message.strokeType\n    return object\n  }\n\n  /**\n   * Converts this Fill to JSON.\n   * @function toJSON\n   * @memberof Fill\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Fill.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Fill\n})())\n\nexport const FontResource = ($root.FontResource = (() => {\n  /**\n   * Properties of a FontResource.\n   * @exports IFontResource\n   * @interface IFontResource\n   * @property {Uint8Array|null} [font] FontResource font\n   */\n\n  /**\n   * Constructs a new FontResource.\n   * @exports FontResource\n   * @classdesc Represents a FontResource.\n   * @implements IFontResource\n   * @constructor\n   * @param {IFontResource=} [properties] Properties to set\n   */\n  function FontResource(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * FontResource font.\n   * @member {Uint8Array} font\n   * @memberof FontResource\n   * @instance\n   */\n  FontResource.prototype.font = $util.newBuffer([])\n\n  /**\n   * Creates a new FontResource instance using the specified properties.\n   * @function create\n   * @memberof FontResource\n   * @static\n   * @param {IFontResource=} [properties] Properties to set\n   * @returns {FontResource} FontResource instance\n   */\n  FontResource.create = function create(properties) {\n    return new FontResource(properties)\n  }\n\n  /**\n   * Encodes the specified FontResource message. Does not implicitly {@link FontResource.verify|verify} messages.\n   * @function encode\n   * @memberof FontResource\n   * @static\n   * @param {IFontResource} message FontResource message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  FontResource.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.font != null && Object.hasOwnProperty.call(message, 'font'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.font)\n    return writer\n  }\n\n  /**\n   * Encodes the specified FontResource message, length delimited. Does not implicitly {@link FontResource.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof FontResource\n   * @static\n   * @param {IFontResource} message FontResource message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  FontResource.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a FontResource message from the specified reader or buffer.\n   * @function decode\n   * @memberof FontResource\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {FontResource} FontResource\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  FontResource.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.FontResource()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.font = reader.bytes()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a FontResource message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof FontResource\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {FontResource} FontResource\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  FontResource.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a FontResource message.\n   * @function verify\n   * @memberof FontResource\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  FontResource.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.font != null && message.hasOwnProperty('font'))\n      if (\n        !(\n          (message.font && typeof message.font.length === 'number') ||\n          $util.isString(message.font)\n        )\n      )\n        return 'font: buffer expected'\n    return null\n  }\n\n  /**\n   * Creates a FontResource message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof FontResource\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {FontResource} FontResource\n   */\n  FontResource.fromObject = function fromObject(object) {\n    if (object instanceof $root.FontResource) return object\n    let message = new $root.FontResource()\n    if (object.font != null)\n      if (typeof object.font === 'string')\n        $util.base64.decode(\n          object.font,\n          (message.font = $util.newBuffer($util.base64.length(object.font))),\n          0,\n        )\n      else if (object.font.length) message.font = object.font\n    return message\n  }\n\n  /**\n   * Creates a plain object from a FontResource message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof FontResource\n   * @static\n   * @param {FontResource} message FontResource\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  FontResource.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults)\n      if (options.bytes === String) object.font = ''\n      else {\n        object.font = []\n        if (options.bytes !== Array) object.font = $util.newBuffer(object.font)\n      }\n    if (message.font != null && message.hasOwnProperty('font'))\n      object.font =\n        options.bytes === String\n          ? $util.base64.encode(message.font, 0, message.font.length)\n          : options.bytes === Array\n          ? Array.prototype.slice.call(message.font)\n          : message.font\n    return object\n  }\n\n  /**\n   * Converts this FontResource to JSON.\n   * @function toJSON\n   * @memberof FontResource\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  FontResource.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return FontResource\n})())\n\nexport const Font = ($root.Font = (() => {\n  /**\n   * Properties of a Font.\n   * @exports IFont\n   * @interface IFont\n   * @property {Array.<IFontResource>|null} [fonts] Font fonts\n   * @property {number|null} [size] Font size\n   * @property {number|null} [lineHeight] Font lineHeight\n   */\n\n  /**\n   * Constructs a new Font.\n   * @exports Font\n   * @classdesc Represents a Font.\n   * @implements IFont\n   * @constructor\n   * @param {IFont=} [properties] Properties to set\n   */\n  function Font(properties) {\n    this.fonts = []\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Font fonts.\n   * @member {Array.<IFontResource>} fonts\n   * @memberof Font\n   * @instance\n   */\n  Font.prototype.fonts = $util.emptyArray\n\n  /**\n   * Font size.\n   * @member {number} size\n   * @memberof Font\n   * @instance\n   */\n  Font.prototype.size = 0\n\n  /**\n   * Font lineHeight.\n   * @member {number} lineHeight\n   * @memberof Font\n   * @instance\n   */\n  Font.prototype.lineHeight = 0\n\n  /**\n   * Creates a new Font instance using the specified properties.\n   * @function create\n   * @memberof Font\n   * @static\n   * @param {IFont=} [properties] Properties to set\n   * @returns {Font} Font instance\n   */\n  Font.create = function create(properties) {\n    return new Font(properties)\n  }\n\n  /**\n   * Encodes the specified Font message. Does not implicitly {@link Font.verify|verify} messages.\n   * @function encode\n   * @memberof Font\n   * @static\n   * @param {IFont} message Font message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Font.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.fonts != null && message.fonts.length)\n      for (let i = 0; i < message.fonts.length; ++i)\n        $root.FontResource.encode(\n          message.fonts[i],\n          writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),\n        ).ldelim()\n    if (message.size != null && Object.hasOwnProperty.call(message, 'size'))\n      writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.size)\n    if (\n      message.lineHeight != null &&\n      Object.hasOwnProperty.call(message, 'lineHeight')\n    )\n      writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.lineHeight)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Font message, length delimited. Does not implicitly {@link Font.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Font\n   * @static\n   * @param {IFont} message Font message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Font.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Font message from the specified reader or buffer.\n   * @function decode\n   * @memberof Font\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Font} Font\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Font.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Font()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.fonts && message.fonts.length)) message.fonts = []\n          message.fonts.push($root.FontResource.decode(reader, reader.uint32()))\n          break\n        case 2:\n          message.size = reader.int32()\n          break\n        case 3:\n          message.lineHeight = reader.int32()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Font message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Font\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Font} Font\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Font.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Font message.\n   * @function verify\n   * @memberof Font\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Font.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.fonts != null && message.hasOwnProperty('fonts')) {\n      if (!Array.isArray(message.fonts)) return 'fonts: array expected'\n      for (let i = 0; i < message.fonts.length; ++i) {\n        let error = $root.FontResource.verify(message.fonts[i])\n        if (error) return 'fonts.' + error\n      }\n    }\n    if (message.size != null && message.hasOwnProperty('size'))\n      if (!$util.isInteger(message.size)) return 'size: integer expected'\n    if (message.lineHeight != null && message.hasOwnProperty('lineHeight'))\n      if (!$util.isInteger(message.lineHeight))\n        return 'lineHeight: integer expected'\n    return null\n  }\n\n  /**\n   * Creates a Font message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Font\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Font} Font\n   */\n  Font.fromObject = function fromObject(object) {\n    if (object instanceof $root.Font) return object\n    let message = new $root.Font()\n    if (object.fonts) {\n      if (!Array.isArray(object.fonts))\n        throw TypeError('.Font.fonts: array expected')\n      message.fonts = []\n      for (let i = 0; i < object.fonts.length; ++i) {\n        if (typeof object.fonts[i] !== 'object')\n          throw TypeError('.Font.fonts: object expected')\n        message.fonts[i] = $root.FontResource.fromObject(object.fonts[i])\n      }\n    }\n    if (object.size != null) message.size = object.size | 0\n    if (object.lineHeight != null) message.lineHeight = object.lineHeight | 0\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Font message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Font\n   * @static\n   * @param {Font} message Font\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Font.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.arrays || options.defaults) object.fonts = []\n    if (options.defaults) {\n      object.size = 0\n      object.lineHeight = 0\n    }\n    if (message.fonts && message.fonts.length) {\n      object.fonts = []\n      for (let j = 0; j < message.fonts.length; ++j)\n        object.fonts[j] = $root.FontResource.toObject(message.fonts[j], options)\n    }\n    if (message.size != null && message.hasOwnProperty('size'))\n      object.size = message.size\n    if (message.lineHeight != null && message.hasOwnProperty('lineHeight'))\n      object.lineHeight = message.lineHeight\n    return object\n  }\n\n  /**\n   * Converts this Font to JSON.\n   * @function toJSON\n   * @memberof Font\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Font.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Font\n})())\n\nexport const GlyphFont = ($root.GlyphFont = (() => {\n  /**\n   * Properties of a GlyphFont.\n   * @exports IGlyphFont\n   * @interface IGlyphFont\n   * @property {string|null} [letter] GlyphFont letter\n   * @property {IMetric|null} [adjustMetric] GlyphFont adjustMetric\n   * @property {Object.<string,number>|null} [kerning] GlyphFont kerning\n   */\n\n  /**\n   * Constructs a new GlyphFont.\n   * @exports GlyphFont\n   * @classdesc Represents a GlyphFont.\n   * @implements IGlyphFont\n   * @constructor\n   * @param {IGlyphFont=} [properties] Properties to set\n   */\n  function GlyphFont(properties) {\n    this.kerning = {}\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * GlyphFont letter.\n   * @member {string} letter\n   * @memberof GlyphFont\n   * @instance\n   */\n  GlyphFont.prototype.letter = ''\n\n  /**\n   * GlyphFont adjustMetric.\n   * @member {IMetric|null|undefined} adjustMetric\n   * @memberof GlyphFont\n   * @instance\n   */\n  GlyphFont.prototype.adjustMetric = null\n\n  /**\n   * GlyphFont kerning.\n   * @member {Object.<string,number>} kerning\n   * @memberof GlyphFont\n   * @instance\n   */\n  GlyphFont.prototype.kerning = $util.emptyObject\n\n  /**\n   * Creates a new GlyphFont instance using the specified properties.\n   * @function create\n   * @memberof GlyphFont\n   * @static\n   * @param {IGlyphFont=} [properties] Properties to set\n   * @returns {GlyphFont} GlyphFont instance\n   */\n  GlyphFont.create = function create(properties) {\n    return new GlyphFont(properties)\n  }\n\n  /**\n   * Encodes the specified GlyphFont message. Does not implicitly {@link GlyphFont.verify|verify} messages.\n   * @function encode\n   * @memberof GlyphFont\n   * @static\n   * @param {IGlyphFont} message GlyphFont message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GlyphFont.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.letter != null && Object.hasOwnProperty.call(message, 'letter'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.letter)\n    if (\n      message.adjustMetric != null &&\n      Object.hasOwnProperty.call(message, 'adjustMetric')\n    )\n      $root.Metric.encode(\n        message.adjustMetric,\n        writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n      ).ldelim()\n    if (\n      message.kerning != null &&\n      Object.hasOwnProperty.call(message, 'kerning')\n    )\n      for (let keys = Object.keys(message.kerning), i = 0; i < keys.length; ++i)\n        writer\n          .uint32(/* id 3, wireType 2 =*/ 26)\n          .fork()\n          .uint32(/* id 1, wireType 2 =*/ 10)\n          .string(keys[i])\n          .uint32(/* id 2, wireType 0 =*/ 16)\n          .int32(message.kerning[keys[i]])\n          .ldelim()\n    return writer\n  }\n\n  /**\n   * Encodes the specified GlyphFont message, length delimited. Does not implicitly {@link GlyphFont.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof GlyphFont\n   * @static\n   * @param {IGlyphFont} message GlyphFont message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GlyphFont.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a GlyphFont message from the specified reader or buffer.\n   * @function decode\n   * @memberof GlyphFont\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {GlyphFont} GlyphFont\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GlyphFont.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.GlyphFont(),\n      key,\n      value\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.letter = reader.string()\n          break\n        case 2:\n          message.adjustMetric = $root.Metric.decode(reader, reader.uint32())\n          break\n        case 3:\n          if (message.kerning === $util.emptyObject) message.kerning = {}\n          let end2 = reader.uint32() + reader.pos\n          key = ''\n          value = 0\n          while (reader.pos < end2) {\n            let tag2 = reader.uint32()\n            switch (tag2 >>> 3) {\n              case 1:\n                key = reader.string()\n                break\n              case 2:\n                value = reader.int32()\n                break\n              default:\n                reader.skipType(tag2 & 7)\n                break\n            }\n          }\n          message.kerning[key] = value\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a GlyphFont message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof GlyphFont\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {GlyphFont} GlyphFont\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GlyphFont.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a GlyphFont message.\n   * @function verify\n   * @memberof GlyphFont\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  GlyphFont.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.letter != null && message.hasOwnProperty('letter'))\n      if (!$util.isString(message.letter)) return 'letter: string expected'\n    if (\n      message.adjustMetric != null &&\n      message.hasOwnProperty('adjustMetric')\n    ) {\n      let error = $root.Metric.verify(message.adjustMetric)\n      if (error) return 'adjustMetric.' + error\n    }\n    if (message.kerning != null && message.hasOwnProperty('kerning')) {\n      if (!$util.isObject(message.kerning)) return 'kerning: object expected'\n      let key = Object.keys(message.kerning)\n      for (let i = 0; i < key.length; ++i)\n        if (!$util.isInteger(message.kerning[key[i]]))\n          return 'kerning: integer{k:string} expected'\n    }\n    return null\n  }\n\n  /**\n   * Creates a GlyphFont message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof GlyphFont\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {GlyphFont} GlyphFont\n   */\n  GlyphFont.fromObject = function fromObject(object) {\n    if (object instanceof $root.GlyphFont) return object\n    let message = new $root.GlyphFont()\n    if (object.letter != null) message.letter = String(object.letter)\n    if (object.adjustMetric != null) {\n      if (typeof object.adjustMetric !== 'object')\n        throw TypeError('.GlyphFont.adjustMetric: object expected')\n      message.adjustMetric = $root.Metric.fromObject(object.adjustMetric)\n    }\n    if (object.kerning) {\n      if (typeof object.kerning !== 'object')\n        throw TypeError('.GlyphFont.kerning: object expected')\n      message.kerning = {}\n      for (let keys = Object.keys(object.kerning), i = 0; i < keys.length; ++i)\n        message.kerning[keys[i]] = object.kerning[keys[i]] | 0\n    }\n    return message\n  }\n\n  /**\n   * Creates a plain object from a GlyphFont message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof GlyphFont\n   * @static\n   * @param {GlyphFont} message GlyphFont\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  GlyphFont.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.objects || options.defaults) object.kerning = {}\n    if (options.defaults) {\n      object.letter = ''\n      object.adjustMetric = null\n    }\n    if (message.letter != null && message.hasOwnProperty('letter'))\n      object.letter = message.letter\n    if (message.adjustMetric != null && message.hasOwnProperty('adjustMetric'))\n      object.adjustMetric = $root.Metric.toObject(message.adjustMetric, options)\n    let keys2\n    if (message.kerning && (keys2 = Object.keys(message.kerning)).length) {\n      object.kerning = {}\n      for (let j = 0; j < keys2.length; ++j)\n        object.kerning[keys2[j]] = message.kerning[keys2[j]]\n    }\n    return object\n  }\n\n  /**\n   * Converts this GlyphFont to JSON.\n   * @function toJSON\n   * @memberof GlyphFont\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  GlyphFont.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return GlyphFont\n})())\n\nexport const GlyphImage = ($root.GlyphImage = (() => {\n  /**\n   * Properties of a GlyphImage.\n   * @exports IGlyphImage\n   * @interface IGlyphImage\n   * @property {string|null} [letter] GlyphImage letter\n   * @property {IMetric|null} [adjustMetric] GlyphImage adjustMetric\n   * @property {Uint8Array|null} [buffer] GlyphImage buffer\n   * @property {string|null} [fileName] GlyphImage fileName\n   * @property {string|null} [fileType] GlyphImage fileType\n   * @property {boolean|null} [selected] GlyphImage selected\n   * @property {Object.<string,number>|null} [kerning] GlyphImage kerning\n   */\n\n  /**\n   * Constructs a new GlyphImage.\n   * @exports GlyphImage\n   * @classdesc Represents a GlyphImage.\n   * @implements IGlyphImage\n   * @constructor\n   * @param {IGlyphImage=} [properties] Properties to set\n   */\n  function GlyphImage(properties) {\n    this.kerning = {}\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * GlyphImage letter.\n   * @member {string} letter\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.letter = ''\n\n  /**\n   * GlyphImage adjustMetric.\n   * @member {IMetric|null|undefined} adjustMetric\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.adjustMetric = null\n\n  /**\n   * GlyphImage buffer.\n   * @member {Uint8Array} buffer\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.buffer = $util.newBuffer([])\n\n  /**\n   * GlyphImage fileName.\n   * @member {string} fileName\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.fileName = ''\n\n  /**\n   * GlyphImage fileType.\n   * @member {string} fileType\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.fileType = ''\n\n  /**\n   * GlyphImage selected.\n   * @member {boolean} selected\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.selected = false\n\n  /**\n   * GlyphImage kerning.\n   * @member {Object.<string,number>} kerning\n   * @memberof GlyphImage\n   * @instance\n   */\n  GlyphImage.prototype.kerning = $util.emptyObject\n\n  /**\n   * Creates a new GlyphImage instance using the specified properties.\n   * @function create\n   * @memberof GlyphImage\n   * @static\n   * @param {IGlyphImage=} [properties] Properties to set\n   * @returns {GlyphImage} GlyphImage instance\n   */\n  GlyphImage.create = function create(properties) {\n    return new GlyphImage(properties)\n  }\n\n  /**\n   * Encodes the specified GlyphImage message. Does not implicitly {@link GlyphImage.verify|verify} messages.\n   * @function encode\n   * @memberof GlyphImage\n   * @static\n   * @param {IGlyphImage} message GlyphImage message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GlyphImage.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.letter != null && Object.hasOwnProperty.call(message, 'letter'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.letter)\n    if (\n      message.adjustMetric != null &&\n      Object.hasOwnProperty.call(message, 'adjustMetric')\n    )\n      $root.Metric.encode(\n        message.adjustMetric,\n        writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n      ).ldelim()\n    if (message.buffer != null && Object.hasOwnProperty.call(message, 'buffer'))\n      writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.buffer)\n    if (\n      message.fileName != null &&\n      Object.hasOwnProperty.call(message, 'fileName')\n    )\n      writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.fileName)\n    if (\n      message.fileType != null &&\n      Object.hasOwnProperty.call(message, 'fileType')\n    )\n      writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.fileType)\n    if (\n      message.selected != null &&\n      Object.hasOwnProperty.call(message, 'selected')\n    )\n      writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.selected)\n    if (\n      message.kerning != null &&\n      Object.hasOwnProperty.call(message, 'kerning')\n    )\n      for (let keys = Object.keys(message.kerning), i = 0; i < keys.length; ++i)\n        writer\n          .uint32(/* id 7, wireType 2 =*/ 58)\n          .fork()\n          .uint32(/* id 1, wireType 2 =*/ 10)\n          .string(keys[i])\n          .uint32(/* id 2, wireType 0 =*/ 16)\n          .int32(message.kerning[keys[i]])\n          .ldelim()\n    return writer\n  }\n\n  /**\n   * Encodes the specified GlyphImage message, length delimited. Does not implicitly {@link GlyphImage.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof GlyphImage\n   * @static\n   * @param {IGlyphImage} message GlyphImage message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  GlyphImage.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a GlyphImage message from the specified reader or buffer.\n   * @function decode\n   * @memberof GlyphImage\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {GlyphImage} GlyphImage\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GlyphImage.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.GlyphImage(),\n      key,\n      value\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.letter = reader.string()\n          break\n        case 2:\n          message.adjustMetric = $root.Metric.decode(reader, reader.uint32())\n          break\n        case 3:\n          message.buffer = reader.bytes()\n          break\n        case 4:\n          message.fileName = reader.string()\n          break\n        case 5:\n          message.fileType = reader.string()\n          break\n        case 6:\n          message.selected = reader.bool()\n          break\n        case 7:\n          if (message.kerning === $util.emptyObject) message.kerning = {}\n          let end2 = reader.uint32() + reader.pos\n          key = ''\n          value = 0\n          while (reader.pos < end2) {\n            let tag2 = reader.uint32()\n            switch (tag2 >>> 3) {\n              case 1:\n                key = reader.string()\n                break\n              case 2:\n                value = reader.int32()\n                break\n              default:\n                reader.skipType(tag2 & 7)\n                break\n            }\n          }\n          message.kerning[key] = value\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a GlyphImage message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof GlyphImage\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {GlyphImage} GlyphImage\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  GlyphImage.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a GlyphImage message.\n   * @function verify\n   * @memberof GlyphImage\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  GlyphImage.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.letter != null && message.hasOwnProperty('letter'))\n      if (!$util.isString(message.letter)) return 'letter: string expected'\n    if (\n      message.adjustMetric != null &&\n      message.hasOwnProperty('adjustMetric')\n    ) {\n      let error = $root.Metric.verify(message.adjustMetric)\n      if (error) return 'adjustMetric.' + error\n    }\n    if (message.buffer != null && message.hasOwnProperty('buffer'))\n      if (\n        !(\n          (message.buffer && typeof message.buffer.length === 'number') ||\n          $util.isString(message.buffer)\n        )\n      )\n        return 'buffer: buffer expected'\n    if (message.fileName != null && message.hasOwnProperty('fileName'))\n      if (!$util.isString(message.fileName)) return 'fileName: string expected'\n    if (message.fileType != null && message.hasOwnProperty('fileType'))\n      if (!$util.isString(message.fileType)) return 'fileType: string expected'\n    if (message.selected != null && message.hasOwnProperty('selected'))\n      if (typeof message.selected !== 'boolean')\n        return 'selected: boolean expected'\n    if (message.kerning != null && message.hasOwnProperty('kerning')) {\n      if (!$util.isObject(message.kerning)) return 'kerning: object expected'\n      let key = Object.keys(message.kerning)\n      for (let i = 0; i < key.length; ++i)\n        if (!$util.isInteger(message.kerning[key[i]]))\n          return 'kerning: integer{k:string} expected'\n    }\n    return null\n  }\n\n  /**\n   * Creates a GlyphImage message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof GlyphImage\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {GlyphImage} GlyphImage\n   */\n  GlyphImage.fromObject = function fromObject(object) {\n    if (object instanceof $root.GlyphImage) return object\n    let message = new $root.GlyphImage()\n    if (object.letter != null) message.letter = String(object.letter)\n    if (object.adjustMetric != null) {\n      if (typeof object.adjustMetric !== 'object')\n        throw TypeError('.GlyphImage.adjustMetric: object expected')\n      message.adjustMetric = $root.Metric.fromObject(object.adjustMetric)\n    }\n    if (object.buffer != null)\n      if (typeof object.buffer === 'string')\n        $util.base64.decode(\n          object.buffer,\n          (message.buffer = $util.newBuffer(\n            $util.base64.length(object.buffer),\n          )),\n          0,\n        )\n      else if (object.buffer.length) message.buffer = object.buffer\n    if (object.fileName != null) message.fileName = String(object.fileName)\n    if (object.fileType != null) message.fileType = String(object.fileType)\n    if (object.selected != null) message.selected = Boolean(object.selected)\n    if (object.kerning) {\n      if (typeof object.kerning !== 'object')\n        throw TypeError('.GlyphImage.kerning: object expected')\n      message.kerning = {}\n      for (let keys = Object.keys(object.kerning), i = 0; i < keys.length; ++i)\n        message.kerning[keys[i]] = object.kerning[keys[i]] | 0\n    }\n    return message\n  }\n\n  /**\n   * Creates a plain object from a GlyphImage message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof GlyphImage\n   * @static\n   * @param {GlyphImage} message GlyphImage\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  GlyphImage.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.objects || options.defaults) object.kerning = {}\n    if (options.defaults) {\n      object.letter = ''\n      object.adjustMetric = null\n      if (options.bytes === String) object.buffer = ''\n      else {\n        object.buffer = []\n        if (options.bytes !== Array)\n          object.buffer = $util.newBuffer(object.buffer)\n      }\n      object.fileName = ''\n      object.fileType = ''\n      object.selected = false\n    }\n    if (message.letter != null && message.hasOwnProperty('letter'))\n      object.letter = message.letter\n    if (message.adjustMetric != null && message.hasOwnProperty('adjustMetric'))\n      object.adjustMetric = $root.Metric.toObject(message.adjustMetric, options)\n    if (message.buffer != null && message.hasOwnProperty('buffer'))\n      object.buffer =\n        options.bytes === String\n          ? $util.base64.encode(message.buffer, 0, message.buffer.length)\n          : options.bytes === Array\n          ? Array.prototype.slice.call(message.buffer)\n          : message.buffer\n    if (message.fileName != null && message.hasOwnProperty('fileName'))\n      object.fileName = message.fileName\n    if (message.fileType != null && message.hasOwnProperty('fileType'))\n      object.fileType = message.fileType\n    if (message.selected != null && message.hasOwnProperty('selected'))\n      object.selected = message.selected\n    let keys2\n    if (message.kerning && (keys2 = Object.keys(message.kerning)).length) {\n      object.kerning = {}\n      for (let j = 0; j < keys2.length; ++j)\n        object.kerning[keys2[j]] = message.kerning[keys2[j]]\n    }\n    return object\n  }\n\n  /**\n   * Converts this GlyphImage to JSON.\n   * @function toJSON\n   * @memberof GlyphImage\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  GlyphImage.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return GlyphImage\n})())\n\nexport const Layout = ($root.Layout = (() => {\n  /**\n   * Properties of a Layout.\n   * @exports ILayout\n   * @interface ILayout\n   * @property {number|null} [padding] Layout padding\n   * @property {number|null} [spacing] Layout spacing\n   * @property {number|null} [width] Layout width\n   * @property {number|null} [height] Layout height\n   * @property {boolean|null} [auto] Layout auto\n   * @property {boolean|null} [fixedSize] Layout fixedSize\n   */\n\n  /**\n   * Constructs a new Layout.\n   * @exports Layout\n   * @classdesc Represents a Layout.\n   * @implements ILayout\n   * @constructor\n   * @param {ILayout=} [properties] Properties to set\n   */\n  function Layout(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Layout padding.\n   * @member {number} padding\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.padding = 0\n\n  /**\n   * Layout spacing.\n   * @member {number} spacing\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.spacing = 0\n\n  /**\n   * Layout width.\n   * @member {number} width\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.width = 0\n\n  /**\n   * Layout height.\n   * @member {number} height\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.height = 0\n\n  /**\n   * Layout auto.\n   * @member {boolean} auto\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.auto = false\n\n  /**\n   * Layout fixedSize.\n   * @member {boolean} fixedSize\n   * @memberof Layout\n   * @instance\n   */\n  Layout.prototype.fixedSize = false\n\n  /**\n   * Creates a new Layout instance using the specified properties.\n   * @function create\n   * @memberof Layout\n   * @static\n   * @param {ILayout=} [properties] Properties to set\n   * @returns {Layout} Layout instance\n   */\n  Layout.create = function create(properties) {\n    return new Layout(properties)\n  }\n\n  /**\n   * Encodes the specified Layout message. Does not implicitly {@link Layout.verify|verify} messages.\n   * @function encode\n   * @memberof Layout\n   * @static\n   * @param {ILayout} message Layout message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Layout.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (\n      message.padding != null &&\n      Object.hasOwnProperty.call(message, 'padding')\n    )\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.padding)\n    if (\n      message.spacing != null &&\n      Object.hasOwnProperty.call(message, 'spacing')\n    )\n      writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.spacing)\n    if (message.width != null && Object.hasOwnProperty.call(message, 'width'))\n      writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.width)\n    if (message.height != null && Object.hasOwnProperty.call(message, 'height'))\n      writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.height)\n    if (message.auto != null && Object.hasOwnProperty.call(message, 'auto'))\n      writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.auto)\n    if (\n      message.fixedSize != null &&\n      Object.hasOwnProperty.call(message, 'fixedSize')\n    )\n      writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.fixedSize)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Layout message, length delimited. Does not implicitly {@link Layout.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Layout\n   * @static\n   * @param {ILayout} message Layout message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Layout.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Layout message from the specified reader or buffer.\n   * @function decode\n   * @memberof Layout\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Layout} Layout\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Layout.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Layout()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.padding = reader.int32()\n          break\n        case 2:\n          message.spacing = reader.int32()\n          break\n        case 3:\n          message.width = reader.int32()\n          break\n        case 4:\n          message.height = reader.int32()\n          break\n        case 5:\n          message.auto = reader.bool()\n          break\n        case 6:\n          message.fixedSize = reader.bool()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Layout message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Layout\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Layout} Layout\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Layout.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Layout message.\n   * @function verify\n   * @memberof Layout\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Layout.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.padding != null && message.hasOwnProperty('padding'))\n      if (!$util.isInteger(message.padding)) return 'padding: integer expected'\n    if (message.spacing != null && message.hasOwnProperty('spacing'))\n      if (!$util.isInteger(message.spacing)) return 'spacing: integer expected'\n    if (message.width != null && message.hasOwnProperty('width'))\n      if (!$util.isInteger(message.width)) return 'width: integer expected'\n    if (message.height != null && message.hasOwnProperty('height'))\n      if (!$util.isInteger(message.height)) return 'height: integer expected'\n    if (message.auto != null && message.hasOwnProperty('auto'))\n      if (typeof message.auto !== 'boolean') return 'auto: boolean expected'\n    if (message.fixedSize != null && message.hasOwnProperty('fixedSize'))\n      if (typeof message.fixedSize !== 'boolean')\n        return 'fixedSize: boolean expected'\n    return null\n  }\n\n  /**\n   * Creates a Layout message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Layout\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Layout} Layout\n   */\n  Layout.fromObject = function fromObject(object) {\n    if (object instanceof $root.Layout) return object\n    let message = new $root.Layout()\n    if (object.padding != null) message.padding = object.padding | 0\n    if (object.spacing != null) message.spacing = object.spacing | 0\n    if (object.width != null) message.width = object.width | 0\n    if (object.height != null) message.height = object.height | 0\n    if (object.auto != null) message.auto = Boolean(object.auto)\n    if (object.fixedSize != null) message.fixedSize = Boolean(object.fixedSize)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Layout message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Layout\n   * @static\n   * @param {Layout} message Layout\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Layout.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.padding = 0\n      object.spacing = 0\n      object.width = 0\n      object.height = 0\n      object.auto = false\n      object.fixedSize = false\n    }\n    if (message.padding != null && message.hasOwnProperty('padding'))\n      object.padding = message.padding\n    if (message.spacing != null && message.hasOwnProperty('spacing'))\n      object.spacing = message.spacing\n    if (message.width != null && message.hasOwnProperty('width'))\n      object.width = message.width\n    if (message.height != null && message.hasOwnProperty('height'))\n      object.height = message.height\n    if (message.auto != null && message.hasOwnProperty('auto'))\n      object.auto = message.auto\n    if (message.fixedSize != null && message.hasOwnProperty('fixedSize'))\n      object.fixedSize = message.fixedSize\n    return object\n  }\n\n  /**\n   * Converts this Layout to JSON.\n   * @function toJSON\n   * @memberof Layout\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Layout.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Layout\n})())\n\nexport const Shadow = ($root.Shadow = (() => {\n  /**\n   * Properties of a Shadow.\n   * @exports IShadow\n   * @interface IShadow\n   * @property {string|null} [color] Shadow color\n   * @property {number|null} [blur] Shadow blur\n   * @property {number|null} [offsetX] Shadow offsetX\n   * @property {number|null} [offsetY] Shadow offsetY\n   */\n\n  /**\n   * Constructs a new Shadow.\n   * @exports Shadow\n   * @classdesc Represents a Shadow.\n   * @implements IShadow\n   * @constructor\n   * @param {IShadow=} [properties] Properties to set\n   */\n  function Shadow(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Shadow color.\n   * @member {string} color\n   * @memberof Shadow\n   * @instance\n   */\n  Shadow.prototype.color = ''\n\n  /**\n   * Shadow blur.\n   * @member {number} blur\n   * @memberof Shadow\n   * @instance\n   */\n  Shadow.prototype.blur = 0\n\n  /**\n   * Shadow offsetX.\n   * @member {number} offsetX\n   * @memberof Shadow\n   * @instance\n   */\n  Shadow.prototype.offsetX = 0\n\n  /**\n   * Shadow offsetY.\n   * @member {number} offsetY\n   * @memberof Shadow\n   * @instance\n   */\n  Shadow.prototype.offsetY = 0\n\n  /**\n   * Creates a new Shadow instance using the specified properties.\n   * @function create\n   * @memberof Shadow\n   * @static\n   * @param {IShadow=} [properties] Properties to set\n   * @returns {Shadow} Shadow instance\n   */\n  Shadow.create = function create(properties) {\n    return new Shadow(properties)\n  }\n\n  /**\n   * Encodes the specified Shadow message. Does not implicitly {@link Shadow.verify|verify} messages.\n   * @function encode\n   * @memberof Shadow\n   * @static\n   * @param {IShadow} message Shadow message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Shadow.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.color != null && Object.hasOwnProperty.call(message, 'color'))\n      writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.color)\n    if (message.blur != null && Object.hasOwnProperty.call(message, 'blur'))\n      writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.blur)\n    if (\n      message.offsetX != null &&\n      Object.hasOwnProperty.call(message, 'offsetX')\n    )\n      writer.uint32(/* id 3, wireType 0 =*/ 24).sint32(message.offsetX)\n    if (\n      message.offsetY != null &&\n      Object.hasOwnProperty.call(message, 'offsetY')\n    )\n      writer.uint32(/* id 4, wireType 0 =*/ 32).sint32(message.offsetY)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Shadow message, length delimited. Does not implicitly {@link Shadow.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Shadow\n   * @static\n   * @param {IShadow} message Shadow message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Shadow.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Shadow message from the specified reader or buffer.\n   * @function decode\n   * @memberof Shadow\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Shadow} Shadow\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Shadow.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Shadow()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.color = reader.string()\n          break\n        case 2:\n          message.blur = reader.int32()\n          break\n        case 3:\n          message.offsetX = reader.sint32()\n          break\n        case 4:\n          message.offsetY = reader.sint32()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Shadow message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Shadow\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Shadow} Shadow\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Shadow.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Shadow message.\n   * @function verify\n   * @memberof Shadow\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Shadow.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.color != null && message.hasOwnProperty('color'))\n      if (!$util.isString(message.color)) return 'color: string expected'\n    if (message.blur != null && message.hasOwnProperty('blur'))\n      if (!$util.isInteger(message.blur)) return 'blur: integer expected'\n    if (message.offsetX != null && message.hasOwnProperty('offsetX'))\n      if (!$util.isInteger(message.offsetX)) return 'offsetX: integer expected'\n    if (message.offsetY != null && message.hasOwnProperty('offsetY'))\n      if (!$util.isInteger(message.offsetY)) return 'offsetY: integer expected'\n    return null\n  }\n\n  /**\n   * Creates a Shadow message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Shadow\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Shadow} Shadow\n   */\n  Shadow.fromObject = function fromObject(object) {\n    if (object instanceof $root.Shadow) return object\n    let message = new $root.Shadow()\n    if (object.color != null) message.color = String(object.color)\n    if (object.blur != null) message.blur = object.blur | 0\n    if (object.offsetX != null) message.offsetX = object.offsetX | 0\n    if (object.offsetY != null) message.offsetY = object.offsetY | 0\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Shadow message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Shadow\n   * @static\n   * @param {Shadow} message Shadow\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Shadow.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.color = ''\n      object.blur = 0\n      object.offsetX = 0\n      object.offsetY = 0\n    }\n    if (message.color != null && message.hasOwnProperty('color'))\n      object.color = message.color\n    if (message.blur != null && message.hasOwnProperty('blur'))\n      object.blur = message.blur\n    if (message.offsetX != null && message.hasOwnProperty('offsetX'))\n      object.offsetX = message.offsetX\n    if (message.offsetY != null && message.hasOwnProperty('offsetY'))\n      object.offsetY = message.offsetY\n    return object\n  }\n\n  /**\n   * Converts this Shadow to JSON.\n   * @function toJSON\n   * @memberof Shadow\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Shadow.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Shadow\n})())\n\nexport const Style = ($root.Style = (() => {\n  /**\n   * Properties of a Style.\n   * @exports IStyle\n   * @interface IStyle\n   * @property {IFont|null} [font] Style font\n   * @property {IFill|null} [fill] Style fill\n   * @property {boolean|null} [useStroke] Style useStroke\n   * @property {IFill|null} [stroke] Style stroke\n   * @property {boolean|null} [useShadow] Style useShadow\n   * @property {IShadow|null} [shadow] Style shadow\n   * @property {string|null} [bgColor] Style bgColor\n   */\n\n  /**\n   * Constructs a new Style.\n   * @exports Style\n   * @classdesc Represents a Style.\n   * @implements IStyle\n   * @constructor\n   * @param {IStyle=} [properties] Properties to set\n   */\n  function Style(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Style font.\n   * @member {IFont|null|undefined} font\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.font = null\n\n  /**\n   * Style fill.\n   * @member {IFill|null|undefined} fill\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.fill = null\n\n  /**\n   * Style useStroke.\n   * @member {boolean} useStroke\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.useStroke = false\n\n  /**\n   * Style stroke.\n   * @member {IFill|null|undefined} stroke\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.stroke = null\n\n  /**\n   * Style useShadow.\n   * @member {boolean} useShadow\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.useShadow = false\n\n  /**\n   * Style shadow.\n   * @member {IShadow|null|undefined} shadow\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.shadow = null\n\n  /**\n   * Style bgColor.\n   * @member {string} bgColor\n   * @memberof Style\n   * @instance\n   */\n  Style.prototype.bgColor = ''\n\n  /**\n   * Creates a new Style instance using the specified properties.\n   * @function create\n   * @memberof Style\n   * @static\n   * @param {IStyle=} [properties] Properties to set\n   * @returns {Style} Style instance\n   */\n  Style.create = function create(properties) {\n    return new Style(properties)\n  }\n\n  /**\n   * Encodes the specified Style message. Does not implicitly {@link Style.verify|verify} messages.\n   * @function encode\n   * @memberof Style\n   * @static\n   * @param {IStyle} message Style message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Style.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.font != null && Object.hasOwnProperty.call(message, 'font'))\n      $root.Font.encode(\n        message.font,\n        writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),\n      ).ldelim()\n    if (message.fill != null && Object.hasOwnProperty.call(message, 'fill'))\n      $root.Fill.encode(\n        message.fill,\n        writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n      ).ldelim()\n    if (\n      message.useStroke != null &&\n      Object.hasOwnProperty.call(message, 'useStroke')\n    )\n      writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.useStroke)\n    if (message.stroke != null && Object.hasOwnProperty.call(message, 'stroke'))\n      $root.Fill.encode(\n        message.stroke,\n        writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),\n      ).ldelim()\n    if (\n      message.useShadow != null &&\n      Object.hasOwnProperty.call(message, 'useShadow')\n    )\n      writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.useShadow)\n    if (message.shadow != null && Object.hasOwnProperty.call(message, 'shadow'))\n      $root.Shadow.encode(\n        message.shadow,\n        writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),\n      ).ldelim()\n    if (\n      message.bgColor != null &&\n      Object.hasOwnProperty.call(message, 'bgColor')\n    )\n      writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.bgColor)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Style message, length delimited. Does not implicitly {@link Style.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Style\n   * @static\n   * @param {IStyle} message Style message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Style.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Style message from the specified reader or buffer.\n   * @function decode\n   * @memberof Style\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Style} Style\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Style.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Style()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.font = $root.Font.decode(reader, reader.uint32())\n          break\n        case 2:\n          message.fill = $root.Fill.decode(reader, reader.uint32())\n          break\n        case 3:\n          message.useStroke = reader.bool()\n          break\n        case 4:\n          message.stroke = $root.Fill.decode(reader, reader.uint32())\n          break\n        case 5:\n          message.useShadow = reader.bool()\n          break\n        case 6:\n          message.shadow = $root.Shadow.decode(reader, reader.uint32())\n          break\n        case 7:\n          message.bgColor = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Style message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Style\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Style} Style\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Style.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Style message.\n   * @function verify\n   * @memberof Style\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Style.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.font != null && message.hasOwnProperty('font')) {\n      let error = $root.Font.verify(message.font)\n      if (error) return 'font.' + error\n    }\n    if (message.fill != null && message.hasOwnProperty('fill')) {\n      let error = $root.Fill.verify(message.fill)\n      if (error) return 'fill.' + error\n    }\n    if (message.useStroke != null && message.hasOwnProperty('useStroke'))\n      if (typeof message.useStroke !== 'boolean')\n        return 'useStroke: boolean expected'\n    if (message.stroke != null && message.hasOwnProperty('stroke')) {\n      let error = $root.Fill.verify(message.stroke)\n      if (error) return 'stroke.' + error\n    }\n    if (message.useShadow != null && message.hasOwnProperty('useShadow'))\n      if (typeof message.useShadow !== 'boolean')\n        return 'useShadow: boolean expected'\n    if (message.shadow != null && message.hasOwnProperty('shadow')) {\n      let error = $root.Shadow.verify(message.shadow)\n      if (error) return 'shadow.' + error\n    }\n    if (message.bgColor != null && message.hasOwnProperty('bgColor'))\n      if (!$util.isString(message.bgColor)) return 'bgColor: string expected'\n    return null\n  }\n\n  /**\n   * Creates a Style message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Style\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Style} Style\n   */\n  Style.fromObject = function fromObject(object) {\n    if (object instanceof $root.Style) return object\n    let message = new $root.Style()\n    if (object.font != null) {\n      if (typeof object.font !== 'object')\n        throw TypeError('.Style.font: object expected')\n      message.font = $root.Font.fromObject(object.font)\n    }\n    if (object.fill != null) {\n      if (typeof object.fill !== 'object')\n        throw TypeError('.Style.fill: object expected')\n      message.fill = $root.Fill.fromObject(object.fill)\n    }\n    if (object.useStroke != null) message.useStroke = Boolean(object.useStroke)\n    if (object.stroke != null) {\n      if (typeof object.stroke !== 'object')\n        throw TypeError('.Style.stroke: object expected')\n      message.stroke = $root.Fill.fromObject(object.stroke)\n    }\n    if (object.useShadow != null) message.useShadow = Boolean(object.useShadow)\n    if (object.shadow != null) {\n      if (typeof object.shadow !== 'object')\n        throw TypeError('.Style.shadow: object expected')\n      message.shadow = $root.Shadow.fromObject(object.shadow)\n    }\n    if (object.bgColor != null) message.bgColor = String(object.bgColor)\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Style message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Style\n   * @static\n   * @param {Style} message Style\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Style.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) {\n      object.font = null\n      object.fill = null\n      object.useStroke = false\n      object.stroke = null\n      object.useShadow = false\n      object.shadow = null\n      object.bgColor = ''\n    }\n    if (message.font != null && message.hasOwnProperty('font'))\n      object.font = $root.Font.toObject(message.font, options)\n    if (message.fill != null && message.hasOwnProperty('fill'))\n      object.fill = $root.Fill.toObject(message.fill, options)\n    if (message.useStroke != null && message.hasOwnProperty('useStroke'))\n      object.useStroke = message.useStroke\n    if (message.stroke != null && message.hasOwnProperty('stroke'))\n      object.stroke = $root.Fill.toObject(message.stroke, options)\n    if (message.useShadow != null && message.hasOwnProperty('useShadow'))\n      object.useShadow = message.useShadow\n    if (message.shadow != null && message.hasOwnProperty('shadow'))\n      object.shadow = $root.Shadow.toObject(message.shadow, options)\n    if (message.bgColor != null && message.hasOwnProperty('bgColor'))\n      object.bgColor = message.bgColor\n    return object\n  }\n\n  /**\n   * Converts this Style to JSON.\n   * @function toJSON\n   * @memberof Style\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Style.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Style\n})())\n\nexport const Ui = ($root.Ui = (() => {\n  /**\n   * Properties of an Ui.\n   * @exports IUi\n   * @interface IUi\n   * @property {string|null} [previewText] Ui previewText\n   */\n\n  /**\n   * Constructs a new Ui.\n   * @exports Ui\n   * @classdesc Represents an Ui.\n   * @implements IUi\n   * @constructor\n   * @param {IUi=} [properties] Properties to set\n   */\n  function Ui(properties) {\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Ui previewText.\n   * @member {string} previewText\n   * @memberof Ui\n   * @instance\n   */\n  Ui.prototype.previewText = ''\n\n  /**\n   * Creates a new Ui instance using the specified properties.\n   * @function create\n   * @memberof Ui\n   * @static\n   * @param {IUi=} [properties] Properties to set\n   * @returns {Ui} Ui instance\n   */\n  Ui.create = function create(properties) {\n    return new Ui(properties)\n  }\n\n  /**\n   * Encodes the specified Ui message. Does not implicitly {@link Ui.verify|verify} messages.\n   * @function encode\n   * @memberof Ui\n   * @static\n   * @param {IUi} message Ui message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Ui.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (\n      message.previewText != null &&\n      Object.hasOwnProperty.call(message, 'previewText')\n    )\n      writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.previewText)\n    return writer\n  }\n\n  /**\n   * Encodes the specified Ui message, length delimited. Does not implicitly {@link Ui.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Ui\n   * @static\n   * @param {IUi} message Ui message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Ui.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes an Ui message from the specified reader or buffer.\n   * @function decode\n   * @memberof Ui\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Ui} Ui\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Ui.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Ui()\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.previewText = reader.string()\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes an Ui message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Ui\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Ui} Ui\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Ui.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies an Ui message.\n   * @function verify\n   * @memberof Ui\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Ui.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.previewText != null && message.hasOwnProperty('previewText'))\n      if (!$util.isString(message.previewText))\n        return 'previewText: string expected'\n    return null\n  }\n\n  /**\n   * Creates an Ui message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Ui\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Ui} Ui\n   */\n  Ui.fromObject = function fromObject(object) {\n    if (object instanceof $root.Ui) return object\n    let message = new $root.Ui()\n    if (object.previewText != null)\n      message.previewText = String(object.previewText)\n    return message\n  }\n\n  /**\n   * Creates a plain object from an Ui message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Ui\n   * @static\n   * @param {Ui} message Ui\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Ui.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.defaults) object.previewText = ''\n    if (message.previewText != null && message.hasOwnProperty('previewText'))\n      object.previewText = message.previewText\n    return object\n  }\n\n  /**\n   * Converts this Ui to JSON.\n   * @function toJSON\n   * @memberof Ui\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Ui.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Ui\n})())\n\nexport const Project = ($root.Project = (() => {\n  /**\n   * Properties of a Project.\n   * @exports IProject\n   * @interface IProject\n   * @property {number|Long|null} [id] Project id\n   * @property {string|null} [name] Project name\n   * @property {string|null} [text] Project text\n   * @property {Object.<string,IGlyphFont>|null} [glyphs] Project glyphs\n   * @property {Array.<IGlyphImage>|null} [glyphImages] Project glyphImages\n   * @property {IStyle|null} [style] Project style\n   * @property {ILayout|null} [layout] Project layout\n   * @property {IMetric|null} [globalAdjustMetric] Project globalAdjustMetric\n   * @property {IUi|null} [ui] Project ui\n   */\n\n  /**\n   * Constructs a new Project.\n   * @exports Project\n   * @classdesc Represents a Project.\n   * @implements IProject\n   * @constructor\n   * @param {IProject=} [properties] Properties to set\n   */\n  function Project(properties) {\n    this.glyphs = {}\n    this.glyphImages = []\n    if (properties)\n      for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n        if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n  }\n\n  /**\n   * Project id.\n   * @member {number|Long} id\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.id = $util.Long ? $util.Long.fromBits(0, 0, false) : 0\n\n  /**\n   * Project name.\n   * @member {string} name\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.name = ''\n\n  /**\n   * Project text.\n   * @member {string} text\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.text = ''\n\n  /**\n   * Project glyphs.\n   * @member {Object.<string,IGlyphFont>} glyphs\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.glyphs = $util.emptyObject\n\n  /**\n   * Project glyphImages.\n   * @member {Array.<IGlyphImage>} glyphImages\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.glyphImages = $util.emptyArray\n\n  /**\n   * Project style.\n   * @member {IStyle|null|undefined} style\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.style = null\n\n  /**\n   * Project layout.\n   * @member {ILayout|null|undefined} layout\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.layout = null\n\n  /**\n   * Project globalAdjustMetric.\n   * @member {IMetric|null|undefined} globalAdjustMetric\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.globalAdjustMetric = null\n\n  /**\n   * Project ui.\n   * @member {IUi|null|undefined} ui\n   * @memberof Project\n   * @instance\n   */\n  Project.prototype.ui = null\n\n  /**\n   * Creates a new Project instance using the specified properties.\n   * @function create\n   * @memberof Project\n   * @static\n   * @param {IProject=} [properties] Properties to set\n   * @returns {Project} Project instance\n   */\n  Project.create = function create(properties) {\n    return new Project(properties)\n  }\n\n  /**\n   * Encodes the specified Project message. Does not implicitly {@link Project.verify|verify} messages.\n   * @function encode\n   * @memberof Project\n   * @static\n   * @param {IProject} message Project message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Project.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create()\n    if (message.id != null && Object.hasOwnProperty.call(message, 'id'))\n      writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.id)\n    if (message.name != null && Object.hasOwnProperty.call(message, 'name'))\n      writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name)\n    if (message.text != null && Object.hasOwnProperty.call(message, 'text'))\n      writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.text)\n    if (message.glyphs != null && Object.hasOwnProperty.call(message, 'glyphs'))\n      for (\n        let keys = Object.keys(message.glyphs), i = 0;\n        i < keys.length;\n        ++i\n      ) {\n        writer\n          .uint32(/* id 4, wireType 2 =*/ 34)\n          .fork()\n          .uint32(/* id 1, wireType 2 =*/ 10)\n          .string(keys[i])\n        $root.GlyphFont.encode(\n          message.glyphs[keys[i]],\n          writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),\n        )\n          .ldelim()\n          .ldelim()\n      }\n    if (message.glyphImages != null && message.glyphImages.length)\n      for (let i = 0; i < message.glyphImages.length; ++i)\n        $root.GlyphImage.encode(\n          message.glyphImages[i],\n          writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),\n        ).ldelim()\n    if (message.style != null && Object.hasOwnProperty.call(message, 'style'))\n      $root.Style.encode(\n        message.style,\n        writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),\n      ).ldelim()\n    if (message.layout != null && Object.hasOwnProperty.call(message, 'layout'))\n      $root.Layout.encode(\n        message.layout,\n        writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),\n      ).ldelim()\n    if (\n      message.globalAdjustMetric != null &&\n      Object.hasOwnProperty.call(message, 'globalAdjustMetric')\n    )\n      $root.Metric.encode(\n        message.globalAdjustMetric,\n        writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),\n      ).ldelim()\n    if (message.ui != null && Object.hasOwnProperty.call(message, 'ui'))\n      $root.Ui.encode(\n        message.ui,\n        writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),\n      ).ldelim()\n    return writer\n  }\n\n  /**\n   * Encodes the specified Project message, length delimited. Does not implicitly {@link Project.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Project\n   * @static\n   * @param {IProject} message Project message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n  Project.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim()\n  }\n\n  /**\n   * Decodes a Project message from the specified reader or buffer.\n   * @function decode\n   * @memberof Project\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Project} Project\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Project.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n    let end = length === undefined ? reader.len : reader.pos + length,\n      message = new $root.Project(),\n      key,\n      value\n    while (reader.pos < end) {\n      let tag = reader.uint32()\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.int64()\n          break\n        case 2:\n          message.name = reader.string()\n          break\n        case 3:\n          message.text = reader.string()\n          break\n        case 4:\n          if (message.glyphs === $util.emptyObject) message.glyphs = {}\n          let end2 = reader.uint32() + reader.pos\n          key = ''\n          value = null\n          while (reader.pos < end2) {\n            let tag2 = reader.uint32()\n            switch (tag2 >>> 3) {\n              case 1:\n                key = reader.string()\n                break\n              case 2:\n                value = $root.GlyphFont.decode(reader, reader.uint32())\n                break\n              default:\n                reader.skipType(tag2 & 7)\n                break\n            }\n          }\n          message.glyphs[key] = value\n          break\n        case 5:\n          if (!(message.glyphImages && message.glyphImages.length))\n            message.glyphImages = []\n          message.glyphImages.push(\n            $root.GlyphImage.decode(reader, reader.uint32()),\n          )\n          break\n        case 6:\n          message.style = $root.Style.decode(reader, reader.uint32())\n          break\n        case 7:\n          message.layout = $root.Layout.decode(reader, reader.uint32())\n          break\n        case 8:\n          message.globalAdjustMetric = $root.Metric.decode(\n            reader,\n            reader.uint32(),\n          )\n          break\n        case 9:\n          message.ui = $root.Ui.decode(reader, reader.uint32())\n          break\n        default:\n          reader.skipType(tag & 7)\n          break\n      }\n    }\n    return message\n  }\n\n  /**\n   * Decodes a Project message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Project\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Project} Project\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n  Project.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n    return this.decode(reader, reader.uint32())\n  }\n\n  /**\n   * Verifies a Project message.\n   * @function verify\n   * @memberof Project\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n  Project.verify = function verify(message) {\n    if (typeof message !== 'object' || message === null)\n      return 'object expected'\n    if (message.id != null && message.hasOwnProperty('id'))\n      if (\n        !$util.isInteger(message.id) &&\n        !(\n          message.id &&\n          $util.isInteger(message.id.low) &&\n          $util.isInteger(message.id.high)\n        )\n      )\n        return 'id: integer|Long expected'\n    if (message.name != null && message.hasOwnProperty('name'))\n      if (!$util.isString(message.name)) return 'name: string expected'\n    if (message.text != null && message.hasOwnProperty('text'))\n      if (!$util.isString(message.text)) return 'text: string expected'\n    if (message.glyphs != null && message.hasOwnProperty('glyphs')) {\n      if (!$util.isObject(message.glyphs)) return 'glyphs: object expected'\n      let key = Object.keys(message.glyphs)\n      for (let i = 0; i < key.length; ++i) {\n        let error = $root.GlyphFont.verify(message.glyphs[key[i]])\n        if (error) return 'glyphs.' + error\n      }\n    }\n    if (message.glyphImages != null && message.hasOwnProperty('glyphImages')) {\n      if (!Array.isArray(message.glyphImages))\n        return 'glyphImages: array expected'\n      for (let i = 0; i < message.glyphImages.length; ++i) {\n        let error = $root.GlyphImage.verify(message.glyphImages[i])\n        if (error) return 'glyphImages.' + error\n      }\n    }\n    if (message.style != null && message.hasOwnProperty('style')) {\n      let error = $root.Style.verify(message.style)\n      if (error) return 'style.' + error\n    }\n    if (message.layout != null && message.hasOwnProperty('layout')) {\n      let error = $root.Layout.verify(message.layout)\n      if (error) return 'layout.' + error\n    }\n    if (\n      message.globalAdjustMetric != null &&\n      message.hasOwnProperty('globalAdjustMetric')\n    ) {\n      let error = $root.Metric.verify(message.globalAdjustMetric)\n      if (error) return 'globalAdjustMetric.' + error\n    }\n    if (message.ui != null && message.hasOwnProperty('ui')) {\n      let error = $root.Ui.verify(message.ui)\n      if (error) return 'ui.' + error\n    }\n    return null\n  }\n\n  /**\n   * Creates a Project message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Project\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Project} Project\n   */\n  Project.fromObject = function fromObject(object) {\n    if (object instanceof $root.Project) return object\n    let message = new $root.Project()\n    if (object.id != null)\n      if ($util.Long)\n        (message.id = $util.Long.fromValue(object.id)).unsigned = false\n      else if (typeof object.id === 'string')\n        message.id = parseInt(object.id, 10)\n      else if (typeof object.id === 'number') message.id = object.id\n      else if (typeof object.id === 'object')\n        message.id = new $util.LongBits(\n          object.id.low >>> 0,\n          object.id.high >>> 0,\n        ).toNumber()\n    if (object.name != null) message.name = String(object.name)\n    if (object.text != null) message.text = String(object.text)\n    if (object.glyphs) {\n      if (typeof object.glyphs !== 'object')\n        throw TypeError('.Project.glyphs: object expected')\n      message.glyphs = {}\n      for (let keys = Object.keys(object.glyphs), i = 0; i < keys.length; ++i) {\n        if (typeof object.glyphs[keys[i]] !== 'object')\n          throw TypeError('.Project.glyphs: object expected')\n        message.glyphs[keys[i]] = $root.GlyphFont.fromObject(\n          object.glyphs[keys[i]],\n        )\n      }\n    }\n    if (object.glyphImages) {\n      if (!Array.isArray(object.glyphImages))\n        throw TypeError('.Project.glyphImages: array expected')\n      message.glyphImages = []\n      for (let i = 0; i < object.glyphImages.length; ++i) {\n        if (typeof object.glyphImages[i] !== 'object')\n          throw TypeError('.Project.glyphImages: object expected')\n        message.glyphImages[i] = $root.GlyphImage.fromObject(\n          object.glyphImages[i],\n        )\n      }\n    }\n    if (object.style != null) {\n      if (typeof object.style !== 'object')\n        throw TypeError('.Project.style: object expected')\n      message.style = $root.Style.fromObject(object.style)\n    }\n    if (object.layout != null) {\n      if (typeof object.layout !== 'object')\n        throw TypeError('.Project.layout: object expected')\n      message.layout = $root.Layout.fromObject(object.layout)\n    }\n    if (object.globalAdjustMetric != null) {\n      if (typeof object.globalAdjustMetric !== 'object')\n        throw TypeError('.Project.globalAdjustMetric: object expected')\n      message.globalAdjustMetric = $root.Metric.fromObject(\n        object.globalAdjustMetric,\n      )\n    }\n    if (object.ui != null) {\n      if (typeof object.ui !== 'object')\n        throw TypeError('.Project.ui: object expected')\n      message.ui = $root.Ui.fromObject(object.ui)\n    }\n    return message\n  }\n\n  /**\n   * Creates a plain object from a Project message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Project\n   * @static\n   * @param {Project} message Project\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n  Project.toObject = function toObject(message, options) {\n    if (!options) options = {}\n    let object = {}\n    if (options.arrays || options.defaults) object.glyphImages = []\n    if (options.objects || options.defaults) object.glyphs = {}\n    if (options.defaults) {\n      if ($util.Long) {\n        let long = new $util.Long(0, 0, false)\n        object.id =\n          options.longs === String\n            ? long.toString()\n            : options.longs === Number\n            ? long.toNumber()\n            : long\n      } else object.id = options.longs === String ? '0' : 0\n      object.name = ''\n      object.text = ''\n      object.style = null\n      object.layout = null\n      object.globalAdjustMetric = null\n      object.ui = null\n    }\n    if (message.id != null && message.hasOwnProperty('id'))\n      if (typeof message.id === 'number')\n        object.id = options.longs === String ? String(message.id) : message.id\n      else\n        object.id =\n          options.longs === String\n            ? $util.Long.prototype.toString.call(message.id)\n            : options.longs === Number\n            ? new $util.LongBits(\n                message.id.low >>> 0,\n                message.id.high >>> 0,\n              ).toNumber()\n            : message.id\n    if (message.name != null && message.hasOwnProperty('name'))\n      object.name = message.name\n    if (message.text != null && message.hasOwnProperty('text'))\n      object.text = message.text\n    let keys2\n    if (message.glyphs && (keys2 = Object.keys(message.glyphs)).length) {\n      object.glyphs = {}\n      for (let j = 0; j < keys2.length; ++j)\n        object.glyphs[keys2[j]] = $root.GlyphFont.toObject(\n          message.glyphs[keys2[j]],\n          options,\n        )\n    }\n    if (message.glyphImages && message.glyphImages.length) {\n      object.glyphImages = []\n      for (let j = 0; j < message.glyphImages.length; ++j)\n        object.glyphImages[j] = $root.GlyphImage.toObject(\n          message.glyphImages[j],\n          options,\n        )\n    }\n    if (message.style != null && message.hasOwnProperty('style'))\n      object.style = $root.Style.toObject(message.style, options)\n    if (message.layout != null && message.hasOwnProperty('layout'))\n      object.layout = $root.Layout.toObject(message.layout, options)\n    if (\n      message.globalAdjustMetric != null &&\n      message.hasOwnProperty('globalAdjustMetric')\n    )\n      object.globalAdjustMetric = $root.Metric.toObject(\n        message.globalAdjustMetric,\n        options,\n      )\n    if (message.ui != null && message.hasOwnProperty('ui'))\n      object.ui = $root.Ui.toObject(message.ui, options)\n    return object\n  }\n\n  /**\n   * Converts this Project to JSON.\n   * @function toJSON\n   * @memberof Project\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n  Project.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n  }\n\n  return Project\n})())\n\nexport { $root as default }\n","import * as proto1000000 from './1.0.0'\nimport * as proto1000001 from './1.0.1'\nimport * as proto1000002 from './1.0.2'\nimport * as proto1000003 from './1.0.3'\n\nexport interface OldProto {\n  1000000: typeof proto1000000\n  1000001: typeof proto1000001\n  1000002: typeof proto1000002\n  1000003: typeof proto1000003\n}\n\nexport const oldProto: OldProto = {\n  1000000: proto1000000,\n  1000001: proto1000001,\n  1000002: proto1000002,\n  1000003: proto1000003,\n}\n\nexport { default as encodeProject } from './encodeProject'\nexport { default as toOriginBuffer } from './toOriginBuffer'\nexport * from './project'\nexport { default } from './project'\n","import { IProject, oldProto, OldProto } from './proto/index'\n\ntype OldKey = keyof OldProto\n\nconst verions: OldKey[] = Object.keys(oldProto)\n  .map((verion) => `${Number(verion)}` as unknown as OldKey)\n  .sort()\n\nfunction updateOldProject(project: IProject, version: number): IProject {\n  verions.forEach((v) => {\n    if (version <= v && oldProto[v]) oldProto[v].updateToNext(project)\n  })\n  return project\n}\n\nexport default updateOldProject\n","import { Project } from 'src/store'\nimport { encodeProject } from './proto'\n\nimport prefix from './prefix'\n\nexport default function encode(project: Project): Uint8Array {\n  const perfixBuffer = prefix()\n  const projectBuffer = encodeProject(project)\n\n  const buffer = new Uint8Array(\n    perfixBuffer.byteLength + projectBuffer.byteLength,\n  )\n\n  buffer.set(perfixBuffer, 0)\n  buffer.set(projectBuffer, perfixBuffer.byteLength)\n\n  return buffer\n}\n","import { Project } from 'src/store'\nimport { Project as ProjectProto, IProject } from './project'\n\nexport default function saveProject(project: Project): Uint8Array {\n  // font\n  if (project.style.font.fonts && project.style.font.fonts.length) {\n    project.style.font.fonts.forEach(\n      (fontResource) => (fontResource.font = new Uint8Array(fontResource.font)),\n    )\n  }\n\n  // images\n  project.glyphImages.forEach((glyphImage) => {\n    if (glyphImage.buffer) glyphImage.buffer = new Uint8Array(glyphImage.buffer)\n  })\n\n  // fill\n  if (project.style.fill.patternTexture.buffer) {\n    project.style.fill.patternTexture.buffer = new Uint8Array(\n      project.style.fill.patternTexture.buffer,\n    )\n  }\n\n  // stroke\n  if (project.style.stroke.patternTexture.buffer) {\n    project.style.stroke.patternTexture.buffer = new Uint8Array(\n      project.style.stroke.patternTexture.buffer,\n    )\n  }\n\n  return ProjectProto.encode(\n    ProjectProto.create(project as unknown as IProject),\n  ).finish()\n}\n","import { ConversionFileItem } from '../type'\nimport check from './check'\nimport decode from './decode'\n\nconst sbfFile: ConversionFileItem = {\n  ext: '.sbf',\n  check,\n  decode,\n}\n\nexport { default as encode } from './encode'\nexport default sbfFile\n","import { DecodeProjectFunction } from '../type'\nimport {\n  Project as ProjectProto,\n  oldProto,\n  OldProto,\n  toOriginBuffer,\n} from './proto/index'\nimport prefix from './prefix'\nimport getVersion from './getVersion'\nimport updateOldProject from './updateOldProject'\n\nconst decode: DecodeProjectFunction = (buffer) => {\n  if (!(buffer instanceof ArrayBuffer)) throw new Error('unknow file')\n\n  const version = getVersion(buffer)\n\n  if (version === 0) throw new Error('unknow file')\n\n  const perfixBuffer = prefix()\n  const u8 = new Uint8Array(buffer)\n  const filePrefix = u8.slice(0, perfixBuffer.byteLength)\n\n  const decodeProto =\n    oldProto[version as keyof OldProto]?.Project || ProjectProto\n\n  const project = decodeProto.decode(u8.slice(filePrefix.byteLength))\n\n  return toOriginBuffer(updateOldProject(project, version))\n}\n\nexport default decode\n","import { Project } from 'src/store'\nimport { IProject } from './project'\n\nexport default function toOriginBuffer(protoProject: IProject): Project {\n  const project = protoProject as unknown as Project\n  const map = new Map()\n\n  // font\n  if (protoProject?.style?.font?.fonts) {\n    protoProject.style.font.fonts.forEach((fontResource, idx) => {\n      if (fontResource.font)\n        project.style.font.fonts[idx].font = fontResource.font.slice().buffer\n    })\n  }\n\n  // images\n  if (protoProject?.glyphImages) {\n    protoProject.glyphImages.forEach((glyphImage, idx) => {\n      if (glyphImage.buffer) {\n        project.glyphImages[idx].buffer = glyphImage.buffer.slice().buffer\n      }\n      if (glyphImage.kerning) {\n        const imgKerning = new Map()\n        Object.keys(glyphImage.kerning).forEach((key) => {\n          if (glyphImage && glyphImage.kerning && glyphImage.kerning[key])\n            imgKerning.set(key, glyphImage.kerning[key] || 0)\n        })\n        glyphImage.kerning = imgKerning as {}\n      }\n    })\n  }\n\n  if (protoProject?.glyphs) {\n    Object.keys(protoProject.glyphs).forEach((k) => {\n      if (protoProject && protoProject.glyphs && protoProject.glyphs[k]) {\n        const gl = protoProject.glyphs[k]\n        const glyphKerning = new Map()\n        if (gl && gl.kerning) {\n          Object.keys(gl.kerning).forEach((key) => {\n            if (gl.kerning) glyphKerning.set(key, gl.kerning[key] || 0)\n          })\n        }\n        map.set(k, { ...gl, kerning: glyphKerning })\n      }\n    })\n    project.glyphs = map\n  }\n\n  // fill\n  if (protoProject?.style?.fill?.patternTexture?.buffer) {\n    project.style.fill.patternTexture.buffer =\n      protoProject.style.fill.patternTexture.buffer.slice().buffer\n  }\n\n  // stroke\n  if (protoProject?.style?.stroke?.patternTexture?.buffer) {\n    project.style.stroke.patternTexture.buffer =\n      protoProject.style.stroke.patternTexture.buffer.slice().buffer\n  }\n\n  return project\n}\n","import Ajv, { JTDSchemaType } from 'ajv/dist/jtd'\nimport glow, { GlowData } from './glow'\nimport fill, { FillData } from './fill'\nimport settings, { SettingsData } from './settings'\nimport shadow, { ShadowData } from './shadow'\nimport stroke, { StrokeData } from './stroke'\nimport background, { BackgroundData } from './background'\nimport bevel, { BevelData } from './bevel'\nimport glyphs, { GlyphsData } from './glyphs'\nimport font, { FontData } from './font'\n\nconst ajv = new Ajv()\n\nexport interface LitteraData {\n  glow: GlowData\n  fill: FillData\n  settings: SettingsData\n  shadow: ShadowData\n  stroke: StrokeData\n  background: BackgroundData\n  bevel: BevelData\n  glyphs: GlyphsData\n  font: FontData\n  fallbackfont?: string\n}\n\nconst schema: JTDSchemaType<LitteraData> = {\n  properties: {\n    glow,\n    fill,\n    settings,\n    shadow,\n    stroke,\n    background,\n    bevel,\n    glyphs,\n    font,\n  },\n  optionalProperties: {\n    fallbackfont: { type: 'string' },\n  },\n}\n\nexport * from './glow'\nexport * from './fill'\nexport * from './settings'\nexport * from './shadow'\nexport * from './stroke'\nexport * from './background'\nexport * from './bevel'\nexport * from './glyphs'\nexport * from './font'\n\nexport const validate = ajv.compile(schema)\n\nexport default validate\n","import { JTDSchemaType } from 'ajv/dist/jtd'\n\nexport interface GlowData {\n  quality: number\n  colors: number[]\n  glowEnabled: boolean\n  alphas: number[]\n  ratios: number[]\n  blurX: number\n  angle: number\n  blurY: number\n  strength: number\n  distance: number\n}\n\nconst glow: JTDSchemaType<GlowData> = {\n  properties: {\n    quality: { type: 'float32' },\n    colors: { elements: { type: 'float32' } },\n    glowEnabled: { type: 'boolean' },\n    alphas: { elements: { type: 'float32' } },\n    ratios: { elements: { type: 'float32' } },\n    blurX: { type: 'float32' },\n    angle: { type: 'float32' },\n    blurY: { type: 'float32' },\n    strength: { type: 'float32' },\n    distance: { type: 'float32' },\n  },\n}\n\nexport default glow\n","import { JTDSchemaType } from 'ajv/dist/jtd'\n\nexport interface FillData {\n  gradientAlphas: number[]\n  yOffset: number\n  gradientType: 'linear' | 'radial'\n  gradientRotation: number\n  fillType: 'gradientFill' | 'textureFill'\n  textureScale: number\n  distanceFieldEnabled: boolean\n  distanceFieldColor: number\n  gradientColors: number[]\n  distanceFieldDownscale: number\n  distanceFieldSpread: number\n  distanceFieldType: 'Type 1' | 'Type 2'\n  gradientRatios: number[]\n  xOffset: number\n  texture?: string\n}\n\nconst fill: JTDSchemaType<FillData> = {\n  properties: {\n    gradientAlphas: { elements: { type: 'float32' } },\n    yOffset: { type: 'float32' },\n    gradientType: { enum: ['linear', 'radial'] },\n    gradientRotation: { type: 'float32' },\n    fillType: { enum: ['gradientFill', 'textureFill'] },\n    textureScale: { type: 'float32' },\n    distanceFieldEnabled: { type: 'boolean' },\n    distanceFieldColor: { type: 'float32' },\n    gradientColors: { elements: { type: 'float32' } },\n    distanceFieldDownscale: { type: 'float32' },\n    distanceFieldSpread: { type: 'float32' },\n    distanceFieldType: { enum: ['Type 1', 'Type 2'] },\n    gradientRatios: { elements: { type: 'float32' } },\n    xOffset: { type: 'float32' },\n  },\n  optionalProperties: {\n    texture: { type: 'string' },\n  },\n}\n\nexport default fill\n","import { JTDSchemaType } from 'ajv/dist/jtd'\n\nexport interface SettingsData {\n  postfixes: string\n  filename: string\n  scalings: string\n}\n\nconst settings: JTDSchemaType<SettingsData> = {\n  properties: {\n    postfixes: { type: 'string' },\n    filename: { type: 'string' },\n    scalings: { type: 'string' },\n  },\n}\n\nexport default settings\n","import { JTDSchemaType } from 'ajv/dist/jtd'\n\nexport interface ShadowData {\n  quality: number\n  color: number\n  strength: number\n  blurX: number\n  angle: number\n  blurY: number\n  shadowEnabled: boolean\n  alpha: number\n  distance: number\n}\n\nconst shadow: JTDSchemaType<ShadowData> = {\n  properties: {\n    quality: { type: 'float32' },\n    color: { type: 'float32' },\n    strength: { type: 'float32' },\n    blurX: { type: 'float32' },\n    angle: { type: 'float32' },\n    blurY: { type: 'float32' },\n    shadowEnabled: { type: 'boolean' },\n    alpha: { type: 'float32' },\n    distance: { type: 'float32' },\n  },\n}\n\nexport default shadow\n","import { JTDSchemaType } from 'ajv/dist/jtd'\n\nexport interface StrokeData {\n  gradientAlphas: number[]\n  yOffset: number\n  gradientType: 'linear' | 'radial'\n  gradientRotation: number\n  fillType: 'gradientFill' | 'textureFill'\n  pixelHinting: boolean\n  textureScale: number\n  gradientColors: number[]\n  strokeEnabled: boolean\n  miterLimit: number\n  jointStyle: 'miter' | 'bevel' | 'round'\n  size: number\n  gradientRatios: number[]\n  xOffset: number\n  texture?: string\n}\n\nconst stroke: JTDSchemaType<StrokeData> = {\n  properties: {\n    gradientAlphas: { elements: { type: 'float32' } },\n    yOffset: { type: 'float32' },\n    gradientType: { enum: ['linear', 'radial'] },\n    gradientRotation: { type: 'float32' },\n    fillType: { enum: ['gradientFill', 'textureFill'] },\n    pixelHinting: { type: 'boolean' },\n    textureScale: { type: 'float32' },\n    gradientColors: { elements: { type: 'float32' } },\n    strokeEnabled: { type: 'boolean' },\n    miterLimit: { type: 'float32' },\n    jointStyle: { enum: ['miter', 'bevel', 'round'] },\n    size: { type: 'float32' },\n    gradientRatios: { elements: { type: 'float32' } },\n    xOffset: { type: 'float32' },\n  },\n  optionalProperties: {\n    texture: { type: 'string' },\n  },\n}\n\nexport default stroke\n","import { JTDSchemaType } from 'ajv/dist/jtd'\n\nexport interface BackgroundData {\n  color: number\n  alpha: number\n}\n\nconst background: JTDSchemaType<BackgroundData> = {\n  properties: {\n    color: { type: 'float32' },\n    alpha: { type: 'float32' },\n  },\n}\n\nexport default background\n","import { JTDSchemaType } from 'ajv/dist/jtd'\n\nexport interface BevelData {\n  bevelEnabled: boolean\n  highlightColor: number\n  highlightAlpha: number\n  quality: number\n  angle: number\n  shadowColor: number\n  shadowAlpha: number\n  blurX: number\n  blurY: number\n  type: 'inner' | 'outer' | 'full'\n  strength: number\n  distance: number\n}\n\nconst bevel: JTDSchemaType<BevelData> = {\n  properties: {\n    bevelEnabled: { type: 'boolean' },\n    highlightColor: { type: 'float32' },\n    highlightAlpha: { type: 'float32' },\n    quality: { type: 'float32' },\n    angle: { type: 'float32' },\n    shadowColor: { type: 'float32' },\n    shadowAlpha: { type: 'float32' },\n    blurX: { type: 'float32' },\n    blurY: { type: 'float32' },\n    type: { enum: ['inner', 'outer', 'full'] },\n    strength: { type: 'float32' },\n    distance: { type: 'float32' },\n  },\n}\n\nexport default bevel\n","import { JTDSchemaType } from 'ajv/dist/jtd'\n\nexport interface GlyphsData {\n  glyphs: string\n  powerOfTwo: boolean\n  canvasHeight: string\n  padding: number\n  packMethod: number\n  canvasWidth: string\n  roundValues: boolean\n  descriptionFormat: number\n}\n\nconst glyphs: JTDSchemaType<GlyphsData> = {\n  properties: {\n    glyphs: { type: 'string' },\n    powerOfTwo: { type: 'boolean' },\n    canvasHeight: { type: 'string' },\n    padding: { type: 'float32' },\n    packMethod: { type: 'float32' },\n    canvasWidth: { type: 'string' },\n    roundValues: { type: 'boolean' },\n    descriptionFormat: { type: 'float32' },\n  },\n}\n\nexport default glyphs\n","import { JTDSchemaType } from 'ajv/dist/jtd'\n\nexport interface FontData {\n  size: number\n  data?: string\n  spacing: number\n}\n\nconst font: JTDSchemaType<FontData> = {\n  properties: {\n    size: { type: 'float32' },\n    spacing: { type: 'float32' },\n  },\n  optionalProperties: {\n    data: { type: 'string' },\n  },\n}\n\nexport default font\n","import * as Sentry from '@sentry/react'\nimport validate from './schema'\nimport { CheckFunction } from '../type'\n\nconst check: CheckFunction = (litteraStr) => {\n  let litteraData\n\n  if (typeof litteraStr === 'string') {\n    try {\n      litteraData = JSON.parse(litteraStr)\n    } catch (e) {\n      return false\n    }\n  }\n\n  if (typeof litteraData !== 'object') return false\n\n  const isLittera = validate(litteraData)\n\n  if (!isLittera) {\n    if (process.env.NODE_ENV === 'development')\n      console.log(isLittera, validate.errors)\n\n    validate.errors?.forEach((item) => {\n      Sentry.addBreadcrumb({\n        category: 'littera',\n        message: 'Littera validate error',\n        level: Sentry.Severity.Info,\n        data: item,\n      })\n    })\n    Sentry.captureMessage('Littera validate error')\n  }\n\n  return isLittera\n}\n\nexport default check\n","import Color from 'color'\nimport {\n  Font,\n  Style,\n  Layout,\n  Project,\n  FillType,\n  Gradient,\n  GlyphFont,\n  FontResource,\n  GradientType,\n  PatternTexture,\n  FontStyleConfig,\n  ShadowStyleConfig,\n  StrokeStyleConfig,\n} from 'src/store'\nimport base64ToArrayBuffer from 'src/utils/base64ToArrayBuffer'\nimport { DecodeProjectFunction } from '../type'\nimport { LitteraData, FillData, StrokeData } from './schema'\nimport check from './check'\n\nfunction transformFill(litteraFill: FillData | StrokeData): FontStyleConfig {\n  const fill = {} as FontStyleConfig\n  if (litteraFill.fillType === 'gradientFill') {\n    // solid color\n    if (litteraFill.gradientColors.length < 2) {\n      fill.type = FillType.SOLID\n      fill.color = Color(litteraFill.gradientColors[0])\n        .alpha(litteraFill.gradientAlphas[0])\n        .hex()\n    } else {\n      fill.type = FillType.GRADIENT\n      fill.gradient = {} as Gradient\n      fill.gradient.palette = []\n      fill.gradient.type =\n        litteraFill.gradientType === 'radial'\n          ? GradientType.RADIAL\n          : GradientType.LINEAR\n\n      litteraFill.gradientColors.forEach((color, idx) => {\n        fill.gradient.palette.push({\n          id: idx + 1,\n          color: Color(color).alpha(litteraFill.gradientAlphas[idx]).hex(),\n          offset: litteraFill.gradientRatios[idx] / 255,\n        })\n      })\n      fill.gradient.angle = litteraFill.gradientRotation\n    }\n  } else {\n    fill.patternTexture = {\n      scale: litteraFill.textureScale,\n    } as PatternTexture\n\n    if (litteraFill.texture) {\n      fill.patternTexture.buffer = base64ToArrayBuffer(litteraFill.texture)\n    }\n  }\n\n  return fill\n}\n\nconst decode: DecodeProjectFunction = (litteraData) => {\n  if (!check(litteraData)) throw new Error('unknow file')\n\n  if (typeof litteraData === 'string') litteraData = JSON.parse(litteraData)\n\n  const data = litteraData as LitteraData\n  const project: Partial<Project> = {}\n\n  project.text = data.glyphs.glyphs\n\n  project.glyphs = new Map()\n\n  data.glyphs.glyphs\n    .split('')\n    .forEach((letter) => project.glyphs?.set(letter, { letter } as GlyphFont))\n\n  /**\n   * style\n   */\n\n  /**\n   * style.font\n   */\n  //#region style.font\n  const font = {} as Font\n  font.size = data.font.size\n\n  if (data.font.data) {\n    font.fonts = []\n    font.fonts.push({\n      font: base64ToArrayBuffer(data.font.data),\n    } as FontResource)\n    if (data.fallbackfont) {\n      font.fonts.push({\n        font: base64ToArrayBuffer(data.fallbackfont),\n      } as FontResource)\n    }\n  }\n  //#endregion\n\n  /**\n   * style.fill\n   */\n  //#region style.fill\n  const fill = transformFill(data.fill) as FontStyleConfig\n  //#endregion\n\n  /**\n   * style.stroke\n   */\n  //#region style.stroke\n  const stroke = {} as StrokeStyleConfig\n  stroke.width = data.stroke.size\n  stroke.lineJoin = data.stroke.jointStyle\n  Object.assign(stroke, transformFill(data.stroke))\n  //#endregion\n\n  /**\n   * style.shadow\n   */\n  //#region style.shadow\n  const shadow = {} as ShadowStyleConfig\n  shadow.color = Color(data.shadow.color).alpha(data.shadow.alpha).hex()\n  shadow.blur = data.shadow.quality + data.shadow.blurX - data.shadow.strength\n  shadow.offsetX = Math.round(\n    Math.cos((data.shadow.angle * Math.PI) / 180) * data.shadow.distance,\n  )\n  shadow.offsetY = Math.round(\n    Math.sin((data.shadow.angle * Math.PI) / 180) * data.shadow.distance,\n  )\n  //#endregion\n\n  project.style = {\n    font,\n    fill,\n    useStroke: data.stroke.strokeEnabled,\n    stroke,\n    useShadow: data.shadow.shadowEnabled,\n    shadow,\n  } as Style\n\n  /**\n   * layout\n   */\n  project.layout = {} as Layout\n  project.layout.padding = data.glyphs.padding\n  if (!isNaN(Number(data.glyphs.canvasWidth))) {\n    project.layout.width = Number(data.glyphs.canvasWidth)\n  }\n  if (!isNaN(Number(data.glyphs.canvasHeight))) {\n    project.layout.width = Number(data.glyphs.canvasHeight)\n  }\n  if (project.layout.width && project.layout.height) {\n    project.layout.auto = false\n    project.layout.fixedSize = true\n  }\n\n  return project\n}\n\nexport default decode\n","import { ConversionFileItem } from './type'\nimport sbf from './sbf'\nimport littera from './littera'\n\nconst conversionList: ConversionFileItem[] = [sbf, littera]\n\nexport default conversionList\n","import { ConversionFileItem } from '../type'\nimport check from './check'\nimport decode from './decode'\n\nconst litteraFile: ConversionFileItem = {\n  ext: '.ltr',\n  check,\n  decode,\n}\n\nexport default litteraFile\n","import conversionList from './types'\nexport { encode } from './types/sbf'\n\nfunction conversion(inputFile: unknown) {\n  const conversion = conversionList.find((item) => item.check(inputFile))\n  if (!conversion) throw new Error('unknow file')\n  return conversion.decode(inputFile)\n}\n\nexport default conversion\n","import React, { FunctionComponent, useRef } from 'react'\nimport { observer } from 'mobx-react'\nimport { useSnackbar } from 'notistack'\nimport * as Sentry from '@sentry/react'\nimport Button from '@material-ui/core/Button'\nimport { useWorkspace } from 'src/store/hooks'\n\nimport readFile from 'src/utils/readFile'\nimport conversion from 'src/file/conversion'\n\ninterface ButtonOpenProps {\n  className?: string\n}\n\nconst ButtonOpen: FunctionComponent<ButtonOpenProps> = (\n  props: ButtonOpenProps,\n) => {\n  const { className } = props\n  const { enqueueSnackbar } = useSnackbar()\n\n  const worckSpace = useWorkspace()\n  const labelRef = useRef<HTMLLabelElement>(null)\n  const { addProject } = worckSpace\n\n  const handleLoad = (e: React.ChangeEvent<HTMLInputElement>): void => {\n    if (!e.target?.files || !e.target.files[0]) return\n    const file = e.target.files[0]\n    const isText = /\\.ltr$/.test(file.name)\n\n    readFile(file, isText).then((buffer) => {\n      try {\n        const project = conversion(buffer)\n        if (!project.name) project.name = file.name\n        addProject(project)\n      } catch (e) {\n        console.log(e)\n        Sentry.captureException(e)\n        enqueueSnackbar((e as Error).toString(), { variant: 'error' })\n      }\n    })\n  }\n\n  return (\n    <Button\n      className={className}\n      title='Open Project (⌘ + O)'\n      component='label'\n      ref={labelRef}\n    >\n      Open\n      <input type='file' onChange={handleLoad} accept='.sbf,.ltr' hidden />\n    </Button>\n  )\n}\n\nexport default observer(ButtonOpen)\n","import React, { useEffect, FunctionComponent, useCallback } from 'react'\nimport { toJS } from 'mobx'\nimport hotkeys from 'hotkeys-js'\nimport { saveAs } from 'file-saver'\nimport { observer } from 'mobx-react'\nimport { useSnackbar } from 'notistack'\nimport * as Sentry from '@sentry/react'\nimport Button from '@material-ui/core/Button'\n\nimport { encode } from 'src/file/conversion'\nimport { useWorkspace } from 'src/store/hooks'\n\ninterface ButtonSaveProps {\n  className?: string\n}\n\nconst ButtonSave: FunctionComponent<ButtonSaveProps> = (\n  props: ButtonSaveProps,\n) => {\n  const { className } = props\n\n  const { enqueueSnackbar } = useSnackbar()\n  const worckSpace = useWorkspace()\n  const { currentProject: project } = worckSpace\n\n  const handleSaveProject = useCallback(\n    (e: { preventDefault(): void }) => {\n      e.preventDefault()\n      try {\n        const buffer = encode(toJS(project))\n        saveAs(new Blob([buffer]), `${project.name}.sbf`)\n      } catch (e) {\n        Sentry.captureException(e)\n        enqueueSnackbar((e as Error).message)\n      }\n    },\n    [enqueueSnackbar, project],\n  )\n\n  useEffect(() => {\n    hotkeys.unbind('ctrl+s')\n    hotkeys('ctrl+s', handleSaveProject)\n    return () => {\n      hotkeys.unbind('ctrl+s')\n    }\n  }, [handleSaveProject])\n\n  return (\n    <Button\n      className={className}\n      title='Save Project (⌘ + S)'\n      onClick={handleSaveProject}\n    >\n      Save\n    </Button>\n  )\n}\n\nexport default observer(ButtonSave)\n","export default function formatStr(\n  str: string,\n  obj: Record<string, unknown>,\n): string {\n  return str.replace(/\\$\\w+\\$/gi, (matchs: string): string => {\n    const returns = obj[matchs.replace(/\\$/g, '')]\n    return `${returns}` === 'undefined' ? '' : `${returns}`\n  })\n}\n","import formatStr from 'src/utils/formatStr'\nimport { Output, FontToString } from '../type'\n\nconst TEMP_INFO = `info face=\"$face$\" size=$size$ bold=$bold$ italic=$italic$ charset=$charset$ unicode=$unicode$ stretchH=$stretchH$ smooth=$smooth$ aa=$aa$ padding=$padding$ spacing=$spacing$\\n`\nconst TEMP_COMMON = `common lineHeight=$lineHeight$ base=$base$ scaleW=$scaleW$ scaleH=$scaleH$ pages=$pages$ packed=$packed$\\n`\nconst TEMP_PAGE = `page id=$id$ file=\"$file$\"\\n`\nconst TEMP_CHARS = `chars count=$count$\\n`\nconst TEMP_CHAR = `char id=$id$ x=$x$ y=$y$ width=$width$ height=$height$ xoffset=$xoffset$ yoffset=$yoffset$ xadvance=$xadvance$ page=$page$ chnl=$chnl$\\n`\nconst TEMP_KERNINGS = `kernings count=$count$\\n`\nconst TEMP_KERNING = `kerning first=$first$ second=$second$ amount=$amount$\\n`\n\nconst type = 'TEXT'\n\nconst exts = ['fnt', 'txt']\n\nconst getString: FontToString = (bmfont) => {\n  const { info, common, pages, chars, kernings } = bmfont\n\n  let str = ''\n\n  str += formatStr(TEMP_INFO, { ...info, charset: info.charset || '\"\"' })\n\n  str += formatStr(TEMP_COMMON, common)\n\n  pages.forEach((p) => {\n    str += formatStr(TEMP_PAGE, p)\n  })\n\n  str += formatStr(TEMP_CHARS, chars)\n\n  chars.list.forEach((char) => {\n    str += formatStr(TEMP_CHAR, char)\n  })\n\n  if (kernings.count) {\n    str += formatStr(TEMP_KERNINGS, kernings)\n\n    kernings.list.forEach((kerning) => {\n      str += formatStr(TEMP_KERNING, kerning)\n    })\n  }\n\n  return str\n}\n\nconst outputConfig: Output = { type, exts, getString }\n\nexport default outputConfig\n","import formatStr from 'src/utils/formatStr'\nimport { Output, FontToString } from '../type'\n\nconst TEMP_INFO = `<info face=\"$face$\" size=\"$size$\" bold=\"$bold$\" italic=\"$italic$\" charset=\"$charset$\" unicode=\"$unicode$\" stretchH=\"$stretchH$\" smooth=\"$smooth$\" aa=\"$aa$\" padding=\"$padding$\" spacing=\"$spacing$\" />`\nconst TEMP_COMMON = `<common lineHeight=\"$lineHeight$\" base=\"$base$\" scaleW=\"$scaleW$\" scaleH=\"$scaleH$\" pages=\"$pages$\" packed=\"$packed$\" />`\nconst TEMP_PAGE = `<page id=\"$id$\" file=\"$file$\" />`\nconst TEMP_CHARS = `<chars count=\"$count$\" />`\nconst TEMP_CHAR = `<char id=\"$id$\" x=\"$x$\" y=\"$y$\" width=\"$width$\" height=\"$height$\" xoffset=\"$xoffset$\" yoffset=\"$yoffset$\" xadvance=\"$xadvance$\" page=\"$page$\" chnl=\"$chnl$\" />`\nconst TEMP_KERNINGS = `<kernings count=\"$count$\" />`\nconst TEMP_KERNING = `<kerning first=\"$first$\" second=\"$second$\" amount=\"$amount$\" />`\n\nconst type = 'XML'\n\nconst exts = ['xml', 'fnt']\n\n// http://www.angelcode.com/products/bmfont/doc/file_format.html\nconst getString: FontToString = (bmfont) => {\n  const { info, common, pages, chars, kernings } = bmfont\n\n  const parser = new DOMParser()\n  const xmlDOM = document.implementation.createDocument('', 'font', null)\n\n  const infoDoc = parser.parseFromString(formatStr(TEMP_INFO, info), 'text/xml')\n  xmlDOM.documentElement.appendChild(infoDoc.childNodes[0])\n\n  const commonDoc = parser.parseFromString(\n    formatStr(TEMP_COMMON, common),\n    'text/xml',\n  )\n  xmlDOM.documentElement.appendChild(commonDoc.childNodes[0])\n\n  const pagesDoc = parser.parseFromString(\n    `<pages>${pages.map((p) => formatStr(TEMP_PAGE, p))}</pages>`,\n    'text/xml',\n  )\n  xmlDOM.documentElement.appendChild(pagesDoc.childNodes[0])\n\n  const charsDoc = parser.parseFromString(\n    formatStr(TEMP_CHARS, chars),\n    'text/xml',\n  )\n\n  chars.list.forEach((char) => {\n    const charDoc = parser.parseFromString(\n      formatStr(TEMP_CHAR, char),\n      'text/xml',\n    )\n    charsDoc.childNodes[0].appendChild(charDoc.childNodes[0])\n  })\n\n  xmlDOM.documentElement.appendChild(charsDoc.childNodes[0])\n\n  if (kernings.count) {\n    const kerningsDoc = parser.parseFromString(\n      formatStr(TEMP_KERNINGS, kernings),\n      'text/xml',\n    )\n\n    kernings.list.forEach((kerning) => {\n      const kerningDoc = parser.parseFromString(\n        formatStr(TEMP_KERNING, kerning),\n        'text/xml',\n      )\n      kerningsDoc.childNodes[0].appendChild(kerningDoc.childNodes[0])\n    })\n\n    xmlDOM.documentElement.appendChild(kerningsDoc.childNodes[0])\n  }\n\n  return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>${new XMLSerializer().serializeToString(\n    xmlDOM,\n  )}`\n}\n\nconst outputConfig: Output = { type, exts, getString }\n\nexport default outputConfig\n","import { Project } from 'src/store'\nimport {\n  BMFont,\n  BMFontInfo,\n  BMFontPage,\n  BMFontChars,\n  BMFontCommon,\n  BMFontKernings,\n} from './type'\n\n// http://www.angelcode.com/products/bmfont/doc/file_format.html\nexport default function toBmfInfo(project: Project, fontFamily = ''): BMFont {\n  const {\n    name,\n    style,\n    layout,\n    globalAdjustMetric,\n    glyphList,\n    ui: { width, height },\n  } = project\n  const { opentype, size } = style.font\n  let fontScale = 1\n  if (opentype) {\n    fontScale = (1 / opentype.unitsPerEm) * size\n  }\n  const info: BMFontInfo = {\n    face: fontFamily || style.font.mainFamily,\n    size: style.font.size,\n    bold: 0,\n    italic: 0,\n    charset: '',\n    unicode: 1,\n    stretchH: 100,\n    smooth: 1,\n    aa: 1,\n    padding: new Array(4).fill(layout.padding),\n    spacing: new Array(2).fill(layout.spacing),\n  }\n\n  const common: BMFontCommon = {\n    lineHeight: style.font.size,\n    base: Math.round(style.font.alphabetic - style.font.top),\n    scaleW: width,\n    scaleH: height,\n    pages: 1,\n    packed: 0,\n  }\n\n  const pages: BMFontPage[] = [\n    {\n      id: 0,\n      file: `${name}.png`,\n    },\n  ]\n\n  const chars: BMFontChars = {\n    count: glyphList.length,\n    list: [],\n  }\n\n  const kernings: BMFontKernings = {\n    count: 0,\n    list: [],\n  }\n\n  glyphList.forEach((glyph) => {\n    const isUnEmpty = !!(glyph.width && glyph.height)\n    const info = {\n      letter: glyph.letter,\n      id: glyph.letter.charCodeAt(0),\n      source: glyph.source,\n      x: glyph.x,\n      y: glyph.y,\n      width: isUnEmpty ? glyph.width + layout.padding * 2 : 0,\n      height: isUnEmpty ? glyph.height + layout.padding * 2 : 0,\n      xoffset:\n        globalAdjustMetric.xOffset +\n        glyph.adjustMetric.xOffset -\n        (isUnEmpty ? glyph.trimOffsetLeft : 0) -\n        (isUnEmpty ? layout.padding : 0),\n      yoffset:\n        globalAdjustMetric.yOffset +\n        glyph.adjustMetric.yOffset -\n        (isUnEmpty ? glyph.trimOffsetTop : 0) -\n        (isUnEmpty ? layout.padding : 0),\n      xadvance:\n        Math.ceil(glyph.fontWidth) +\n        globalAdjustMetric.xAdvance +\n        glyph.adjustMetric.xAdvance,\n      page: 0,\n      chnl: 15,\n    }\n\n    chars.list.push(info)\n\n    if (opentype) {\n      glyphList.forEach(({ letter }) => {\n        const amount = Math.round(\n          opentype.getKerningValue(\n            opentype.charToGlyphIndex(glyph.letter),\n            opentype.charToGlyphIndex(letter),\n          ) *\n            fontScale +\n            (glyph.kerning.get(letter) || 0),\n        )\n        if (amount) {\n          kernings.list.push({\n            first: glyph.letter.charCodeAt(0),\n            second: letter.charCodeAt(0),\n            amount,\n          })\n        }\n      })\n    } else {\n      glyph.kerning.forEach((amount, letter) => {\n        if (amount)\n          kernings.list.push({\n            first: glyph.letter.charCodeAt(0),\n            second: letter.charCodeAt(0),\n            amount,\n          })\n      })\n    }\n  })\n  kernings.count = kernings.list.length\n\n  chars.list.sort((a, b) => a.id - b.id)\n\n  return {\n    info,\n    common,\n    pages,\n    chars,\n    kernings,\n  }\n}\n","import { ConfigItem } from './type'\nimport text from './types/text'\nimport xml from './types/xml'\n\nconst list = [text, xml]\n\nexport const configList: ConfigItem[] = []\n\nlist.forEach(({ type, exts, getString }) => {\n  exts.forEach((ext) => {\n    configList.push({\n      id: type + ext,\n      ext,\n      type,\n      getString,\n    })\n  })\n})\n\nexport * from './type'\nexport * from './toBmfInfo'\nexport { default as toBmfInfo } from './toBmfInfo'\nexport { default as exportFile } from './exportFile'\nexport default configList\n","import React, {\n  useState,\n  useEffect,\n  useCallback,\n  FunctionComponent,\n} from 'react'\nimport hotkeys from 'hotkeys-js'\nimport { observer } from 'mobx-react'\nimport Box from '@material-ui/core/Box'\nimport Input from '@material-ui/core/Input'\nimport Button from '@material-ui/core/Button'\nimport Dialog from '@material-ui/core/Dialog'\nimport Select from '@material-ui/core/Select'\nimport MenuItem from '@material-ui/core/MenuItem'\nimport DialogTitle from '@material-ui/core/DialogTitle'\nimport DialogContent from '@material-ui/core/DialogContent'\nimport DialogActions from '@material-ui/core/DialogActions'\n\nimport { useProject } from 'src/store/hooks'\nimport { configList, exportFile } from 'src/file/export'\nimport GridInput from 'src/app/components/GridInput/GridInput'\n\ninterface ButtonExportProps {\n  className?: string\n}\n\nconst ButtonExport: FunctionComponent<ButtonExportProps> = (\n  props: ButtonExportProps,\n) => {\n  const { className } = props\n  const project = useProject()\n  const { setShowPreview } = project.ui\n  const [open, setOpen] = useState(false)\n  const [list] = useState(configList)\n  const [val, setVal] = useState(0)\n  const [fontName, setFontName] = useState(project.style.font.mainFamily)\n  const [fileName, setFileName] = useState(project.name)\n\n  const handleOpen = useCallback(() => {\n    setFontName(project.style.font.mainFamily)\n    setFileName(project.name)\n    setShowPreview(false)\n    setOpen(true)\n  }, [project.name, project.style.font.mainFamily, setShowPreview])\n\n  const handleClose = () => {\n    setOpen(false)\n  }\n\n  const handleChangeFontName = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setFontName(e.target.value)\n  }\n\n  const handleChangeFileName = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setFileName(e.target.value)\n  }\n\n  const handleChange = (\n    e: React.ChangeEvent<{\n      name?: string | undefined\n      value: unknown\n    }>,\n  ) => {\n    setVal(e.target.value as number)\n  }\n\n  const handleSave = useCallback(() => {\n    exportFile(project, list[val], fontName, fileName)\n    handleClose()\n  }, [fileName, fontName, list, project, val])\n\n  useEffect(() => {\n    hotkeys.unbind('ctrl+shift+s,command+shift+s')\n    hotkeys('ctrl+shift+s,command+shift+s', handleOpen)\n    return () => {\n      hotkeys.unbind('ctrl+shift+s,command+shift+s')\n    }\n  }, [handleOpen])\n\n  return (\n    <>\n      <Button\n        className={className}\n        title='Export BitmapFont (⌘⇧ + S)'\n        onClick={handleOpen}\n      >\n        Export\n      </Button>\n      <Dialog onClose={handleClose} open={open} fullWidth maxWidth='xs'>\n        <DialogTitle>Export Config</DialogTitle>\n        <DialogContent dividers>\n          <Box paddingX={2} marginY={4}>\n            <GridInput before='Font Name:' childrenWidth={6}>\n              <Input\n                fullWidth\n                type='text'\n                value={fontName}\n                placeholder={project.style.font.mainFamily}\n                onChange={handleChangeFontName}\n              />\n            </GridInput>\n          </Box>\n          <Box paddingX={2} marginY={4}>\n            <GridInput before='File Name:' after='.zip' childrenWidth={6}>\n              <Input\n                fullWidth\n                type='text'\n                value={fileName}\n                placeholder={project.name}\n                onChange={handleChangeFileName}\n              />\n            </GridInput>\n          </Box>\n          <Box paddingX={2} marginY={4}>\n            <GridInput before='Export Type:' childrenWidth={6}>\n              <Select\n                displayEmpty\n                value={val}\n                onChange={handleChange}\n                fullWidth\n              >\n                {list.map((item, idx) => (\n                  <MenuItem value={idx} key={item.id}>\n                    {`${fileName || project.name}.${\n                      item.ext\n                    } (BMFont ${item.type.toUpperCase()})`}\n                  </MenuItem>\n                ))}\n              </Select>\n            </GridInput>\n          </Box>\n        </DialogContent>\n        <DialogActions>\n          <Button autoFocus onClick={handleSave} color='default'>\n            Save\n          </Button>\n        </DialogActions>\n      </Dialog>\n    </>\n  )\n}\n\nexport default observer(ButtonExport)\n","import JSZip from 'jszip'\nimport { saveAs } from 'file-saver'\nimport { Project } from 'src/store'\nimport toBmfInfo from './toBmfInfo'\nimport { ConfigItem } from './type'\n\nexport default function exportFile(\n  project: Project,\n  config: ConfigItem,\n  fontName: string,\n  fileName: string,\n): void {\n  const zip = new JSZip()\n  const { packCanvas, name } = project\n  const bmfont = toBmfInfo(project, fontName)\n  const text = config.getString(bmfont)\n  const saveFileName = fileName || name\n\n  zip.file(`${saveFileName}.${config.ext}`, text)\n\n  if (packCanvas) {\n    packCanvas.toBlob((blob) => {\n      if (blob) zip.file(`${saveFileName}.png`, blob)\n      zip\n        .generateAsync({ type: 'blob' })\n        .then((content) => saveAs(content, `${saveFileName}.zip`))\n    })\n  }\n}\n","import React, { FunctionComponent } from 'react'\nimport Box from '@material-ui/core/Box'\nimport GitHubIcon from '@material-ui/icons/GitHub'\nimport IconButton from '@material-ui/core/IconButton'\nimport Typography from '@material-ui/core/Typography'\nimport { makeStyles, createStyles } from '@material-ui/core/styles'\n\nimport ButtonNew from './ButtonNew'\nimport ButtonOpen from './ButtonOpen'\nimport ButtonSave from './ButtonSave'\nimport ButtonExport from './ButtonExport'\n\nconst useStyles = makeStyles(({ zIndex, spacing }) =>\n  createStyles({\n    root: {\n      position: 'relative',\n      zIndex: zIndex.appBar,\n    },\n    appName: {\n      fontSize: '1.25rem',\n      fontWeight: 'bolder',\n      marginRight: spacing(4),\n    },\n    appNameSup: {\n      fontWeight: 'lighter',\n      fontSize: '0.5em',\n      marginLeft: '0.5rem',\n    },\n    btn: {\n      textTransform: 'none',\n    },\n  }),\n)\n\nconst TitleBar: FunctionComponent<unknown> = () => {\n  const classes = useStyles()\n\n  return (\n    <Box\n      className={classes.root}\n      bgcolor='background.titleBar'\n      paddingX={4}\n      display='flex'\n      alignItems='center'\n    >\n      <Typography variant='h1' className={classes.appName}>\n        SnowB BMF\n        <sup className={classes.appNameSup}>BETA</sup>\n      </Typography>\n      <Box flex='auto' paddingX={4}>\n        <ButtonNew className={classes.btn} />\n        <ButtonOpen className={classes.btn} />\n        <ButtonSave className={classes.btn} />\n        <ButtonExport className={classes.btn} />\n      </Box>\n      <IconButton\n        size='small'\n        component='a'\n        href='https://github.com/SilenceLeo/snowb-bmf'\n        target='_blank'\n        title='GitHub'\n      >\n        <GitHubIcon />\n      </IconButton>\n    </Box>\n  )\n}\nexport default TitleBar\n","import React, { FunctionComponent } from 'react'\nimport { SketchPicker, ColorResult } from 'react-color'\nimport { useTheme, makeStyles, createStyles } from '@material-ui/core/styles'\nimport Popper, { PopperPlacementType } from '@material-ui/core/Popper'\n\nexport interface ChildrenProps {\n  open: boolean\n  color: string\n  placement: PopperPlacementType\n  anchorEl: HTMLDivElement | null\n  onChange(color: string): void\n}\n\nconst usePickerStyle = () => {\n  const theme = useTheme()\n  const { palette } = theme\n\n  if (palette.type === 'light') return {}\n\n  return {\n    default: {\n      picker: {\n        background: palette.background.titleBar,\n        shadow: theme.shadows[24],\n      },\n      alpha: {\n        background: '#fff',\n      },\n      color: {\n        background: '#fff',\n      },\n    },\n  }\n}\n\nconst useStyles = makeStyles(({ palette }) =>\n  createStyles({\n    picker: {\n      '& *': {\n        color: `${palette.text.primary} !important`,\n        borderColor: `${palette.divider} !important`,\n      },\n      '& input': {\n        background: 'none',\n        color: `${palette.text.primary} !important`,\n        boxShadow: `none !important`,\n        border: `1px solid ${palette.divider} !important`,\n      },\n    },\n  }),\n)\n\nconst WrappedSketchPicker: FunctionComponent<Partial<ChildrenProps>> = (\n  props: Partial<ChildrenProps>,\n) => {\n  const { open, anchorEl, color, onChange, placement } = props\n  const classes = useStyles()\n  const pickerStyle = usePickerStyle()\n  return (\n    <Popper\n      open={!!open}\n      anchorEl={anchorEl}\n      placement={placement || 'bottom'}\n      style={{ zIndex: 999999 }}\n    >\n      <SketchPicker\n        color={color}\n        styles={pickerStyle}\n        className={classes.picker}\n        onChange={({ rgb }: ColorResult) => {\n          if (onChange)\n            onChange(\n              `rgba(${rgb.r},${rgb.g},${rgb.b},${\n                typeof rgb.a === 'undefined' ? 1 : rgb.a\n              })`,\n            )\n        }}\n      />\n    </Popper>\n  )\n}\n\nexport default WrappedSketchPicker\n","import React, { FunctionComponent, useRef, useState } from 'react'\nimport { makeStyles, createStyles, Theme } from '@material-ui/core/styles'\nimport ClickAwayListener from '@material-ui/core/ClickAwayListener'\n\nimport WrappedSketchPicker from '../WrappedSketchPicker'\n\nexport interface ColorInputProps {\n  color?: string\n  onChange?: (color: string) => void\n}\n\nconst useStyles = makeStyles(({ palette, bgPixel }: Theme) =>\n  createStyles({\n    root: {\n      overflow: 'hidden',\n    },\n    swatch: {\n      ...bgPixel,\n      display: 'inline-block',\n      cursor: 'pointer',\n    },\n    color: {\n      width: '46px',\n      height: '24px',\n      border: `5px solid ${palette.primary.main}`,\n      backgroundColor: (props: ColorInputProps) => props.color || '',\n    },\n  }),\n)\n\nconst ColorInput: FunctionComponent<ColorInputProps> = (\n  props: ColorInputProps,\n) => {\n  const { color, onChange } = props\n  const classes = useStyles(props)\n  const anchorEl = useRef(null)\n  const [open, setOpen] = useState(false)\n\n  return (\n    <ClickAwayListener\n      mouseEvent='onMouseDown'\n      onClickAway={() => setOpen(false)}\n    >\n      <div aria-hidden className={classes.swatch} ref={anchorEl}>\n        <div\n          aria-hidden\n          className={classes.color}\n          onClick={() => setOpen(!open)}\n        />\n        <WrappedSketchPicker\n          open={open}\n          anchorEl={anchorEl.current}\n          color={color || '#000000'}\n          onChange={onChange}\n        />\n      </div>\n    </ClickAwayListener>\n  )\n}\n\nexport default ColorInput\n","import React, { FunctionComponent } from 'react'\n\nimport GridInput from 'src/app/components/GridInput'\nimport ColorInput from 'src/app/components/ColorInput'\n\ninterface FormColorProps {\n  color: string\n  onChange(color: string): void\n}\n\nconst FormColor: FunctionComponent<FormColorProps> = (\n  props: FormColorProps,\n) => {\n  const { color, onChange } = props\n\n  return (\n    <GridInput before='Color:' childrenWidth={3}>\n      <ColorInput color={color} onChange={onChange} />\n    </GridInput>\n  )\n}\n\nexport default FormColor\n","import React, {\n  FunctionComponent,\n  DetailedHTMLProps,\n  HTMLAttributes,\n} from 'react'\nimport clsx from 'clsx'\nimport { makeStyles, createStyles, Theme } from '@material-ui/core/styles'\n\ninterface ColorStopPorps\n  extends DetailedHTMLProps<HTMLAttributes<HTMLDivElement>, HTMLDivElement> {\n  left?: string | number\n  top?: string | number\n  color: string\n  isActive: boolean\n}\n\nconst useStyles = makeStyles(({ bgPixel, palette }: Theme) =>\n  createStyles({\n    root: {\n      ...bgPixel,\n      width: '12px',\n      height: '12px',\n      border: `solid ${palette.primary.main}`,\n      borderWidth: '0 1px 1px',\n      position: 'absolute',\n      cursor: 'pointer',\n      marginLeft: '-6px',\n      left: (props) => props.left || 0,\n      zIndex: (props) => (props.isActive ? 2 : 1),\n      '&:before,&:after': {\n        position: 'absolute',\n        content: '\"\"',\n        width: 0,\n        height: 0,\n        borderStyle: 'solid',\n        left: '0',\n      },\n      '&:before': {\n        top: '-6px',\n        left: '-1px',\n        borderWidth: '0 6px 6px 6px',\n        borderColor: `transparent transparent ${palette.primary.dark} transparent`,\n      },\n      '&:after': {\n        top: '-5px',\n        borderWidth: '0 5px 5px 5px',\n        borderColor: (props) => {\n          const activeColor =\n            palette.type === 'dark'\n              ? palette.common.white\n              : palette.common.black\n\n          return `transparent transparent ${\n            props.isActive ? activeColor : palette.grey[600]\n          } transparent`\n        },\n      },\n    },\n    color: {\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n      backgroundColor: ({ color }: ColorStopPorps) => color || 'transparent',\n    },\n  }),\n)\n\nconst ColorStop: FunctionComponent<ColorStopPorps> = (\n  props: ColorStopPorps,\n) => {\n  const { left, top, color, isActive, className, ...divProps } = props\n  const classes = useStyles({ left, top, color, isActive })\n\n  return (\n    <div className={clsx(classes.root, className)} {...divProps}>\n      <div className={classes.color} />\n    </div>\n  )\n}\n\nexport default ColorStop\n","import React, {\n  FunctionComponent,\n  useCallback,\n  useRef,\n  MutableRefObject,\n  useState,\n  useEffect,\n} from 'react'\nimport clsx from 'clsx'\nimport { makeStyles, createStyles } from '@material-ui/core/styles'\n\nimport ColorStop from './ColorStop'\n\nexport interface AddPaletteItem {\n  offset: number\n  color: string\n}\n\nexport interface PaletteItem extends AddPaletteItem {\n  id: number\n  offset: number\n  color: string\n}\n\ninterface ColorStopsHolderProps {\n  className?: string\n  palette: PaletteItem[]\n  activeId?: number\n  onAdd(offset: number): void\n  onUpdate(paletteItem: Partial<AddPaletteItem>, isDelete?: boolean): void\n  onSelect(id?: number): void\n}\n\nconst useStyles = makeStyles(() =>\n  createStyles({\n    root: {\n      width: '100%',\n      height: '17px',\n      position: 'relative',\n      cursor: 'crosshair',\n    },\n  }),\n)\n\nconst ColorStopsHolder: FunctionComponent<ColorStopsHolderProps> = (\n  props: ColorStopsHolderProps,\n) => {\n  const { className, palette, activeId, onAdd, onUpdate, onSelect } = props\n  const classes = useStyles(props)\n  const [width, setWidth] = useState(0)\n  const [startPoint, setStartPoint] = useState({ x: 0, y: 0, offset: 0 })\n  const [isDragging, setIsDragging] = useState(false)\n  const rootRef: MutableRefObject<HTMLDivElement | null> = useRef(null)\n\n  useEffect(() => {\n    if (rootRef.current) {\n      setWidth(rootRef.current.clientWidth)\n    }\n  }, [rootRef])\n\n  const handleAddPalette = (\n    e: React.MouseEvent<HTMLDivElement, MouseEvent>,\n  ) => {\n    const target = rootRef.current\n    if (!target || e.buttons !== 1) return\n    const { left } = target.getBoundingClientRect()\n    const offset = (e.clientX - left) / width\n    onAdd(offset)\n    setIsDragging(true)\n    setStartPoint({ x: e.clientX, y: e.clientY, offset })\n  }\n\n  const handleMouseDown = (\n    e: React.MouseEvent<HTMLDivElement, MouseEvent>,\n    paletteItem: PaletteItem,\n  ) => {\n    if (e.buttons !== 1) return\n    e.preventDefault()\n    e.stopPropagation()\n    setStartPoint({ x: e.clientX, y: e.clientY, offset: paletteItem.offset })\n    setIsDragging(true)\n    onSelect(paletteItem.id)\n  }\n\n  const handleMouseMove = useCallback(\n    (e: MouseEvent) => {\n      if (!isDragging || !activeId) return\n      if (e.buttons !== 1) {\n        setIsDragging(false)\n        return\n      }\n      const idx = palette.findIndex(\n        (paletteItem) => paletteItem.id === activeId,\n      )\n\n      if (idx < 0) return\n      const newPalette = [...palette]\n\n      if (Math.abs(e.clientY - startPoint.y) > 50) {\n        onUpdate(newPalette[idx], true)\n        return\n      }\n\n      const paletteItem = newPalette[idx]\n      const offset = Math.min(\n        Math.max((e.clientX - startPoint.x) / width + startPoint.offset, 0),\n        1,\n      )\n      newPalette[idx] = { ...paletteItem, offset }\n      onUpdate({ offset })\n    },\n    [\n      activeId,\n      isDragging,\n      onUpdate,\n      palette,\n      startPoint.offset,\n      startPoint.x,\n      startPoint.y,\n      width,\n    ],\n  )\n\n  const handleMouseUp = useCallback((e: MouseEvent) => {\n    e.stopPropagation()\n    e.preventDefault()\n    setIsDragging(false)\n  }, [])\n\n  useEffect(() => {\n    if (isDragging) {\n      window.addEventListener('mousemove', handleMouseMove)\n      window.addEventListener('mouseup', handleMouseUp)\n    } else {\n      window.removeEventListener('mousemove', handleMouseMove)\n      window.removeEventListener('mouseup', handleMouseUp)\n    }\n\n    return () => {\n      window.removeEventListener('mousemove', handleMouseMove)\n      window.removeEventListener('mouseup', handleMouseUp)\n    }\n  }, [handleMouseMove, handleMouseUp, isDragging])\n\n  return (\n    <div\n      aria-hidden\n      ref={rootRef}\n      className={clsx(classes.root, className)}\n      onMouseDown={handleAddPalette}\n    >\n      {palette.map((paletteItem) => (\n        <ColorStop\n          key={paletteItem.id}\n          left={width * paletteItem.offset}\n          color={paletteItem.color}\n          isActive={paletteItem.id === activeId}\n          onMouseDown={(e) => handleMouseDown(e, paletteItem)}\n        />\n      ))}\n    </div>\n  )\n}\n\nexport default ColorStopsHolder\n","import React, { FunctionComponent, useState } from 'react'\nimport { makeStyles } from '@material-ui/core/styles'\n\nexport interface PaletteItem {\n  id: number | string\n  offset: number\n  color: string\n}\n\ninterface PaletteProps {\n  width?: number | string\n  height?: number | string\n  palette: PaletteItem[]\n}\n\nconst useStyles = makeStyles(({ bgPixel }) => ({\n  root: {\n    ...bgPixel,\n    width: (props: PaletteProps) => props.width || '100%',\n    height: (props: PaletteProps) => props.height || '100%',\n    border: '1px solid #ccc',\n  },\n  svg: {\n    width: '100%',\n    height: '100%',\n    verticalAlign: 'top',\n  },\n}))\n\nconst Palette: FunctionComponent<PaletteProps> = (\n  props: PaletteProps,\n): JSX.Element => {\n  const classes = useStyles(props)\n  const { palette } = props\n  const [id] = useState(`palette_${Math.random().toString().substr(2, 9)}`)\n  const sortedPalette = [...palette].sort(\n    ({ offset: offset1 }, { offset: offset2 }) => offset1 - offset2,\n  )\n\n  return (\n    <div className={classes.root}>\n      <svg className={classes.svg}>\n        <defs>\n          <linearGradient id={id} x1='0' y1='0.5' x2='1' y2='0.5'>\n            {sortedPalette.map((item) => (\n              <stop\n                key={item.id}\n                offset={item.offset}\n                style={{ stopColor: item.color }}\n              />\n            ))}\n          </linearGradient>\n        </defs>\n        <rect x='0' y='0' width='100%' height='100%' fill={`url(#${id})`} />\n      </svg>\n    </div>\n  )\n}\n\nexport default Palette\n","import React, { FunctionComponent, useRef, useState, useEffect } from 'react'\nimport Color from 'color'\nimport ClickAwayListener from '@material-ui/core/ClickAwayListener'\n\nimport ColorStopsHolder, {\n  AddPaletteItem,\n  PaletteItem,\n} from './ColorStopsHolder'\nimport Palette from '../Palette'\n\nexport interface GradientBuilderProps {\n  children?: JSX.Element\n  palette: PaletteItem[]\n  onAdd: (addPaletteItem: AddPaletteItem) => void\n  onUpdate: (palette: PaletteItem[]) => void\n}\n\nexport interface ChildrenProps {\n  open: boolean\n  anchorEl: HTMLDivElement | null\n  color: string\n  onChange(color: string): void\n}\n\nconst GradientBuilder: FunctionComponent<GradientBuilderProps> = (\n  props: GradientBuilderProps,\n) => {\n  const { children, palette, onUpdate, onAdd } = props\n  const rootEl: React.MutableRefObject<HTMLDivElement | null> = useRef(null)\n  const [oldPalette, setOldPalette] = useState([...palette])\n  const [activeId, setActiveId] = useState<number>(0)\n  const [activeColor, setActiveColor] = useState<string>('')\n  const [isAdd, setIsAdd] = useState(false)\n\n  useEffect(() => {\n    if (isAdd) {\n      const newIds = palette.map(({ id }) => id)\n      const oldIds = oldPalette.map(({ id }) => id)\n      const diff = Array.from(new Set([...newIds, ...oldIds])).filter(\n        (id) => !oldIds.includes(id),\n      )\n      if (diff.length > 0) {\n        setActiveId(diff[0])\n      }\n      setIsAdd(() => false)\n    }\n  }, [palette, isAdd, oldPalette])\n\n  useEffect(() => {\n    setOldPalette([...palette])\n  }, [palette])\n\n  useEffect(() => {\n    if (activeId) {\n      const paletteItem = palette.find((item) => item.id === activeId)\n      if (paletteItem) {\n        setActiveColor(paletteItem.color)\n      }\n    }\n  }, [activeId, palette])\n\n  const handleAdd = (offset: number) => {\n    const list = [...palette]\n    const current = { offset, color: 'rgba(0,0,0,1)' }\n    let left: PaletteItem | undefined\n    let right: PaletteItem | undefined\n    setActiveId(0)\n\n    list.forEach((item) => {\n      if (\n        item.offset < current.offset &&\n        (!left || left.offset < item.offset)\n      ) {\n        left = item\n      } else if (!right || right.offset > item.offset) {\n        right = item\n      }\n    })\n\n    if (left && right) {\n      const offsetSpace =\n        (current.offset - left.offset) / (right.offset - left.offset)\n      const leftColor = Color(left.color)\n      const rightColor = Color(right.color)\n\n      const r =\n        (rightColor.red() - leftColor.red()) * offsetSpace + leftColor.red()\n      const g =\n        (rightColor.green() - leftColor.green()) * offsetSpace +\n        leftColor.green()\n      const b =\n        (rightColor.blue() - leftColor.blue()) * offsetSpace + leftColor.blue()\n      const a =\n        (rightColor.alpha() - leftColor.alpha()) * offsetSpace +\n        leftColor.alpha()\n      current.color = `rgba(${Math.round(r)},${Math.round(g)},${Math.round(\n        b,\n      )},${Math.round(a)})`\n    } else if (left || right) {\n      current.color = ((left || right) as PaletteItem).color\n    }\n\n    onAdd(current)\n    setIsAdd(true)\n  }\n\n  const handleUpdate = (item: Partial<AddPaletteItem>, isDelete = false) => {\n    if (!activeId) return\n\n    const newPalette = [...palette]\n    const idx = newPalette.findIndex(\n      (paletteItem) => paletteItem.id === activeId,\n    )\n    if (isDelete) {\n      onUpdate([...newPalette.slice(0, idx), ...newPalette.slice(idx + 1)])\n      setActiveId(0)\n    } else {\n      const updateItem = { ...newPalette[idx], ...item }\n      onUpdate([\n        ...newPalette.slice(0, idx),\n        updateItem,\n        ...newPalette.slice(idx + 1),\n      ])\n    }\n  }\n\n  return (\n    <ClickAwayListener\n      mouseEvent='onMouseDown'\n      onClickAway={() => setActiveId(0)}\n    >\n      <div ref={rootEl}>\n        <Palette palette={palette} height='35px' />\n        <ColorStopsHolder\n          palette={palette}\n          activeId={activeId}\n          onAdd={handleAdd}\n          onUpdate={handleUpdate}\n          onSelect={(id) => setActiveId(id || 0)}\n        />\n        {children\n          ? React.cloneElement(children, {\n              open: !!activeId || isAdd,\n              anchorEl: rootEl.current,\n              color: activeColor,\n              onChange: (color: string) =>\n                handleUpdate({\n                  color,\n                }),\n            })\n          : null}\n      </div>\n    </ClickAwayListener>\n  )\n}\nexport default GradientBuilder\n","import React, {\n  useState,\n  useRef,\n  useEffect,\n  FunctionComponent,\n  useCallback,\n} from 'react'\nimport { makeStyles, createStyles } from '@material-ui/core/styles'\n\nexport interface AnglePickerProps {\n  width?: number\n  angle: number\n  onChange(angle: number): void\n}\n\nconst useStyles = makeStyles(() =>\n  createStyles({\n    root: {\n      width: (props: AnglePickerProps) =>\n        props.width ? `${props.width}px` : '36px',\n      height: (props) => (props.width ? `${props.width}px` : '36px'),\n      position: 'relative',\n      cursor: 'crosshair',\n      overflow: 'hidden',\n      borderRadius: '100%',\n      background: '#FFF',\n    },\n    point: {\n      width: '6px',\n      height: '6px',\n      borderRadius: '100%',\n      position: 'relative',\n      left: '50%',\n      top: '50%',\n      marginTop: '-2px',\n      background: '#000',\n      pointerEvents: 'none',\n      transformOrigin: `0 50%`,\n      transform: (props) =>\n        `rotate(${props.angle || 0}deg) translate(${\n          (props.width || 36) / 2 - 8\n        }px, 0)`,\n    },\n  }),\n)\n\nconst AnglePicker: FunctionComponent<AnglePickerProps> = (\n  props: AnglePickerProps,\n) => {\n  const { onChange } = props\n  const rootRef = useRef<HTMLDivElement>(null)\n  const [isDragging, setIsDragging] = useState(false)\n  const classes = useStyles(props)\n\n  const handleMouseMove = useCallback(\n    (e: React.MouseEvent<HTMLDivElement, MouseEvent> | MouseEvent) => {\n      if (!rootRef.current) return\n\n      const { clientX, clientY } = e\n      const bounds = rootRef.current.getBoundingClientRect()\n      const radians = Math.atan2(\n        clientY - (bounds.y + bounds.height / 2),\n        clientX - (bounds.x + bounds.width / 2),\n      )\n      onChange(Math.round(radians * (180 / Math.PI)))\n    },\n    [onChange],\n  )\n\n  const handleMouseUp = useCallback((e: MouseEvent) => {\n    e.stopPropagation()\n    e.preventDefault()\n    setIsDragging(false)\n  }, [])\n\n  const handleMouseDown = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    if (!rootRef.current) return\n    setIsDragging(true)\n    handleMouseMove(e)\n  }\n\n  useEffect(() => {\n    if (isDragging) {\n      window.addEventListener('mousemove', handleMouseMove)\n      window.addEventListener('mouseup', handleMouseUp)\n    } else {\n      window.removeEventListener('mousemove', handleMouseMove)\n      window.removeEventListener('mouseup', handleMouseUp)\n    }\n\n    return () => {\n      window.removeEventListener('mousemove', handleMouseMove)\n      window.removeEventListener('mouseup', handleMouseUp)\n    }\n  }, [handleMouseMove, handleMouseUp, isDragging])\n\n  return (\n    <div\n      aria-hidden\n      className={classes.root}\n      ref={rootRef}\n      onMouseDown={handleMouseDown}\n    >\n      <div className={classes.point} />\n    </div>\n  )\n}\n\nexport default AnglePicker\n","import React, { FunctionComponent } from 'react'\nimport Input from '@material-ui/core/Input'\n\nimport GridInput from 'src/app/components/GridInput'\nimport AnglePicker, { AnglePickerProps } from 'src/app/components/AnglePicker'\n\nconst FormAngle: FunctionComponent<AnglePickerProps> = (\n  props: AnglePickerProps,\n) => {\n  const { angle, onChange } = props\n\n  return (\n    <GridInput\n      before='Angle:'\n      after={<AnglePicker width={24} angle={angle} onChange={onChange} />}\n    >\n      <Input\n        value={angle}\n        fullWidth\n        type='number'\n        onChange={(e) => onChange(Number(e.target.value))}\n      />\n    </GridInput>\n  )\n}\n\nexport default FormAngle\n","import React, { FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport Box from '@material-ui/core/Box'\nimport Radio from '@material-ui/core/Radio'\nimport RadioGroup from '@material-ui/core/RadioGroup'\nimport FormControlLabel from '@material-ui/core/FormControlLabel'\n\nimport GradientPicker from 'src/app/components/GradientPicker'\nimport WrappedSketchPicker from 'src/app/components/WrappedSketchPicker'\nimport { Gradient, GradientType } from 'src/store'\nimport GridInput from 'src/app/components/GridInput'\n\nimport FormAngle from '../FormAngle'\n\ninterface FormGradientProps {\n  gradient: Gradient\n}\n\nconst FormGradient: FunctionComponent<FormGradientProps> = (\n  props: FormGradientProps,\n) => {\n  const {\n    gradient: {\n      type,\n      angle,\n      palette,\n      addColor,\n      updatePalette,\n      setAngle,\n      setType,\n    },\n  } = props\n\n  return (\n    <>\n      <Box paddingX={2} marginY={4}>\n        <FormAngle angle={angle} onChange={setAngle} />\n      </Box>\n\n      <Box paddingX={2} marginY={4}>\n        <GridInput before='Type:' component='div' childrenWidth={8}>\n          <RadioGroup\n            row\n            name='type'\n            value={type}\n            onChange={(e) => setType(Number(e.target.value))}\n            style={{ flexWrap: 'nowrap' }}\n          >\n            <FormControlLabel\n              value={GradientType.LINEAR}\n              control={<Radio size='small' color='default' />}\n              label='Linear'\n            />\n            <FormControlLabel\n              value={GradientType.RADIAL}\n              control={<Radio size='small' color='default' />}\n              label='Radial'\n            />\n          </RadioGroup>\n        </GridInput>\n      </Box>\n      <Box paddingX={2} marginY={4}>\n        <GradientPicker\n          palette={palette}\n          onAdd={(e) => addColor(e.offset, e.color)}\n          onUpdate={updatePalette}\n        >\n          <WrappedSketchPicker />\n        </GradientPicker>\n      </Box>\n    </>\n  )\n}\n\nexport default observer(FormGradient)\n","import React, { FunctionComponent } from 'react'\nimport { makeStyles, createStyles } from '@material-ui/core/styles'\nimport Box from '@material-ui/core/Box'\n\nimport readFile from 'src/utils/readFile'\n\nconst useStyles = makeStyles((theme) =>\n  createStyles({\n    root: {\n      width: theme.spacing(12),\n      height: theme.spacing(12),\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      position: 'relative',\n      border: `1px solid ${theme.palette.primary.main}`,\n      cursor: 'pointer',\n      ...theme.bgPixel,\n    },\n    image: {\n      maxWidth: '100%',\n      maxHeight: '100%',\n      pointerEvents: 'none',\n    },\n  }),\n)\n\ninterface FileSelectorProps {\n  src: string\n  onChange(image: ArrayBuffer): void\n}\n\nconst FileSelector: FunctionComponent<FileSelectorProps> = (\n  props: FileSelectorProps,\n) => {\n  const { src, onChange } = props\n  const classes = useStyles()\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>): void => {\n    if (!e.target.files) return\n    if (e.target.files.length > 0) {\n      readFile(e.target.files[0]).then((buffer) => {\n        if (buffer instanceof ArrayBuffer) onChange(buffer)\n      })\n    }\n  }\n\n  return (\n    <Box component='label' className={classes.root}>\n      <input\n        hidden\n        type='file'\n        multiple\n        accept='image/*'\n        onChange={handleChange}\n      />\n      <img className={classes.image} src={src} alt='' />\n    </Box>\n  )\n}\n\nexport default FileSelector\n","import React, { FunctionComponent } from 'react'\n\nimport GridInput from 'src/app/components/GridInput'\nimport Box from '@material-ui/core/Box'\nimport Input from '@material-ui/core/Input'\nimport Select from '@material-ui/core/Select'\nimport MenuItem from '@material-ui/core/MenuItem'\n\nimport { PatternTexture, Repetition } from 'src/store'\n\nimport FileSelector from './FileSelector'\n\ninterface FormImageProps {\n  patternTexture: PatternTexture\n  scale: number\n  src: string\n  // onChangeImage(buffer: ArrayBuffer): void\n  // onChangeScale(scale: number): void\n}\n\nconst FormImage: FunctionComponent<FormImageProps> = (\n  props: FormImageProps,\n) => {\n  const { patternTexture } = props\n  const { src, scale, repetition, setRepetition, setScale, setImage } =\n    patternTexture\n\n  return (\n    <>\n      <Box paddingX={2} marginY={4}>\n        <GridInput\n          component='div'\n          before='Scale:'\n          after={<FileSelector src={src} onChange={setImage} />}\n        >\n          <Input\n            value={scale}\n            fullWidth\n            type='number'\n            inputProps={{ min: 0.01, step: 0.1 }}\n            onChange={(e) => setScale(Number(e.target.value))}\n          />\n        </GridInput>\n      </Box>\n      <Box paddingX={2} marginY={4}>\n        <GridInput before='Repeat:'>\n          <Select\n            value={repetition}\n            onChange={(e) => setRepetition(e.target.value as Repetition)}\n            displayEmpty\n            fullWidth\n          >\n            <MenuItem value='repeat'>Repeat</MenuItem>\n            <MenuItem value='repeat-x'>Repeat-x</MenuItem>\n            <MenuItem value='repeat-y'>Repeat-y</MenuItem>\n            <MenuItem value='no-repeat'>No Repeat</MenuItem>\n          </Select>\n        </GridInput>\n      </Box>\n    </>\n  )\n}\n\nexport default FormImage\n","import React, { FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport Box from '@material-ui/core/Box'\nimport Radio from '@material-ui/core/Radio'\nimport RadioGroup from '@material-ui/core/RadioGroup'\nimport FormControlLabel from '@material-ui/core/FormControlLabel'\n\nimport { FontStyleConfig, FillType } from 'src/store'\n\nimport FormColor from '../FormColor'\nimport FormGradient from '../FormGradient'\nimport FormImage from '../FormImage'\n\ninterface FormFillProps {\n  config: FontStyleConfig\n}\n\nconst FormFill: FunctionComponent<FormFillProps> = (props: FormFillProps) => {\n  const {\n    config: { type, color, gradient, patternTexture, setType, setColor },\n  } = props\n\n  return (\n    <>\n      <Box paddingX={2} marginY={4}>\n        <RadioGroup\n          row\n          name='type'\n          value={type}\n          onChange={(e) => setType(Number(e.target.value))}\n        >\n          <FormControlLabel\n            value={FillType.SOLID}\n            control={<Radio size='small' color='default' />}\n            label='Solid'\n          />\n          <FormControlLabel\n            value={FillType.GRADIENT}\n            control={<Radio size='small' color='default' />}\n            label='Gradient'\n          />\n          <FormControlLabel\n            value={FillType.IMAGE}\n            control={<Radio size='small' color='default' />}\n            label='Image'\n          />\n        </RadioGroup>\n      </Box>\n      {type === 0 ? (\n        <Box paddingX={2} marginY={4}>\n          <FormColor color={color} onChange={setColor} />\n        </Box>\n      ) : null}\n      {type === 1 ? <FormGradient gradient={gradient} /> : null}\n      {type === 2 ? (\n        <FormImage\n          patternTexture={patternTexture}\n          src={patternTexture.src}\n          scale={patternTexture.scale}\n          // onChangeImage={patternTexture.setImage}\n          // onChangeScale={patternTexture.setScale}\n        />\n      ) : null}\n    </>\n  )\n}\n\nexport default observer(FormFill)\n","import React, { FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport Box from '@material-ui/core/Box'\nimport Typography from '@material-ui/core/Typography'\n\nimport { useFill } from 'src/store/hooks'\nimport FormFill from '../../../common/FormFill'\n\nconst Fill: FunctionComponent<unknown> = () => {\n  const fill = useFill()\n  return (\n    <>\n      <Box paddingX={2} marginY={4}>\n        <Typography>Fill</Typography>\n      </Box>\n      <FormFill config={fill} />\n    </>\n  )\n}\n\nexport default observer(Fill)\n","import React, { FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport { createStyles, makeStyles } from '@material-ui/core/styles'\nimport Box from '@material-ui/core/Box'\nimport Input from '@material-ui/core/Input'\nimport Switch from '@material-ui/core/Switch'\nimport Button from '@material-ui/core/Button'\nimport Typography from '@material-ui/core/Typography'\nimport ButtonGroup from '@material-ui/core/ButtonGroup'\n\nimport { useStyle } from 'src/store/hooks'\nimport GridInput from 'src/app/components/GridInput'\n\nimport FormFill from 'src/app/layout/common/FormFill'\n\nconst useStyles = makeStyles(() =>\n  createStyles({\n    disabled: {\n      opacity: 0.3,\n      pointerEvents: 'none',\n    },\n    title: {\n      flex: 1,\n    },\n  }),\n)\n\nconst Stroke: FunctionComponent<unknown> = () => {\n  const classes = useStyles()\n  const { stroke, useStroke, setUseStroke } = useStyle()\n  const {\n    setWidth,\n    lineJoin,\n    setLineJoin,\n    lineCap,\n    setLineCap,\n    strokeType,\n    setStrokeType,\n  } = stroke\n\n  return (\n    <>\n      <Box\n        component='label'\n        display='flex'\n        alignItems='center'\n        paddingX={2}\n        marginY={4}\n      >\n        <Typography component='div' className={classes.title}>\n          Stroke\n        </Typography>\n        Off\n        <Switch\n          size='small'\n          checked={useStroke}\n          onChange={(e) => setUseStroke(e.target.checked)}\n        />\n        On\n      </Box>\n      <div className={useStroke ? '' : classes.disabled}>\n        <Box paddingX={2} marginY={4}>\n          <GridInput before='Width:' after='px'>\n            <Input\n              value={stroke?.width || 0}\n              fullWidth\n              type='number'\n              inputProps={{ min: 0 }}\n              onChange={(e) => setWidth(Number(e.target.value))}\n            />\n          </GridInput>\n        </Box>\n\n        <Box paddingX={2} marginY={4}>\n          <GridInput before='Type:' component='div' childrenWidth={8}>\n            <ButtonGroup size='small' color='primary'>\n              <Button\n                onClick={() => setStrokeType(0)}\n                variant={strokeType === 0 ? 'contained' : 'outlined'}\n              >\n                Outer\n              </Button>\n              <Button\n                onClick={() => setStrokeType(1)}\n                variant={strokeType === 1 ? 'contained' : 'outlined'}\n              >\n                Middle\n              </Button>\n              <Button\n                onClick={() => setStrokeType(2)}\n                variant={strokeType === 2 ? 'contained' : 'outlined'}\n              >\n                Inner\n              </Button>\n            </ButtonGroup>\n          </GridInput>\n        </Box>\n\n        <Box paddingX={2} marginY={4}>\n          <GridInput before='Line Cap:' component='div' childrenWidth={8}>\n            <ButtonGroup size='small' color='primary'>\n              <Button\n                onClick={() => setLineCap('butt')}\n                variant={lineCap === 'butt' ? 'contained' : 'outlined'}\n              >\n                Butt\n              </Button>\n              <Button\n                onClick={() => setLineCap('round')}\n                variant={lineCap === 'round' ? 'contained' : 'outlined'}\n              >\n                Round\n              </Button>\n              <Button\n                onClick={() => setLineCap('square')}\n                variant={lineCap === 'square' ? 'contained' : 'outlined'}\n              >\n                Square\n              </Button>\n            </ButtonGroup>\n          </GridInput>\n        </Box>\n\n        <Box paddingX={2} marginY={4}>\n          <GridInput before='Line Join:' component='div' childrenWidth={8}>\n            <ButtonGroup size='small' color='primary'>\n              <Button\n                onClick={() => setLineJoin('miter')}\n                variant={lineJoin === 'miter' ? 'contained' : 'outlined'}\n              >\n                Miter\n              </Button>\n              <Button\n                onClick={() => setLineJoin('round')}\n                variant={lineJoin === 'round' ? 'contained' : 'outlined'}\n              >\n                Round\n              </Button>\n              <Button\n                onClick={() => setLineJoin('bevel')}\n                variant={lineJoin === 'bevel' ? 'contained' : 'outlined'}\n              >\n                Bevel\n              </Button>\n            </ButtonGroup>\n          </GridInput>\n        </Box>\n        <FormFill config={stroke} />\n      </div>\n    </>\n  )\n}\n\nexport default observer(Stroke)\n","import React, { FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport { makeStyles, createStyles } from '@material-ui/core/styles'\nimport Box from '@material-ui/core/Box'\nimport Typography from '@material-ui/core/Typography'\nimport Input from '@material-ui/core/Input'\nimport Switch from '@material-ui/core/Switch'\n\nimport { useStyle } from 'src/store/hooks'\nimport GridInput from 'src/app/components/GridInput'\nimport FormColor from '../../../common/FormColor'\n\nconst useStyles = makeStyles(() =>\n  createStyles({\n    disabled: {\n      opacity: 0.3,\n      pointerEvents: 'none',\n    },\n    title: {\n      flex: 1,\n    },\n  }),\n)\n\nconst Shadow: FunctionComponent<unknown> = () => {\n  const { shadow, useShadow, setUseShadow } = useStyle()\n  const { setOffsetX, setOffsetY, setBlur, setColor } = shadow\n  const classes = useStyles()\n\n  return (\n    <>\n      <Box\n        component='label'\n        display='flex'\n        alignItems='center'\n        paddingX={2}\n        marginY={4}\n      >\n        <Typography component='div' className={classes.title}>\n          Shadow\n        </Typography>\n        Off\n        <Switch\n          size='small'\n          checked={useShadow}\n          onChange={(e) => setUseShadow(e.target.checked)}\n        />\n        On\n      </Box>\n      <div className={useShadow ? '' : classes.disabled}>\n        <Box paddingX={2} marginY={4}>\n          <GridInput before='Offset X:' after='px'>\n            <Input\n              value={shadow?.offsetX || 0}\n              fullWidth\n              type='number'\n              disabled={!useShadow}\n              onChange={(e) => setOffsetX(Number(e.target.value))}\n            />\n          </GridInput>\n        </Box>\n        <Box paddingX={2} marginY={4}>\n          <GridInput before='Offset Y:' after='px'>\n            <Input\n              value={shadow?.offsetY || 0}\n              fullWidth\n              type='number'\n              disabled={!useShadow}\n              onChange={(e) => setOffsetY(Number(e.target.value))}\n            />\n          </GridInput>\n        </Box>\n        <Box paddingX={2} marginY={4}>\n          <GridInput before='Blur:' after='px'>\n            <Input\n              value={shadow?.blur || 0}\n              fullWidth\n              type='number'\n              disabled={!useShadow}\n              inputProps={{ style: { textAlign: 'right' }, min: 0 }}\n              onChange={(e) => setBlur(Number(e.target.value))}\n            />\n          </GridInput>\n        </Box>\n        <Box paddingX={2} marginY={4}>\n          <FormColor color={shadow?.color || ''} onChange={setColor} />\n        </Box>\n      </div>\n    </>\n  )\n}\nexport default observer(Shadow)\n","import React, { FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport Box from '@material-ui/core/Box'\nimport Typography from '@material-ui/core/Typography'\n\nimport { useStyle } from 'src/store/hooks'\nimport FormColor from '../../../common/FormColor'\n\nconst BackgroundColor: FunctionComponent<unknown> = () => {\n  const { bgColor, setBgColor } = useStyle()\n\n  return (\n    <>\n      <Box\n        component='label'\n        display='flex'\n        alignItems='center'\n        paddingX={2}\n        marginY={4}\n      >\n        <Typography>Background Color</Typography>\n      </Box>\n      <Box paddingX={2} marginY={4}>\n        <FormColor color={bgColor || ''} onChange={setBgColor} />\n      </Box>\n    </>\n  )\n}\n\nexport default observer(BackgroundColor)\n","import React, { FunctionComponent } from 'react'\nimport { makeStyles, createStyles } from '@material-ui/core/styles'\nimport Box from '@material-ui/core/Box'\nimport Divider from '@material-ui/core/Divider'\nimport Typography from '@material-ui/core/Typography'\n\nimport Fill from './modules/Fill'\nimport Stroke from './modules/Stroke'\nimport Shadow from './modules/Shadow'\nimport BackgroundColor from './modules/BackgroundColor'\n\nconst useStyles = makeStyles(() =>\n  createStyles({\n    root: {\n      overflow: 'hidden',\n      width: '256px',\n    },\n  }),\n)\n\nconst RightBar: FunctionComponent<unknown> = () => {\n  const classes = useStyles()\n\n  return (\n    <Box\n      bgcolor='background.sidebar'\n      display='flex'\n      flexDirection='column'\n      overflow='hidden'\n      className={classes.root}\n    >\n      <Box bgcolor='background.sidebar' boxShadow={2} padding={2}>\n        <Typography variant='subtitle2'>Style Config</Typography>\n      </Box>\n      <Box flex={1} height={0} overflow='hidden auto'>\n        <Fill />\n        <Divider />\n        <Stroke />\n        <Divider />\n        <Shadow />\n        <Divider />\n        <BackgroundColor />\n      </Box>\n    </Box>\n  )\n}\n\nexport default RightBar\n","import { useEffect, useCallback, RefObject, DependencyList } from 'react'\n\ninterface DeltaInfo {\n  deltaScale: number\n  deltaX: number\n  deltaY: number\n}\n\ninterface WheelCallback {\n  (deltaInfo: DeltaInfo): void\n}\n\nfunction useWheel(\n  ref: RefObject<HTMLElement>,\n  onWheel: WheelCallback,\n  deps: DependencyList = [],\n): void {\n  const callback = useCallback(onWheel, [onWheel, deps])\n  const handleWheel = useCallback(\n    (e: WheelEvent) => {\n      e.preventDefault()\n      e.stopPropagation()\n      const { ctrlKey, altKey, deltaX, deltaY } = e\n      if (ctrlKey) {\n        let d = -0.01\n        if (Math.abs(deltaY) > 50) d *= 0.1\n        callback({ deltaScale: deltaY * d, deltaX: 0, deltaY: 0 })\n      } else {\n        let x = -deltaX\n        let y = -deltaY\n        if (deltaX === 0 && altKey && Math.abs(deltaY) > 50) {\n          x = -deltaY\n          y = 0\n        }\n        callback({\n          deltaX: x,\n          deltaY: y,\n          deltaScale: 0,\n        })\n      }\n    },\n    [callback],\n  )\n\n  useEffect(() => {\n    if (!ref.current) return undefined\n\n    const dom = ref.current\n\n    dom.addEventListener('wheel', handleWheel, {\n      passive: false,\n    })\n\n    return () => dom.removeEventListener('wheel', handleWheel)\n  }, [ref, handleWheel])\n}\nexport default useWheel\n","import {\n  useState,\n  useEffect,\n  useMemo,\n  useCallback,\n  DependencyList,\n} from 'react'\n\ninterface OffsetInfo {\n  offsetX: number\n  offsetY: number\n}\n\ninterface WheelCallback {\n  (offsetInfo: OffsetInfo): void\n}\n\nconst point = {\n  x: 0,\n  y: 0,\n}\n\nfunction useSpaceDrag<T extends HTMLElement>(\n  onMove: WheelCallback,\n  deps: DependencyList = [],\n): [0 | 1 | 2, (e: React.MouseEvent<T, MouseEvent>) => void] {\n  const [moveState, setMoveState] = useState({\n    ks: false,\n    ms: false,\n  })\n\n  const dragStatus = useMemo(() => {\n    if (moveState.ks && moveState.ms) return 2\n    if (moveState.ks) return 1\n    return 0\n  }, [moveState.ks, moveState.ms])\n\n  const moveCallback = useCallback(onMove, [onMove, ...deps])\n\n  const handleKeyEvent = useCallback(\n    (e: KeyboardEvent) => {\n      const state = e.keyCode === 32 && e.type === 'keydown'\n      if (moveState.ks === state) return\n      setMoveState((s) => {\n        return {\n          ...s,\n          ks: e.keyCode === 32 && e.type === 'keydown',\n        }\n      })\n    },\n    [moveState.ks],\n  )\n\n  const handleMouseDown = (e: React.MouseEvent<T, MouseEvent>) => {\n    if (!moveState.ks) return\n    const { clientX, clientY } = e\n    point.x = clientX\n    point.y = clientY\n    setMoveState((s) => {\n      return {\n        ...s,\n        ms: true,\n      }\n    })\n  }\n\n  const handleMove = useCallback(\n    (e: MouseEvent) => {\n      const { clientX, clientY } = e\n      const { x, y } = point\n\n      if (clientX - x === 0 && clientY - y === 0) return\n\n      moveCallback({\n        offsetX: clientX - x,\n        offsetY: clientY - y,\n      })\n\n      point.x = clientX\n      point.y = clientY\n    },\n    [moveCallback],\n  )\n\n  const handleEnd = useCallback(() => {\n    setMoveState((s) => {\n      return {\n        ...s,\n        ms: false,\n      }\n    })\n  }, [])\n\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyEvent)\n    window.addEventListener('keyup', handleKeyEvent)\n\n    return () => {\n      window.removeEventListener('keydown', handleKeyEvent)\n      window.removeEventListener('keyup', handleKeyEvent)\n    }\n  }, [handleKeyEvent])\n\n  useEffect(() => {\n    if (moveState.ks && moveState.ms) {\n      window.addEventListener('mousemove', handleMove)\n      window.addEventListener('mouseup', handleEnd)\n    } else {\n      window.removeEventListener('mousemove', handleMove)\n      window.removeEventListener('mouseup', handleEnd)\n    }\n\n    return () => {\n      window.removeEventListener('mousemove', handleMove)\n      window.removeEventListener('mouseup', handleEnd)\n    }\n  }, [handleEnd, handleMove, moveState.ks, moveState.ms])\n\n  return [dragStatus, handleMouseDown]\n}\nexport default useSpaceDrag\n","import React, { useRef, useEffect, FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport { makeStyles, createStyles } from '@material-ui/core/styles'\n\nimport { useProject } from 'src/store/hooks'\nimport useWheel from 'src/app/hooks/useWheel'\nimport useSpaceDrag from 'src/app/hooks/useSpaceDrag'\n\ninterface StyleProps {\n  width: number\n  height: number\n  scale: number\n  offsetX: number\n  offsetY: number\n  dragState: number\n}\n\nconst useStyles = makeStyles(({ bgPixel }) =>\n  createStyles({\n    root: {\n      position: 'relative',\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden',\n      flex: 1,\n      cursor: (props: StyleProps) => {\n        if (props.dragState === 2) return 'grabbing'\n        if (props.dragState === 1) return 'grab'\n        return 'default'\n      },\n    },\n    canvas: {\n      ...bgPixel,\n      transformOrigin: '50% 50%',\n      position: 'absolute',\n      left: '50%',\n      top: '50%',\n      width: (props: StyleProps) => `${props.width}px`,\n      height: (props: StyleProps) => `${props.height}px`,\n      marginLeft: (props: StyleProps) => `${props.width / -2}px`,\n      marginTop: (props: StyleProps) => `${props.height / -2}px`,\n      transform: (props: StyleProps) =>\n        `scale(${props.scale}) translate(${props.offsetX}px,${props.offsetY}px)`,\n      imageRendering: 'pixelated',\n    },\n  }),\n)\n\nconst PackCanvas: FunctionComponent<unknown> = () => {\n  const {\n    isPacking,\n    ui,\n    layout: { padding, auto, fixedSize, width: packWidth, height: packHeight },\n    glyphList,\n    style: { bgColor },\n    packCanvas,\n    setCanvas,\n  } = useProject()\n  const { width, height, scale, offsetX, offsetY } = ui\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  const domRef = useRef<HTMLDivElement>(null)\n  const [dragState, handleMouseDown] = useSpaceDrag(\n    (offsetInfo) => {\n      const { offsetX: ix, offsetY: iy } = offsetInfo\n      const { scale: os, offsetX: ox, offsetY: oy, setTransform } = ui\n      setTransform({\n        offsetX: ox + ix / os,\n        offsetY: oy + iy / os,\n      })\n    },\n    [ui],\n  )\n\n  const classes = useStyles({\n    width,\n    height,\n    scale,\n    offsetX,\n    offsetY,\n    dragState,\n  })\n\n  useWheel(\n    domRef,\n    (info) => {\n      const { offsetX: ox, offsetY: oy, scale: os, setTransform } = ui\n      const s = os + info.deltaScale\n      const x = ox + info.deltaX / s\n      const y = oy + info.deltaY / s\n      setTransform({\n        offsetX: x,\n        offsetY: y,\n        scale: s,\n      })\n    },\n    [ui],\n  )\n\n  useEffect(() => {\n    if (canvasRef.current && canvasRef.current !== packCanvas)\n      setCanvas(canvasRef.current)\n  }, [canvasRef, packCanvas, setCanvas])\n\n  useEffect(() => {\n    if (!glyphList || isPacking || !width || !height) return\n    const canvas = canvasRef.current\n    if (!canvas) return\n\n    canvas.width = width\n    canvas.height = height\n\n    const ctx = canvas.getContext('2d')\n    if (!ctx) return\n\n    if (bgColor) {\n      ctx.fillStyle = bgColor\n      ctx.fillRect(0, 0, canvas.width, canvas.height)\n    }\n\n    glyphList.forEach((glyph) => {\n      if (\n        glyph.source &&\n        glyph.source.width !== 0 &&\n        glyph.source.height !== 0\n      ) {\n        ctx.drawImage(\n          glyph.source as HTMLCanvasElement,\n          glyph.x + (padding || 0),\n          glyph.y + (padding || 0),\n        )\n      }\n    })\n  }, [\n    bgColor,\n    glyphList,\n    isPacking,\n    height,\n    width,\n    padding,\n    auto,\n    fixedSize,\n    packWidth,\n    packHeight,\n  ])\n\n  return (\n    <div\n      aria-hidden\n      ref={domRef}\n      className={classes.root}\n      onMouseDown={handleMouseDown}\n    >\n      <canvas ref={canvasRef} className={classes.canvas} />\n    </div>\n  )\n}\n\nexport default observer(PackCanvas)\n","import React, { FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport { makeStyles, createStyles } from '@material-ui/core/styles'\nimport LinearProgress from '@material-ui/core/LinearProgress'\nimport { useProject } from 'src/store/hooks'\n\nconst useStyles = makeStyles(({ palette }) =>\n  createStyles({\n    root: {\n      width: '100%',\n      background: palette.background.paper,\n      textAlign: 'center',\n      display: 'flex',\n      justifyContent: 'center',\n      alignItems: 'center',\n      fontSize: 12,\n      padding: 2,\n      animationDuration: '300ms',\n      pointerEvents: 'none',\n      color: palette.text.secondary,\n      position: 'relative',\n    },\n    loading: {\n      position: 'absolute',\n      left: 0,\n      top: '100%',\n      width: '100%',\n    },\n  }),\n)\n\nconst PackSizeBar: FunctionComponent<unknown> = () => {\n  const { isPacking, ui } = useProject()\n  const { width, height } = ui\n  const classes = useStyles()\n\n  return (\n    <div className={classes.root}>\n      Packed texture size: {width} x {height}\n      {isPacking ? <LinearProgress className={classes.loading} /> : null}\n    </div>\n  )\n}\n\nexport default observer(PackSizeBar)\n","import React, { FunctionComponent } from 'react'\n\nimport PackCanvas from './PackCanvas'\nimport PackSizeBar from './PackSizeBar'\n\nconst PackView: FunctionComponent<unknown> = () => {\n  return (\n    <>\n      <PackSizeBar />\n      <PackCanvas />\n    </>\n  )\n}\n\nexport default PackView\n","import React, { FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport clsx from 'clsx'\nimport { makeStyles, createStyles } from '@material-ui/core/styles'\n\nimport { useProjectUi } from 'src/store/hooks'\n\nimport { PreviewObject } from './getPreviewCanvas'\n\nconst useStyles = makeStyles(() =>\n  createStyles({\n    letter: {\n      position: 'absolute',\n      '&:hover,&$select': {\n        background: 'rgba(0,0,0,0.2)',\n        outline: '1px solid #000',\n      },\n    },\n    select: {\n      '& + $next': {\n        background: 'rgba(0,0,0,0.1)',\n        outline: '1px dashed #666',\n      },\n    },\n    next: {},\n  }),\n)\n\ninterface LetterListProps {\n  data: PreviewObject\n}\n\nconst LetterList: FunctionComponent<LetterListProps> = (\n  props: LetterListProps,\n) => {\n  const {\n    data: { xOffset, yOffset, list },\n  } = props\n  const classes = useStyles()\n  const ui = useProjectUi()\n  const handleSelect = (\n    e: React.MouseEvent<HTMLDivElement, MouseEvent>,\n    letter: string,\n    next: string,\n  ) => {\n    // setSelectLetter\n    e.stopPropagation()\n    ui.setSelectLetter(letter, next)\n  }\n  return (\n    <>\n      {list.map((item, idx) => {\n        const key = `${item.letter}${idx}`\n        return (\n          <div\n            aria-hidden\n            className={clsx(classes.letter, {\n              [classes.select]: item.letter === ui.selectLetter,\n              [classes.next]: item.letter === ui.selectNextLetter,\n            })}\n            style={{\n              width: item.width,\n              height: item.height,\n              left: `${item.x - xOffset}px`,\n              top: `${item.y - yOffset}px`,\n            }}\n            key={key}\n            onClick={(e) => handleSelect(e, item.letter, item.next)}\n          />\n        )\n      })}\n    </>\n  )\n}\n\nexport default observer(LetterList)\n","import React, { useRef, useState, useEffect, FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport { makeStyles, createStyles } from '@material-ui/core/styles'\n\nimport { useProject } from 'src/store/hooks'\nimport useWheel from 'src/app/hooks/useWheel'\nimport useSpaceDrag from 'src/app/hooks/useSpaceDrag'\nimport { BMFontChar, toBmfInfo } from 'src/file/export'\n\nimport getPreviewCanvas, { PreviewObject } from './getPreviewCanvas'\nimport LetterList from './LetterList'\nimport { autorun } from 'mobx'\n\ninterface StyleProps {\n  width: number\n  height: number\n  scale: number\n  offsetX: number\n  offsetY: number\n  dragState: number\n}\n\nconst useStyles = makeStyles(({ bgPixel }) =>\n  createStyles({\n    root: {\n      position: 'relative',\n      flex: 1,\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden',\n      ...bgPixel,\n      cursor: (props: StyleProps) => {\n        if (props.dragState === 2) return 'grabbing'\n        if (props.dragState === 1) return 'grab'\n        return 'default'\n      },\n    },\n    wrap: {\n      transformOrigin: '50% 50%',\n      position: 'absolute',\n      left: '50%',\n      top: '50%',\n      width: (props: StyleProps) => `${props.width}px`,\n      height: (props: StyleProps) => `${props.height}px`,\n      marginLeft: (props: StyleProps) => `${props.width / -2}px`,\n      marginTop: (props: StyleProps) => `${props.height / -2}px`,\n      transform: (props: StyleProps) =>\n        `scale(${props.scale}) translate(${props.offsetX}px,${props.offsetY}px)`,\n    },\n    canvas: {\n      width: '100%',\n      height: '100%',\n      imageRendering: 'pixelated',\n    },\n  }),\n)\n\nconst PreviewCanvas: FunctionComponent<unknown> = () => {\n  const project = useProject()\n  const [data, setData] = useState<PreviewObject | null>(null)\n  const {\n    ui,\n    style: {\n      font: {\n        size,\n        lineHeight,\n        middle,\n        hanging,\n        top,\n        alphabetic,\n        ideographic,\n        bottom,\n        minBaseLine,\n        maxBaseLine,\n      },\n    },\n    layout: { padding },\n    isPacking,\n  } = project\n  const { previewScale, previewOffsetX, previewOffsetY } = ui\n\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  const domRef = useRef<HTMLDivElement>(null)\n  const [dragState, handleMouseDown] = useSpaceDrag(\n    (offsetInfo) => {\n      const { offsetX: ix, offsetY: iy } = offsetInfo\n      const {\n        previewScale: os,\n        previewOffsetX: ox,\n        previewOffsetY: oy,\n        setPreviewTransform,\n      } = ui\n      setPreviewTransform({\n        previewOffsetX: ox + ix / os,\n        previewOffsetY: oy + iy / os,\n      })\n    },\n    [ui],\n  )\n  const classes = useStyles({\n    width: data ? data.width : 0,\n    height: data ? data.height : 0,\n    scale: previewScale,\n    offsetX: previewOffsetX,\n    offsetY: previewOffsetY,\n    dragState,\n  })\n\n  useWheel(\n    domRef,\n    (info) => {\n      const {\n        previewOffsetX: ox,\n        previewOffsetY: oy,\n        previewScale: os,\n        setPreviewTransform,\n      } = ui\n      const s = os + info.deltaScale\n      const x = ox + info.deltaX / s\n      const y = oy + info.deltaY / s\n      setPreviewTransform({\n        previewOffsetX: x,\n        previewOffsetY: y,\n        previewScale: s,\n      })\n    },\n    [ui],\n  )\n\n  useEffect(() => {\n    if (!canvasRef.current || isPacking || !data) return\n\n    const canvas = canvasRef.current\n    const ctx = canvas.getContext('2d')\n    if (!ctx) return\n    const lh = size * lineHeight\n\n    canvas.width = data.width\n    canvas.height = data.height\n    data.list.forEach((item) => {\n      if (!item.source || item.source.width === 0 || item.source.height === 0)\n        return\n      ctx.drawImage(item.source, item.x - data.xOffset, item.y - data.yOffset)\n    })\n\n    for (let index = 0; index < data.lines; index += 1) {\n      ;[middle, hanging, top, alphabetic, ideographic, bottom].forEach(\n        (baseLine) => {\n          const basey = Math.round(baseLine - minBaseLine + index * lh)\n          ctx.beginPath()\n          ctx.moveTo(-data.xOffset, basey + 0.5 - data.yOffset)\n          ctx.lineTo(data.width, basey + 0.5 - data.yOffset)\n          if (baseLine === minBaseLine || baseLine === maxBaseLine) {\n            ctx.strokeStyle = 'rgba(0,0,0,1)'\n            ctx.setLineDash([])\n          } else {\n            ctx.strokeStyle = 'rgba(0,0,0,0.5)'\n            ctx.setLineDash([10, 3, 2, 3])\n          }\n          ctx.stroke()\n        },\n      )\n      ctx.beginPath()\n      ctx.moveTo(-data.xOffset + 0.5, index * lh - data.yOffset)\n      ctx.lineTo(\n        -data.xOffset + 0.5,\n        index * lh - data.yOffset + maxBaseLine - minBaseLine,\n      )\n      ctx.strokeStyle = 'rgba(0,0,0,1)'\n      ctx.setLineDash([])\n      ctx.stroke()\n    }\n  }, [\n    alphabetic,\n    bottom,\n    data,\n    hanging,\n    ideographic,\n    isPacking,\n    lineHeight,\n    maxBaseLine,\n    middle,\n    minBaseLine,\n    size,\n    top,\n  ])\n\n  useEffect(() => {\n    autorun(() => {\n      if (!canvasRef.current || isPacking) return\n      const canvas = canvasRef.current\n      const ctx = canvas.getContext('2d')\n      if (!ctx) return\n\n      const { chars, kernings } = toBmfInfo(project)\n      const kerningMap: Map<number, Map<number, number>> = new Map()\n      kernings.list.forEach(({ first, second, amount }) => {\n        if (!kerningMap.has(first)) kerningMap.set(first, new Map())\n        const k = kerningMap.get(first)\n        k?.set(second, amount)\n      })\n      const charMap: Map<string, BMFontChar> = new Map()\n      chars.list.forEach((char) => {\n        charMap.set(char.letter, char)\n      })\n      const lh = size * lineHeight\n      const obj = getPreviewCanvas(\n        ui.previewText,\n        charMap,\n        kerningMap,\n        lh,\n        maxBaseLine - minBaseLine,\n        padding,\n      )\n      setData(() => obj)\n    })\n  }, [\n    isPacking,\n    lineHeight,\n    maxBaseLine,\n    minBaseLine,\n    project,\n    size,\n    ui.previewText,\n    padding,\n  ])\n\n  return (\n    <div\n      aria-hidden\n      ref={domRef}\n      className={classes.root}\n      onMouseDown={handleMouseDown}\n      onClick={() => ui.setSelectLetter('', '')}\n    >\n      <div className={classes.wrap}>\n        <canvas ref={canvasRef} className={classes.canvas} />\n        {data ? <LetterList data={data} /> : null}\n      </div>\n    </div>\n  )\n}\n\nexport default observer(PreviewCanvas)\n","import { BMFontChar } from 'src/file/export'\n\ninterface PreviewItem {\n  x: number\n  y: number\n  width: number\n  height: number\n  source: HTMLImageElement | HTMLCanvasElement | null\n  letter: string\n  next: string\n}\n\nexport interface PreviewObject {\n  xOffset: number\n  yOffset: number\n  width: number\n  height: number\n  list: PreviewItem[]\n  lines: number\n}\n\nexport default function getPreviewCanvas(\n  text: string,\n  chars: Map<string, BMFontChar>,\n  kernings: Map<number, Map<number, number>>,\n  lineHeight: number,\n  fontHeight: number,\n  padding: number = 0,\n): PreviewObject {\n  // const letters = Array.from(new Set(text.replace(/\\r\\n|\\r|\\n/g, '').split('')))\n  const list: PreviewItem[] = []\n  const lines = text.split(/\\r\\n|\\r|\\n/)\n  let minX = 0\n  let minY = 0\n  let maxX = 0\n  let maxY = 0\n  let y = 0\n  let x = 0\n\n  lines.forEach((str, index) => {\n    y = lineHeight * index\n    x = 0\n    const arr = Array.from(str)\n    arr.forEach((letter, idx) => {\n      const char = chars.get(letter)\n      if (!char) return\n      const next = arr[idx + 1]\n      const lk = kernings.get(letter.charCodeAt(0))\n      let kering = 0\n      if (next && lk && lk.has(next.charCodeAt(0))) {\n        kering = lk.get(next.charCodeAt(0)) || 0\n      }\n      const obj = {\n        x: x + char.xoffset + (char.width === 0 ? 0 : padding),\n        y: y + char.yoffset + (char.width === 0 ? 0 : padding),\n        width:\n          (char.width || char.xadvance) - (char.width === 0 ? 0 : padding * 2),\n        height:\n          (char.height || fontHeight) - (char.width === 0 ? 0 : padding * 2),\n        source: char.source,\n        letter: char.letter,\n        next,\n      }\n      x += char.xadvance + kering\n      minX = Math.min(obj.x, minX)\n      minY = Math.min(obj.y, minY)\n      maxX = Math.max(obj.x + obj.width, maxX)\n      maxY = Math.max(obj.y + obj.height, maxY)\n      list.push(obj)\n    })\n  })\n\n  return {\n    lines: lines.length,\n    list,\n    xOffset: minX,\n    yOffset: minY,\n    width: maxX - minX,\n    height: Math.max(maxY - minY, lines.length * lineHeight - minY) + 2,\n  }\n}\n","import React, { useState, FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\n\nimport Box from '@material-ui/core/Box'\nimport TextField from '@material-ui/core/TextField'\nimport Typography from '@material-ui/core/Typography'\n\nimport { useProjectUi } from 'src/store/hooks'\n\nconst Preview: FunctionComponent<unknown> = () => {\n  const { previewText, setPreviewText } = useProjectUi()\n  const [isIME, setIsIME] = useState(false)\n  const [inputText, setInputText] = useState(previewText)\n\n  const handleInput = (event: React.ChangeEvent<HTMLTextAreaElement>): void => {\n    const { value } = event.target\n    if (isIME) {\n      setInputText(value)\n    } else {\n      setInputText(value)\n      if (value !== previewText) setPreviewText(value)\n    }\n  }\n\n  const handleCompositionEnd = (): void => {\n    setIsIME(false)\n    setInputText(inputText)\n    if (inputText !== previewText) setPreviewText(inputText)\n  }\n\n  return (\n    <Box>\n      <Box paddingX={2} marginY={4}>\n        <Typography>Glyphs</Typography>\n      </Box>\n      <Box paddingX={2} marginY={4}>\n        <TextField\n          margin='none'\n          value={isIME ? inputText : previewText}\n          fullWidth\n          multiline\n          rows={7}\n          variant='outlined'\n          inputProps={{ spellCheck: false }}\n          onChange={handleInput}\n          onCompositionStart={() => setIsIME(true)}\n          onCompositionEnd={handleCompositionEnd}\n        />\n      </Box>\n    </Box>\n  )\n}\n\nexport default observer(Preview)\n","import React, { FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport Box from '@material-ui/core/Box'\nimport Typography from '@material-ui/core/Typography'\n\nimport { useProject } from 'src/store/hooks'\n\nimport FormAdjustMetric from 'src/app/layout/common/FormAdjustMetric'\n\nconst GlobalMetric: FunctionComponent<unknown> = () => {\n  const project = useProject()\n  const { glyphList, ui } = project\n  const glyph = glyphList.find((gl) => gl.letter === ui.selectLetter)\n  if (!glyph) return null\n  const { adjustMetric, letter } = glyph\n  const { xAdvance, xOffset, yOffset, setXAdvance, setXOffset, setYOffset } =\n    adjustMetric\n\n  return (\n    <>\n      <Box paddingX={2} marginY={4}>\n        <Typography>{`\"${letter}\" Adjustment`}</Typography>\n      </Box>\n      <FormAdjustMetric\n        xAdvance={xAdvance}\n        xOffset={xOffset}\n        yOffset={yOffset}\n        setXAdvance={setXAdvance}\n        setXOffset={setXOffset}\n        setYOffset={setYOffset}\n      />\n    </>\n  )\n}\n\nexport default observer(GlobalMetric)\n","import React, { useState, useEffect, FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport { deepObserve } from 'mobx-utils'\nimport Box from '@material-ui/core/Box'\nimport Typography from '@material-ui/core/Typography'\nimport Input from '@material-ui/core/Input'\nimport GridInput from 'src/app/components/GridInput'\n\nimport { useProject } from 'src/store/hooks'\nimport { GlyphFont, GlyphImage } from 'src/store'\n\nconst GlobalMetric: FunctionComponent<unknown> = () => {\n  const {\n    glyphList,\n    ui,\n    style: {\n      font: { opentype, size },\n    },\n  } = useProject()\n  const [offset, setOffset] = useState(0)\n  const [glyph, setGlyph] = useState<GlyphFont | GlyphImage | undefined>()\n  const [kerning, setKerning] = useState(0)\n\n  useEffect(() => {\n    setGlyph(glyphList.find((gl) => gl.letter === ui.selectLetter))\n  }, [glyphList, ui.selectLetter])\n\n  useEffect(() => {\n    if (glyph && ui.selectNextLetter && opentype) {\n      const fontScale = (1 / opentype.unitsPerEm) * size\n      setOffset(\n        Math.round(\n          opentype.getKerningValue(\n            opentype.charToGlyphIndex(glyph.letter),\n            opentype.charToGlyphIndex(ui.selectNextLetter),\n          ) * fontScale,\n        ),\n      )\n    }\n  }, [glyph, opentype, size, ui.selectNextLetter])\n\n  const handleChange = (\n    e: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>,\n  ) => {\n    if (glyph)\n      glyph.steKerning(ui.selectNextLetter, Number(e.target.value) - offset)\n  }\n\n  useEffect(() => {\n    let disposer\n\n    if (glyph) {\n      setKerning(glyph.kerning.get(ui.selectNextLetter) || 0)\n      disposer = deepObserve(glyph.kerning, () => {\n        setKerning(glyph.kerning.get(ui.selectNextLetter) || 0)\n      })\n    }\n\n    return disposer\n  }, [glyph, ui.selectNextLetter])\n\n  if (!glyph || !ui.selectNextLetter) return null\n\n  return (\n    <>\n      <Box paddingX={2} marginY={4}>\n        <Typography>{`\"${glyph.letter}\" - \"${ui.selectNextLetter}\" Kerning`}</Typography>\n      </Box>\n      <Box paddingX={2} marginY={4}>\n        <GridInput before='Amount:' after='px'>\n          <Input\n            value={kerning + offset}\n            fullWidth\n            type='number'\n            onChange={handleChange}\n          />\n        </GridInput>\n      </Box>\n    </>\n  )\n}\n\nexport default observer(GlobalMetric)\n","import React, { FunctionComponent } from 'react'\nimport Grid from '@material-ui/core/Grid'\n\nimport PreviewCanvas from './PreviewCanvas'\nimport PreviewText from './PreviewText'\nimport PreviewMertic from './PreviewMertic'\nimport PreviewKerning from './PreviewKerning'\n\nconst Preview: FunctionComponent<unknown> = () => {\n  return (\n    <>\n      <PreviewCanvas />\n      <Grid container alignItems='flex-start'>\n        <Grid item xs={4}>\n          <PreviewText />\n        </Grid>\n        <Grid item xs={4}>\n          <PreviewMertic />\n        </Grid>\n        <Grid item xs={4}>\n          <PreviewKerning />\n        </Grid>\n      </Grid>\n    </>\n  )\n}\n\nexport default Preview\n","import React, { FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport { makeStyles, createStyles } from '@material-ui/core/styles'\nimport ErrorOutlineIcon from '@material-ui/icons/ErrorOutline'\n\nimport { useProjectUi } from 'src/store/hooks'\n\nimport PackView from '../PackView'\nimport Preview from '../Preview'\n\nconst useStyles = makeStyles(({ palette }) =>\n  createStyles({\n    '@keyframes slideDown': {\n      from: { opacity: 0, transform: 'translate(0, -100%)' },\n      to: { opacity: 1, transform: 'translate(0, 0)' },\n    },\n    root: {\n      backgroundColor: palette.background.default,\n      position: 'relative',\n      display: 'flex',\n      flex: 1,\n      flexDirection: 'column',\n    },\n    toast: {\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      width: '100%',\n      zIndex: 10,\n      background: palette.error.main,\n      textAlign: 'center',\n      display: 'flex',\n      justifyContent: 'center',\n      alignItems: 'center',\n      fontSize: 14,\n      padding: 2,\n      animationName: '$slideDown',\n      animationDuration: '300ms',\n      pointerEvents: 'none',\n    },\n    icon: {\n      marginRight: 5,\n    },\n  }),\n)\n\nconst MainView: FunctionComponent<unknown> = () => {\n  const { showPreview, packFailed } = useProjectUi()\n  const classes = useStyles()\n\n  return (\n    <div className={classes.root}>\n      {packFailed ? (\n        <div className={classes.toast}>\n          <ErrorOutlineIcon className={classes.icon} fontSize='inherit' />\n          Packaging failed, try to increase the size of the package please.\n        </div>\n      ) : null}\n      {showPreview ? <Preview /> : <PackView />}\n    </div>\n  )\n}\n\nexport default observer(MainView)\n","import React, { useRef, useState, useEffect, FunctionComponent } from 'react'\n// import { observer } from 'mobx-react'\nimport clsx from 'clsx'\nimport { makeStyles, createStyles } from '@material-ui/core/styles'\n// import Input from '@material-ui/core/Input'\nimport CloseIcon from '@material-ui/icons/Close'\n\nconst useStyles = makeStyles(({ palette }) =>\n  createStyles({\n    root: {\n      minHeight: 'auto',\n      minWidth: '80px',\n      maxWidth: 'none',\n      height: '34px',\n      lineHeight: '16px',\n      padding: '10px',\n      color: 'rgba(255,255,255,0.5)',\n      backgroundColor: 'rgb(45, 45, 45)',\n      borderRight: `1px solid ${palette.background.default}`,\n      textTransform: 'none',\n      display: 'inline-flex',\n      alignItems: 'center',\n      justifyContent: 'space-between',\n      cursor: 'pointer',\n      '&:hover': {\n        '& $icon': {\n          opacity: 1,\n        },\n      },\n      '&:last-child': {\n        borderRight: '0 none',\n      },\n    },\n    selected: {\n      background: palette.background.default,\n      color: '#fff',\n      '& $icon': {\n        opacity: 1,\n      },\n    },\n    name: {\n      whiteSpace: 'nowrap',\n      position: 'relative',\n      background: 'inherit',\n    },\n    editor: {\n      color: 'rgba(0,0,0,0)',\n    },\n    input: {\n      position: 'absolute',\n      width: '100%',\n      height: '100%',\n      left: 0,\n      fontSize: 'inherit',\n      padding: 0,\n      border: '0 none',\n      appearance: 'none',\n      color: 'inherit',\n      background: 'inherit',\n    },\n    icon: {\n      width: '16px',\n      height: '16px',\n      marginLeft: '10px',\n      opacity: 0,\n    },\n  }),\n)\n\ninterface ProjectTabProps {\n  name: string\n  value: number\n  selected?: boolean\n  useRemove?: boolean\n  onRemove?: (\n    e: React.MouseEvent<SVGSVGElement, MouseEvent>,\n    value: number,\n  ) => void\n  onChange?: (\n    e: React.MouseEvent<HTMLDivElement, MouseEvent>,\n    value: number,\n  ) => void\n  onClick?: (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => void\n  onRename?: (name: string, value: number) => void\n}\n\nconst ProjectTab: FunctionComponent<ProjectTabProps> = (\n  props: ProjectTabProps,\n) => {\n  const {\n    name,\n    useRemove,\n    selected,\n    value,\n    onChange,\n    onClick,\n    onRemove,\n    onRename,\n  } = props\n  const [editor, setEditor] = useState(false)\n  const [sname, setSName] = useState(name)\n  const editorRef = useRef<HTMLInputElement>(null)\n  const classes = useStyles()\n\n  const handleRemove = (e: React.MouseEvent<SVGSVGElement, MouseEvent>) => {\n    e.stopPropagation()\n    if (onRemove) onRemove(e, value)\n  }\n\n  const handleSelect = (\n    e: React.MouseEvent<HTMLDivElement, MouseEvent>,\n  ): void => {\n    e.stopPropagation()\n    if (onChange) onChange(e, value)\n    if (onClick) onClick(e)\n  }\n\n  const handleDoubleClick = (\n    e: React.MouseEvent<HTMLDivElement, MouseEvent>,\n  ): void => {\n    e.stopPropagation()\n    if (editorRef.current) {\n      setEditor(true)\n    }\n  }\n\n  const handleEditorEnd = (e: { preventDefault?(): void }) => {\n    if (e.preventDefault) e.preventDefault()\n    setEditor(false)\n  }\n\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.keyCode === 13 && editorRef.current) {\n      editorRef.current.blur()\n    }\n  }\n\n  const handleInput = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setSName(e.target.value)\n  }\n\n  useEffect(() => {\n    if (editor && editorRef.current) editorRef.current.focus()\n    if (!editor && onRename) onRename(sname, value)\n  }, [editor, onRename, sname, value])\n\n  useEffect(() => {\n    setSName(name)\n  }, [name])\n\n  return (\n    <div\n      aria-hidden\n      className={clsx(classes.root, {\n        [classes.selected]: selected,\n      })}\n      onClick={handleSelect}\n      onDoubleClick={handleDoubleClick}\n      title='Double click rename'\n    >\n      <span aria-hidden className={classes.name}>\n        {editor ? sname : name}\n        <input\n          className={classes.input}\n          hidden={!editor}\n          ref={editorRef}\n          value={editor ? sname : name}\n          type='text'\n          onKeyDown={handleKeyDown}\n          onBlur={handleEditorEnd}\n          //   onInput={handleInput}\n          onChange={handleInput}\n        />\n      </span>\n      {useRemove ? (\n        <CloseIcon\n          className={classes.icon}\n          onClick={handleRemove}\n          onDoubleClick={handleRemove}\n        />\n      ) : null}\n    </div>\n  )\n}\n\nexport default ProjectTab\n","import React, { FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport { makeStyles, createStyles } from '@material-ui/core/styles'\nimport Tabs from '@material-ui/core/Tabs'\nimport { useWorkspace } from 'src/store/hooks'\nimport ProjectTab from './ProjectTab'\n\nconst useStyles = makeStyles(({ palette, shadows }) =>\n  createStyles({\n    root: {\n      minHeight: 'auto',\n      width: '100%',\n      boxShadow: shadows[2],\n      background: palette.background.sidebar,\n      position: 'relative',\n      zIndex: 1,\n    },\n  }),\n)\n\nconst ProjectTabs: FunctionComponent<unknown> = () => {\n  const classes = useStyles()\n  const workSpace = useWorkspace()\n  const {\n    addProject,\n    selectProject,\n    removeProject,\n    setProjectName,\n    namedList,\n    activeId,\n  } = workSpace\n\n  const handleChange = (e: unknown, value: number): void => {\n    selectProject(value)\n  }\n\n  const handleRemove = (\n    e: React.MouseEvent<SVGSVGElement, MouseEvent>,\n    value?: number,\n  ): void => {\n    if (typeof value !== 'undefined') removeProject(value)\n  }\n\n  const handleDoubleClick = (): void => {\n    addProject()\n  }\n\n  return (\n    <Tabs\n      classes={classes}\n      value={activeId}\n      onChange={handleChange}\n      indicatorColor='primary'\n      textColor='primary'\n      variant='scrollable'\n      scrollButtons='off'\n      selectionFollowsFocus\n      TabIndicatorProps={{ hidden: true }}\n      onDoubleClick={handleDoubleClick}\n    >\n      {namedList.map((item) => {\n        return (\n          <ProjectTab\n            useRemove={namedList.length > 1}\n            name={item.name}\n            value={item.id}\n            key={item.id}\n            onRename={setProjectName}\n            onRemove={handleRemove}\n          />\n        )\n      })}\n    </Tabs>\n  )\n}\n\nexport default observer(ProjectTabs)\n","import React, { FunctionComponent, useState, useRef } from 'react'\nimport { observer } from 'mobx-react'\nimport { makeStyles, createStyles } from '@material-ui/core/styles'\nimport Box from '@material-ui/core/Box'\nimport Paper from '@material-ui/core/Paper'\nimport Button from '@material-ui/core/Button'\nimport Popper from '@material-ui/core/Popper'\nimport Slider from '@material-ui/core/Slider'\nimport Switch from '@material-ui/core/Switch'\nimport MenuItem from '@material-ui/core/MenuItem'\nimport MenuList from '@material-ui/core/MenuList'\nimport ClickAwayListener from '@material-ui/core/ClickAwayListener'\n\nimport { useProjectUi } from 'src/store/hooks'\n\nconst useStyles = makeStyles(() =>\n  createStyles({\n    slider: {\n      width: '200px',\n    },\n  }),\n)\n\nconst ControlerBar: FunctionComponent<unknown> = () => {\n  const {\n    scale,\n    setTransform,\n    previewScale,\n    setPreviewTransform,\n    showPreview,\n    setShowPreview,\n  } = useProjectUi()\n  const classes = useStyles()\n  const [open, setOpen] = useState(false)\n  const anchorRef = useRef<HTMLButtonElement>(null)\n  const [list] = useState([0.25, 0.5, 0.75, 1, 1.25, 1.5, 5, 10])\n  const handleToggle = () => {\n    setOpen((prevOpen) => !prevOpen)\n  }\n\n  const handleClose = (event: React.MouseEvent<EventTarget>) => {\n    if (\n      anchorRef.current &&\n      anchorRef.current.contains(event.target as HTMLElement)\n    ) {\n      return\n    }\n\n    setOpen(false)\n  }\n\n  const handleChange = (event: unknown, val: number | number[]) => {\n    if (showPreview) {\n      setPreviewTransform({ previewScale: val as number })\n    } else {\n      setTransform({ scale: val as number })\n    }\n  }\n\n  const handleSelect = (val: number) => {\n    // setTransform({ scale: val })\n    handleChange(null, val)\n    setOpen(false)\n  }\n\n  return (\n    <Box paddingX={2} display='flex' justifyContent='space-between'>\n      <Box component='label' display='flex' alignItems='center'>\n        Preview\n        <Switch\n          size='small'\n          color='primary'\n          checked={showPreview}\n          onChange={(e) => setShowPreview(e.target.checked)}\n        />\n      </Box>\n      <Slider\n        className={classes.slider}\n        value={showPreview ? previewScale : scale}\n        min={0.01}\n        max={10}\n        step={0.01}\n        onChange={handleChange}\n      />\n      <Button ref={anchorRef} onClick={handleToggle}>\n        {`${Math.round((showPreview ? previewScale : scale) * 1000) / 10}%`}\n      </Button>\n      <Popper open={open} anchorEl={anchorRef.current} placement='top-end'>\n        <Paper>\n          <ClickAwayListener onClickAway={handleClose}>\n            <MenuList>\n              {list.map((n) => (\n                <MenuItem key={n} onClick={() => handleSelect(n)}>\n                  {`${n * 100}%`}\n                </MenuItem>\n              ))}\n            </MenuList>\n          </ClickAwayListener>\n        </Paper>\n      </Popper>\n    </Box>\n  )\n}\n\nexport default observer(ControlerBar)\n","import React, { useState, FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\n\nimport Paper from '@material-ui/core/Paper'\nimport Grid from '@material-ui/core/Grid'\nimport Checkbox from '@material-ui/core/Checkbox'\nimport InputBase from '@material-ui/core/InputBase'\nimport IconButton from '@material-ui/core/IconButton'\nimport DeleteIcon from '@material-ui/icons/Delete'\n\nimport { GlyphImage } from 'src/store'\nimport { useProject } from 'src/store/hooks'\n\nimport { makeStyles, createStyles } from '@material-ui/core/styles'\n\nconst useStyles = makeStyles((theme) =>\n  createStyles({\n    root: {\n      width: theme.spacing(24),\n      height: theme.spacing(24),\n      margin: theme.spacing(2),\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      position: 'relative',\n    },\n    image: {\n      maxWidth: '100%',\n      maxHeight: '100%',\n      pointerEvents: 'none',\n    },\n    actions: {\n      width: '100%',\n      height: '100%',\n      position: 'absolute',\n      left: 0,\n      top: 0,\n    },\n    inputLabel: {\n      width: '100%',\n      height: '100%',\n      '& input': {\n        textAlign: 'center',\n      },\n    },\n  }),\n)\n\ninterface ImageGlyphProps {\n  glyph: GlyphImage\n  selected?: boolean\n}\n\nconst ImageGlyph: FunctionComponent<ImageGlyphProps> = (\n  props: ImageGlyphProps,\n) => {\n  const classes = useStyles()\n  const { removeImage } = useProject()\n  const [isIME, setIsIME] = useState(false)\n  const { glyph } = props\n  const [inputValue, setInputValue] = useState(glyph.letter)\n  const { changeSelect, selected, setGlyph } = glyph\n\n  const handleChangeGlyph = (e: React.ChangeEvent<HTMLInputElement>): void => {\n    const { value } = e.target\n    if (!isIME) {\n      setGlyph(value)\n    } else {\n      setInputValue(value.slice(0, 1))\n      setGlyph(value.slice(0, 1))\n    }\n  }\n\n  const handleCompositionEnd = (): void => {\n    setIsIME(false)\n    setInputValue((iv) => iv.slice(0, 1))\n    setGlyph(inputValue.slice(0, 1))\n  }\n\n  return (\n    <Paper variant='outlined' className={classes.root}>\n      <img className={classes.image} src={glyph.src} alt={glyph.fileName} />\n      <Grid container direction='column' className={classes.actions}>\n        <Grid item container justifyContent='space-between' alignItems='center'>\n          <Checkbox\n            checked={selected}\n            size='small'\n            color='default'\n            onChange={(e) => changeSelect(e.target.checked)}\n          />\n          <IconButton\n            color='primary'\n            size='small'\n            onClick={() => removeImage(glyph)}\n          >\n            <DeleteIcon fontSize='small' />\n          </IconButton>\n        </Grid>\n        <Grid\n          item\n          xs\n          component='label'\n          className={classes.inputLabel}\n          container\n          alignItems='flex-end'\n        >\n          <InputBase\n            fullWidth\n            value={isIME ? inputValue : glyph.letter}\n            onFocus={(e) => e.target.select()}\n            onInput={handleChangeGlyph}\n            onCompositionEnd={handleCompositionEnd}\n            onCompositionStart={() => setIsIME(true)}\n          />\n        </Grid>\n      </Grid>\n    </Paper>\n  )\n}\n\nexport default observer(ImageGlyph)\n","import React, { FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport { makeStyles, createStyles } from '@material-ui/core'\nimport Box from '@material-ui/core/Box'\n\nimport { useProject } from 'src/store/hooks'\n\nimport ImageGlyph from './ImageGlyph'\n\nconst useStyles = makeStyles(() =>\n  createStyles({\n    root: {\n      width: '100%',\n      display: 'flex',\n      flexWrap: 'wrap',\n    },\n  }),\n)\n\nconst ImageGlyphList: FunctionComponent<unknown> = () => {\n  const { glyphImages } = useProject()\n  const classes = useStyles()\n  return (\n    <Box className={classes.root}>\n      {glyphImages.map((glyph) => {\n        return <ImageGlyph glyph={glyph} key={glyph.src} />\n      })}\n    </Box>\n  )\n}\n\nexport default observer(ImageGlyphList)\n","import React, { FunctionComponent, useState, useEffect } from 'react'\nimport { observer } from 'mobx-react'\nimport clsx from 'clsx'\nimport { makeStyles, createStyles } from '@material-ui/core/styles'\n\nimport Box from '@material-ui/core/Box'\nimport Grid from '@material-ui/core/Grid'\nimport Button from '@material-ui/core/Button'\nimport Accordion from '@material-ui/core/Accordion'\nimport AccordionSummary from '@material-ui/core/AccordionSummary'\nimport AccordionDetails from '@material-ui/core/AccordionDetails'\nimport Typography from '@material-ui/core/Typography'\nimport ExpandMoreIcon from '@material-ui/icons/ExpandMore'\nimport FullscreenIcon from '@material-ui/icons/Fullscreen'\nimport FullscreenExitIcon from '@material-ui/icons/FullscreenExit'\nimport IconButton from '@material-ui/core/IconButton'\nimport PhotoLibraryIcon from '@material-ui/icons/PhotoLibrary'\n\nimport { FileInfo } from 'src/store'\nimport { useProject } from 'src/store/hooks'\n\nimport readFile from 'src/utils/readFile'\n\nimport ImageGlyphList from './ImageGlyphList'\n\nconst useStyles = makeStyles(() =>\n  createStyles({\n    root: {\n      display: 'flex',\n      position: 'relative',\n    },\n    fixed: {\n      position: 'fixed',\n      left: 0,\n      top: 0,\n      zIndex: 999999,\n      width: '100%',\n      height: '100%',\n      '& $panel': {\n        maxHeight: 'none',\n      },\n    },\n    panel: {\n      width: '100%',\n      display: 'flex',\n      flexDirection: 'column',\n      maxHeight: '305px',\n    },\n    continer: {\n      flex: 1,\n      overflow: 'hidden',\n      overflowY: 'auto',\n    },\n    listWrap: {\n      minHeight: '224px',\n      height: '100%',\n      width: '100%',\n      overflow: 'hidden',\n      overflowY: 'auto',\n    },\n  }),\n)\n\nconst LayerBox: FunctionComponent<unknown> = () => {\n  const classes = useStyles()\n  const { addImages } = useProject()\n  const [isFullscreen, setFullscreen] = useState(false)\n  const [open, setOpen] = useState(false)\n  // const [isDroping, setIsDroping] = useState(false)\n\n  const handleLoadFile = (files: FileList) => {\n    const list = Array.from(files).filter((file) => /^image\\//.test(file.type))\n    if (!list.length) return\n    Promise.all(\n      list.map((file) =>\n        readFile(file).then((buffer) => {\n          if (!buffer || typeof buffer === 'string') return null\n\n          const matched = file.name.match(/(\\S)\\.[a-zA-Z0-9]+$/i)\n          return {\n            letter: matched ? matched[1] : '',\n            fileName: file.name,\n            fileType: file.type,\n            buffer,\n          }\n        }),\n      ),\n    ).then((fileList) => {\n      addImages(fileList.filter((f) => f) as FileInfo[])\n    })\n  }\n\n  const handleDrop = (e: React.DragEvent<HTMLElement>): void => {\n    e.preventDefault()\n    handleLoadFile(e.dataTransfer.files)\n  }\n\n  const hanfleToggleFullScreen = (\n    e?: React.MouseEvent<HTMLDivElement, MouseEvent>,\n  ) => {\n    if (e) e.stopPropagation()\n    setFullscreen((f) => !f)\n  }\n\n  const handleToggleOpen = () => {\n    setOpen((o) => isFullscreen || !o)\n  }\n  const handleFilesChange = (e: React.ChangeEvent<HTMLInputElement>): void => {\n    if (!e.target.files) return\n    const { files } = e.target\n    handleLoadFile(files)\n  }\n\n  const handleKeyDown = (e: KeyboardEvent) => {\n    const target = e.target as HTMLElement\n    if (e.keyCode === 27) {\n      if (!target || target.tagName !== 'INPUT') setFullscreen(false)\n      else if (target) target.blur()\n    }\n  }\n\n  useEffect(() => {\n    if (isFullscreen) window.addEventListener('keydown', handleKeyDown)\n    else window.removeEventListener('keydown', handleKeyDown)\n    return () => window.removeEventListener('keydown', handleKeyDown)\n  }, [isFullscreen])\n\n  return (\n    <Box\n      onDragEnter={(e) => e.preventDefault()}\n      onDragOver={(e) => e.preventDefault()}\n      // onDragLeave={handleDrop}\n      onDrop={handleDrop}\n      className={clsx(classes.root, {\n        [classes.fixed]: isFullscreen,\n      })}\n    >\n      <Accordion\n        className={classes.panel}\n        expanded={isFullscreen || open}\n        onChange={handleToggleOpen}\n        TransitionProps={{\n          style:\n            isFullscreen || open\n              ? { flex: 1, overflow: 'hidden', overflowY: 'auto' }\n              : {},\n        }}\n      >\n        <AccordionSummary\n          expandIcon={isFullscreen ? undefined : <ExpandMoreIcon />}\n        >\n          <Grid container alignItems='center'>\n            <Grid item>\n              <Typography>Image Glyph List</Typography>\n            </Grid>\n            <Grid item xs container justifyContent='center'>\n              <Button\n                component='label'\n                color='primary'\n                size='small'\n                variant='contained'\n                startIcon={<PhotoLibraryIcon />}\n              >\n                Select Images\n                <input\n                  hidden\n                  type='file'\n                  multiple\n                  accept='image/*'\n                  onChange={handleFilesChange}\n                />\n              </Button>\n            </Grid>\n            <Grid item>\n              <IconButton component='div' onClick={hanfleToggleFullScreen}>\n                {isFullscreen ? <FullscreenExitIcon /> : <FullscreenIcon />}\n              </IconButton>\n            </Grid>\n          </Grid>\n        </AccordionSummary>\n        <AccordionDetails className={classes.continer}>\n          <Box className={classes.listWrap}>\n            <ImageGlyphList />\n          </Box>\n        </AccordionDetails>\n      </Accordion>\n    </Box>\n  )\n}\nexport default observer(LayerBox)\n","import React, { FunctionComponent } from 'react'\nimport Box from '@material-ui/core/Box'\nimport { makeStyles, createStyles } from '@material-ui/core/styles'\n\nimport MainView from './modules/MainView'\nimport ProjectTabs from './modules/ProjectTabs'\nimport ControlerBar from './modules/ControlerBar'\nimport ImageGlyphList from './modules/ImageGlyphList'\n\nconst useStyles = makeStyles(({ palette, shadows }) =>\n  createStyles({\n    root: {\n      position: 'relative',\n      flex: 1,\n      display: 'flex',\n      flexDirection: 'column',\n      justifyContent: 'center',\n      width: 0,\n    },\n    tabsRoot: {\n      minHeight: 'auto',\n      width: '100%',\n      boxShadow: shadows[2],\n      background: palette.background.sidebar,\n      position: 'relative',\n      zIndex: 1,\n    },\n    tabRoot: {\n      minHeight: 'auto',\n      minWidth: 'auto',\n      maxWidth: 'none',\n      height: '34px',\n      color: 'rgba(255,255,255,0.5)',\n      borderRight: `1px solid ${palette.background.default}`,\n      textTransform: 'none',\n    },\n    tabSelected: {\n      background: palette.background.default,\n    },\n    tabWrapper: {\n      color: '#FFF',\n    },\n  }),\n)\n\nconst WorkSpace: FunctionComponent<unknown> = () => {\n  const classes = useStyles()\n\n  return (\n    <Box className={classes.root}>\n      <ProjectTabs />\n      <MainView />\n      <ControlerBar />\n      <ImageGlyphList />\n    </Box>\n  )\n}\n\nexport default WorkSpace\n","import React from 'react'\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles'\nimport Button from '@material-ui/core/Button'\nimport Snackbar from '@material-ui/core/Snackbar'\nimport IconButton from '@material-ui/core/IconButton'\nimport CloseIcon from '@material-ui/icons/Close'\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    close: {\n      padding: theme.spacing(0.5),\n    },\n  }),\n)\n\nexport interface SnackbarMessage {\n  message: string\n  key: number\n}\n\nexport interface State {\n  open: boolean\n  snackPack: SnackbarMessage[]\n  messageInfo?: SnackbarMessage\n}\n\nexport default function ConsecutiveSnackbars() {\n  const classes = useStyles()\n  const [open, setOpen] = React.useState(false)\n\n  const handleClose = (\n    event: React.SyntheticEvent | MouseEvent,\n    reason?: string,\n  ) => {\n    if (reason === 'clickaway') {\n      return\n    }\n    setOpen(false)\n  }\n\n  const updateVersion = React.useCallback((event) => {\n    const { detail } = event\n    setOpen(!!detail)\n  }, [])\n\n  const handleReload = () => {\n    window.location.reload()\n  }\n\n  React.useEffect(() => {\n    window.addEventListener('updateVerion', updateVersion, false)\n    return () =>\n      window.removeEventListener('updateVerion', updateVersion, false)\n  }, [updateVersion])\n\n  return (\n    <Snackbar\n      anchorOrigin={{\n        vertical: 'bottom',\n        horizontal: 'left',\n      }}\n      open={open}\n      onClose={handleClose}\n      message='New version is available.'\n      action={\n        <React.Fragment>\n          <Button color='secondary' size='small' onClick={handleReload}>\n            Reload\n          </Button>\n          <IconButton\n            aria-label='close'\n            color='inherit'\n            className={classes.close}\n            onClick={handleClose}\n          >\n            <CloseIcon />\n          </IconButton>\n        </React.Fragment>\n      }\n    />\n  )\n}\n","import React, { FunctionComponent } from 'react'\nimport { observer } from 'mobx-react'\nimport Box from '@material-ui/core/Box'\nimport Backdrop from '@material-ui/core/Backdrop'\nimport CircularProgress from '@material-ui/core/CircularProgress'\nimport { makeStyles, createStyles } from '@material-ui/core/styles'\n\nimport useStores from 'src/store/hooks'\n\nimport LeftBar from '../LeftBar'\nimport TitleBar from '../TitleBar'\nimport RightBar from '../RightBar'\nimport WorkSpace from '../WorkSpace'\nimport UpdateToast from './UpdateToast'\n\nconst useStyles = makeStyles(({ zIndex }) =>\n  createStyles({\n    root: {\n      width: '100%',\n      height: '100%',\n      display: 'flex',\n      flexDirection: 'column',\n    },\n    content: {\n      display: 'flex',\n      flex: 1,\n      position: 'relative',\n      height: '0',\n      overflow: 'hidden',\n    },\n    loadingBackdrop: {\n      zIndex: zIndex.drawer + 1,\n      color: '#fff',\n    },\n  }),\n)\n\nconst Wrap: FunctionComponent<unknown> = () => {\n  const classes = useStyles()\n  const { ui } = useStores()\n\n  return (\n    <Box className={classes.root}>\n      <TitleBar />\n      <UpdateToast />\n      <Box className={classes.content}>\n        <LeftBar />\n        <WorkSpace />\n        <RightBar />\n      </Box>\n      <Backdrop className={classes.loadingBackdrop} open={!!ui.globalLoader}>\n        <CircularProgress color='inherit' />\n      </Backdrop>\n    </Box>\n  )\n}\n\nexport default observer(Wrap)\n","import React from 'react'\nimport { Provider } from 'mobx-react'\nimport { SnackbarProvider } from 'notistack'\nimport CssBaseline from '@material-ui/core/CssBaseline'\nimport { ThemeProvider } from '@material-ui/core/styles'\n\nimport createStore from 'src/store'\nimport theme from './theme'\n\nimport Wrap from './layout/Wrap'\n\nfunction App(): JSX.Element {\n  return (\n    <ThemeProvider theme={theme}>\n      <CssBaseline />\n      <Provider {...createStore()}>\n        <SnackbarProvider\n          anchorOrigin={{\n            horizontal: 'center',\n            vertical: 'top',\n          }}\n        >\n          <Wrap />\n        </SnackbarProvider>\n      </Provider>\n    </ThemeProvider>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n    ),\n)\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void\n  onUpdate?: (registration: ServiceWorkerRegistration) => void\n}\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href)\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config)\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://cra.link/PWA',\n          )\n        })\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config)\n      }\n    })\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing\n        if (installingWorker == null) {\n          return\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://cra.link/PWA.',\n              )\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration)\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.')\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration)\n              }\n            }\n          }\n        }\n      }\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error)\n    })\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type')\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload()\n          })\n        })\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config)\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.',\n      )\n    })\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister()\n      })\n      .catch((error) => {\n        console.error(error.message)\n      })\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport * as Sentry from '@sentry/react'\nimport { Integrations } from '@sentry/tracing'\n\nimport App from './app/App'\n\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration'\n\nif (process.env.REACT_APP_SENTRY_DSN) {\n  Sentry.init({\n    dsn: process.env.REACT_APP_SENTRY_DSN,\n    release: process.env.REACT_APP_SENTRY_RELEASE || 'test',\n    integrations: [new Integrations.BrowserTracing()],\n    tracesSampleRate: 1.0,\n    environment: process.env.NODE_ENV,\n  })\n}\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://cra.link/PWA\nserviceWorkerRegistration.register({\n  onUpdate(registration) {\n    const worker = registration.waiting\n    if (!worker) return\n\n    const channel = new MessageChannel()\n\n    channel.port1.onmessage = () => {\n      window.dispatchEvent(new CustomEvent('updateVerion', { detail: worker }))\n    }\n\n    worker.postMessage({ type: 'SKIP_WAITING' }, [channel.port2])\n  },\n})\n"],"sourceRoot":""}